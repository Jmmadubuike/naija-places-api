var od = Object.defineProperty; var ad = (n, t, e) => t in n ? od(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e; var V = (n, t, e) => ad(n, typeof t != "symbol" ? t + "" : t, e); import { d as z, m as rd, c as K, u as ld, o as M, a as O, b as _, n as Q, t as q, e as N, r as Qt, f as $, g as W, h as ul, i as et, j as hl, k as cd, l as as, w as ne, p as dd, q as Ws, s as fl, v as ud, x as hd, y as fd, z as pl, A as pd, B as Ai, C as Xn, D as Se, E as Gn, F as Pn, G as Wt, H as gs, I as P, J as dt, K as Et, L as j, M as D, T as li, N as sn, O as Lt, P as se, _ as J, Q as gd, R as md, S as $o, U as Ft, V as Vt, W as on, X as Qi, Y as ci, Z as Do, $ as bd, a0 as vd, a1 as gl, a2 as di, a3 as ml, a4 as he, a5 as ui, a6 as Ie, a7 as _d, a8 as bl, a9 as yd, aa as vl, ab as hi, ac as xd, ad as _l, ae as yl, af as wd, ag as kd, ah as Sd, ai as Md, aj as Pd } from "./framework.DBpHzKZJ.js"; const Cd = { class: "flex" }, Td = { class: "flex-shrink-0" }, Od = { class: "ml-3" }, Ld = { class: "ml-auto pl-3" }, Ad = { class: "-mx-1.5 -my-1.5" }, $d = _("span", { class: "sr-only" }, "Dismiss", -1), Dd = _("i", { class: "ri-close-fill h-5 w-5" }, null, -1), Ed = [$d, Dd], Rd = z({ __name: "CAlert", props: rd({ type: { type: String, default: "default" }, message: String }, { showing: { default: !1 }, showingModifiers: {} }), emits: ["update:showing"], setup (n) { const t = K(() => { const i = { default: { btn: "text-gray-500 focus:ring-gray-600 bg-gray-50 hover:bg-gray-100 focus:ring-offset-gray-700", text: "text-gray-500", bg: "bg-gray-50" }, success: { btn: "text-green-500 focus:ring-green-600 bg-green-50 hover:bg-green-100 focus:ring-offset-green-50", text: "text-green-800", bg: "bg-green-50" }, warning: { btn: "text-amber-500 focus:ring-amber-600 bg-amber-50 hover:bg-amber-100 focus:ring-offset-amber-700", text: "text-amber-500", bg: "bg-amber-50" }, info: { btn: "text-blue-500 focus:ring-blue-600 bg-blue-50 hover:bg-blue-100 focus:ring-offset-blue-50", text: "text-blue-800", bg: "bg-blue-50" }, error: { btn: "text-red-500 focus:ring-red-600 bg-red-50 hover:bg-red-100 focus:ring-offset-red-50", text: "text-red-800", bg: "bg-red-50" } }; return i[s.type] || i.default }), e = ld(n, "showing"), s = n; return (i, o) => e.value && n.message ? (M(), O("div", { key: 0, class: Q(["rounded-md p-4 my-2", t.value.bg]) }, [_("div", Cd, [_("div", Td, [_("i", { class: Q(["ri-checkbox-circle-fill h-5 w-5", t.value.text]) }, null, 2)]), _("div", Od, [_("p", { class: Q(["text-sm font-medium", t.value.text]) }, q(n.message), 3)]), _("div", Ld, [_("div", Ad, [_("button", { type: "button", class: Q(["inline-flex rounded-md p-1.5 focus:outline-none focus:ring-2 focus:ring-offset-2", t.value.btn]), onClick: o[0] || (o[0] = a => e.value = !e.value) }, Ed, 2)])])])], 2)) : N("", !0) } }), Id = Object.freeze(Object.defineProperty({ __proto__: null, default: Rd }, Symbol.toStringTag, { value: "Module" })), Nd = ["type"], Fd = ["href"], Vd = { key: 0 }, Xe = { __name: "CButton", props: { loading: Boolean, square: Boolean, dense: Boolean, label: String, icon: String, type: String, href: String, to: String }, setup (n) { return (t, e) => { const s = Qt("CSpinner"); return !n.href && !n.to ? (M(), O("button", { key: 0, type: n.type, class: Q(["flex justify-center text-sm font-medium border border-transparent shadow-sm focus:outline-none", { "px-4 py-2": !n.dense && !/p[x,y]?-\d+/.test(t.$attrs.class), "rounded-md": !n.square, "py-0.5 px-0.5": n.dense && !/p[x,y]?-\d+/.test(t.$attrs.class), "focus:ring-2 focus:ring-offset-2": !/focus:ring-+/.test(t.$attrs.class) }]) }, [$(t.$slots, "icon", { loading: n.loading }, () => [n.loading ? N("", !0) : (M(), O("i", { key: 0, class: Q(["text-white", n.icon]) }, null, 2))]), $(t.$slots, "loading", { loading: n.loading }, () => [n.loading ? (M(), W(s, { key: 0 })) : N("", !0)]), n.loading ? N("", !0) : $(t.$slots, "default", { key: 0, loading: n.loading }, () => [_("span", null, q(n.label), 1)])], 10, Nd)) : (M(), O("a", { key: 1, class: Q(["flex justify-center text-sm font-medium border border-transparent shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2", { "px-4 py-2": !n.dense && !/p[x,y]?-\d+/.test(t.$attrs.class), "rounded-md": !n.square, "py-0.5 px-0.5": n.dense && !/p[x,y]?-\d+/.test(t.$attrs.class), "focus:ring-2 focus:ring-offset-2": !/focus:ring-+/.test(t.$attrs.class) }]), href: n.href || n.to }, [$(t.$slots, "icon", { loading: n.loading }, () => [n.loading ? N("", !0) : (M(), O("i", { key: 0, class: Q(n.icon) }, null, 2))]), $(t.$slots, "loading", { loading: n.loading }, () => [n.loading ? (M(), W(s, { key: 0 })) : N("", !0)]), $(t.$slots, "default", { loading: n.loading }, () => [n.loading ? N("", !0) : (M(), O("span", Vd, q(n.label), 1))])], 10, Fd)) } } }, Bd = Object.freeze(Object.defineProperty({ __proto__: null, default: Xe }, Symbol.toStringTag, { value: "Module" })), zd = _("circle", { class: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", "stroke-width": "4" }, null, -1), jd = _("path", { class: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" }, null, -1), Hd = [zd, jd], Wd = { __name: "CSpinner", props: { size: { type: String, default: "sm" } }, setup (n) { const t = K(() => { const s = { xs: "w-2 h-2", sm: "w-5 h-5", md: "w-10 h-10", lg: "w-24 h-24", xl: "w-36 h-36" }; return s[e.size] || s.sm }), e = n; return (s, i) => (M(), O("svg", { class: Q(["text-white animate-spin", t.value]), xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" }, Hd, 2)) } }, Ud = Object.freeze(Object.defineProperty({ __proto__: null, default: Wd }, Symbol.toStringTag, { value: "Module" }));/**
 * vue-demi v0.14.7
 * Copyright (c) 2020-present, Anthony Fu
 * @license MIT
 */var Yd = !1;/*!
 * pinia v2.2.1
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */let xl; const fi = n => xl = n, wl = Symbol(); function Zi (n) { return n && typeof n == "object" && Object.prototype.toString.call(n) === "[object Object]" && typeof n.toJSON != "function" } var zn; (function (n) { n.direct = "direct", n.patchObject = "patch object", n.patchFunction = "patch function" })(zn || (zn = {})); function Kd () { const n = ul(!0), t = n.run(() => et({})); let e = [], s = []; const i = hl({ install (o) { fi(i), i._a = o, o.provide(wl, i), o.config.globalProperties.$pinia = i, s.forEach(a => e.push(a)), s = [] }, use (o) { return !this._a && !Yd ? s.push(o) : e.push(o), this }, _p: e, _a: null, _e: n, _s: new Map, state: t }); return i } const kl = () => { }; function ya (n, t, e, s = kl) { n.push(t); const i = () => { const o = n.indexOf(t); o > -1 && (n.splice(o, 1), s()) }; return !e && hd() && fd(i), i } function pn (n, ...t) { n.slice().forEach(e => { e(...t) }) } const qd = n => n(), xa = Symbol(), $i = Symbol(); function to (n, t) { n instanceof Map && t instanceof Map ? t.forEach((e, s) => n.set(s, e)) : n instanceof Set && t instanceof Set && t.forEach(n.add, n); for (const e in t) { if (!t.hasOwnProperty(e)) continue; const s = t[e], i = n[e]; Zi(i) && Zi(s) && n.hasOwnProperty(e) && !Ws(s) && !fl(s) ? n[e] = to(i, s) : n[e] = s } return n } const Xd = Symbol(); function Gd (n) { return !Zi(n) || !n.hasOwnProperty(Xd) } const { assign: Oe } = Object; function Jd (n) { return !!(Ws(n) && n.effect) } function Qd (n, t, e, s) { const { state: i, actions: o, getters: a } = t, r = e.state.value[n]; let l; function c () { r || (e.state.value[n] = i ? i() : {}); const d = pd(e.state.value[n]); return Oe(d, o, Object.keys(a || {}).reduce((u, h) => (u[h] = hl(K(() => { fi(e); const f = e._s.get(n); return a[h].call(f, f) })), u), {})) } return l = Sl(n, c, t, e, s, !0), l } function Sl (n, t, e = {}, s, i, o) { let a; const r = Oe({ actions: {} }, e), l = { deep: !0 }; let c, d, u = [], h = [], f; const g = s.state.value[n]; !o && !g && (s.state.value[n] = {}), et({}); let m; function v (x) { let S; c = d = !1, typeof x == "function" ? (x(s.state.value[n]), S = { type: zn.patchFunction, storeId: n, events: f }) : (to(s.state.value[n], x), S = { type: zn.patchObject, payload: x, storeId: n, events: f }); const C = m = Symbol(); pl().then(() => { m === C && (c = !0) }), d = !0, pn(u, S, s.state.value[n]) } const p = o ? function () { const { state: S } = e, C = S ? S() : {}; this.$patch(T => { Oe(T, C) }) } : kl; function b () { a.stop(), u = [], h = [], s._s.delete(n) } const y = (x, S = "") => { if (xa in x) return x[$i] = S, x; const C = function () { fi(s); const T = Array.from(arguments), R = [], I = []; function H (F) { R.push(F) } function E (F) { I.push(F) } pn(h, { args: T, name: C[$i], store: w, after: H, onError: E }); let B; try { B = x.apply(this && this.$id === n ? this : w, T) } catch (F) { throw pn(I, F), F } return B instanceof Promise ? B.then(F => (pn(R, F), F)).catch(F => (pn(I, F), Promise.reject(F))) : (pn(R, B), B) }; return C[xa] = !0, C[$i] = S, C }, k = { _p: s, $id: n, $onAction: ya.bind(null, h), $patch: v, $reset: p, $subscribe (x, S = {}) { const C = ya(u, x, S.detached, () => T()), T = a.run(() => ne(() => s.state.value[n], R => { (S.flush === "sync" ? d : c) && x({ storeId: n, type: zn.direct, events: f }, R) }, Oe({}, l, S))); return C }, $dispose: b }, w = dd(k); s._s.set(n, w); const A = (s._a && s._a.runWithContext || qd)(() => s._e.run(() => (a = ul()).run(() => t({ action: y })))); for (const x in A) { const S = A[x]; if (Ws(S) && !Jd(S) || fl(S)) o || (g && Gd(S) && (Ws(S) ? S.value = g[x] : to(S, g[x])), s.state.value[n][x] = S); else if (typeof S == "function") { const C = y(S, x); A[x] = C, r.actions[x] = S } } return Oe(w, A), Oe(ud(w), A), Object.defineProperty(w, "$state", { get: () => s.state.value[n], set: x => { v(S => { Oe(S, x) }) } }), s._p.forEach(x => { Oe(w, a.run(() => x({ store: w, app: s._a, pinia: s, options: r }))) }), g && o && e.hydrate && e.hydrate(w.$state, g), c = !0, d = !0, w } function Zd (n, t, e) { let s, i; const o = typeof t == "function"; s = n, i = o ? e : t; function a (r, l) { const c = cd(); return r = r || (c ? as(wl, null) : null), r && fi(r), r = xl, r._s.has(s) || (o ? Sl(s, t, i, r) : Qd(s, i, r)), r._s.get(s) } return a.$id = s, a } const Jt = Zd("bootstrap", () => { const n = et({}), t = et(null), e = et({}), s = et(); function i (r, l) { n.value = r, t.value = l } function o () { return new Promise(() => { t.value = null, n.value = {} }) } function a (r) { s.value = r } return { user: n, token: t, cache: e, redirect: s, clearAuth: o, setRedirect: a, saveAuthUser: i } }); class Dn { constructor(t, e, s, i) { this.s = t, this.k = e, this.$dhy = s, this.$exp = i } get v () { return this.$dhy(this.s) } get e () { return this.$exp(this.s) } } class wa extends Dn { constructor(t, e, s, i, o) { super(t, e, s, i), this.$upd = o } set v (t) { this.$upd(this.s, t) } get v () { return super.v } } const Di = "undefined", tu = Promise, pi = Object, vn = void 0, Ml = null, En = !0, Jn = !1, eu = (n, t, e) => n.then(t, e), nu = (n, t, e) => JSON.stringify(n, t, e), su = (n, t = 0) => setTimeout(n, t), iu = n => pi.keys(n), ou = (n, t) => n.forEach(t), Pl = (n, ...t) => n.push(...t), au = (n, t) => n.map(t), ru = n => n.shift(), lu = n => n.length, gi = n => typeof n, ka = (n, t) => n.includes(t); typeof window === Di && (typeof process !== Di && process.cwd); const Sa = "memory", cu = "restore", Ot = () => { }, Us = n => n, _t = n => gi(n) === "function", ue = n => gi(n) === "number" && !Number.isNaN(n), Cl = n => gi(n) === "string", eo = n => n !== Ml && gi(n) === "object", Tl = n => pi.prototype.toString.call(n), Me = n => Tl(n) === "[object Object]", Ut = (n, t) => n instanceof t, ze = n => n ? n.getTime() : Date.now(), ge = n => n.context, an = n => n.config, Ol = n => n.options, du = n => Ol(ge(n)), uu = n => { const { params: t, headers: e } = an(n); return nu([n.type, n.url, t, n.data, e]) }, qt = n => n.key, Ll = (n, t, e = []) => { const s = _t(n) ? n(...e) : n; return t(!!s.key, "hook handler must be a method instance or a function that returns method instance"), s }, Al = n => { const t = Tl(n); return /^\[object (Blob|FormData|ReadableStream|URLSearchParams)\]$/i.test(t) || Ut(n, ArrayBuffer) }, rs = (n, ...t) => pi.assign(n, ...t), hu = (n, ...t) => { const e = {}; for (const s in n) t.includes(s) || (e[s] = n[s]); return e }, ls = n => { const { cacheFor: t } = an(n), e = l => ue(l) ? ze() + l : ze(l || vn); let s = Sa, i = () => 0, o = Jn, a = vn; const r = _t(t); if (!r) { let l = t; if (Me(t)) { const { mode: c = Sa, expire: d, tag: u } = t || {}; s = c, o = c === cu, a = u ? u.toString() : vn, l = d } i = c => e(_t(l) ? l({ method: n, mode: c }) : l) } return { f: t, c: r, e: i, m: s, s: o, t: a } }, ht = (n, ...t) => new n(...t), Eo = (n, t = []) => _t(n) ? n(...t) : n, fu = (n, t) => _t(n) ? n : [Jn, Ml].includes(n) ? Ot : t, pu = (n = 0) => { let t = vn; return e => { t && clearTimeout(t), t = su(e, n) } }, gu = (n = Jn) => { const t = []; let e = vn, s = !1; const i = async () => { for (s = !0; lu(t) > 0;) { const r = ru(t); r && await r() } e && e(), s = !1 }; return { addQueue: r => ht(tu, (l, c) => { Pl(t, () => eu(r(), l, u => { n ? l(vn) : c(u) })), s || i() }), onComplete: r => { e = r } } }, Ys = (n, t, e = En, s, i) => { const o = () => { i && s && (n = t(n, s, i), n !== i[s] && (i[s] = n)) }; if (e && o(), eo(n)) for (const a in n) Ut(n, String) || Ys(n[a], t, e, a, n); return !e && o(), n }; function Ro (n, t = { trackedKeys: {}, bindError: Jn }) { const e = d => n.ref ? n.ref(d) : { current: d }; t = e(t).current; const s = d => (n.export || Us)(d, t), i = d => { if (!_t(n.memorize)) return d; const u = n.memorize(d); return u.memorized = !0, u }, { dehydrate: o } = n, a = (d, u, h) => d !== o(u, h, t) && t.trackedKeys[h] && n.update(d, u, h, t), r = d => au(d, u => Ut(u, Dn) ? u.e : u), l = [], c = {}; return { create: (d, u) => (Pl(l, u), ht(wa, n.create(d, u, t), u, h => o(h, u, t), s, (h, f) => a(f, h, u))), computed: (d, u, h) => (ou(u, f => { f.k && (c[f.k] = !0) }), ht(Dn, n.computed(d, r(u), h, t), h, f => o(f, h, t), s)), effectRequest: d => n.effectRequest(d, t), ref: e, watch: (d, u) => n.watch(r(d), u, t), onMounted: d => n.onMounted(d, t), onUnmounted: d => n.onUnmounted(d, t), __referingObj: t, exposeProvider: d => { const u = {}, h = {}; for (const p in d) { const b = d[p]; if (_t(b)) u[p] = p.startsWith("on") ? (...k) => (b(...k), v) : b.memorized ? b : i(b); else { const k = Ut(b, Dn); k && (h[p] = b.s), pi.defineProperty(u, p, { get: () => (t.trackedKeys[p] = En, k ? b.e : b), set: Ot, enumerable: En, configurable: En }) } } const { update: f, __proxyState: g } = u; t.trackedKeys = { ...c }, t.bindError = Jn; const m = { __referingObj: t, update: i(p => { iu(p).forEach(b => { ka(l, b) ? a(p[b], h[b], b) : b in u && _t(f) && f({ [b]: p[b] }) }) }), __proxyState: i(p => ka(l, p) && Ut(d[p], Dn) ? (t.trackedKeys[p] = En, d[p]) : g(p)) }, v = rs(u, m); return v }, objectify: (d, u) => d.reduce((h, f) => (h[f.k] = u ? f[u] : f, h), {}), transformState2Proxy: (d, u) => ht(wa, d, u, h => o(h, u, t), s, (h, f) => a(f, h, u)) } } const mu = "$a.", mi = (n, t) => mu + n + t, Ei = "undefined", Tt = Promise, $l = n => Tt.resolve(n), Dl = n => Tt.reject(n), bi = Object, Io = RegExp, X = void 0, bu = null, rt = !0, st = !1, Le = (n, t, e) => n.then(t, e), Ze = (n, t) => n.catch(t), El = (n, t) => n.finally(t), Rl = (n, t, e) => JSON.stringify(n, t, e), vu = n => JSON.parse(n), Ks = (n, t = 0) => setTimeout(n, t), no = n => clearTimeout(n), Ne = n => bi.keys(n), _u = n => bi.values(n), ae = (n, t) => n.forEach(t), Zt = (n, ...t) => n.push(...t), ie = (n, t) => n.map(t), Fe = (n, t) => n.filter(t), Ge = (n, t, e = 0, ...s) => n.splice(t, e, ...s), vt = n => n.length, re = n => Array.isArray(n), rn = (n, t) => delete n[t], Ma = (n, t) => n.includes(t), yu = typeof window === Ei && (typeof process !== Ei ? typeof process.cwd == "function" : typeof Deno !== Ei), No = "memory", xn = "restore", Ri = "undefined"; typeof window === Ri && (typeof process !== Ri && process.cwd); const xu = (n, ...t) => new n(...t); class wu extends Error {
  constructor(t, e, s) {
    super(e + (s ? `

For detailed: https://alova.js.org/error#${s}` : "")), this.name = `[alova${t ? `/${t}` : ""}]`
  }
} const cs = (n = "") => (t, e, s) => { if (!t) throw xu(wu, n, e, s) }; let Fo = { autoHitCache: "global", ssr: yu }; const ms = "color: black; font-size: 12px; font-weight: bolder"; var ku = (n, t, e, s) => { const i = console, o = (...h) => console.log(...h), { url: a } = t, r = e === xn, l = "\x1B[42m%s\x1B[49m", c = "\x1B[32m%s\x1B[39m", d = ` [HitCache]${a} `, u = () => Array(vt(d) + 1).join("^"); Fo.ssr ? (o(l, d), o(c, " Cache ", n), o(c, " Mode  ", e), r && o(c, " Tag   ", s), o(c, u())) : (i.groupCollapsed ? i.groupCollapsed("%cHitCache", "padding: 2px 6px; background: #c4fcd3; color: #53b56d;", a) : o(l, d), o("%c[Cache]", ms, n), o("%c[Mode]", ms, e), r && o("%c[Tag]", ms, s), o("%c[Method]", ms, t), i.groupEnd ? i.groupEnd() : o(c, u())) }; const so = n => `hss.${n}`, Il = "hsr.", io = n => Il + n, qs = "$$hsrs", Nl = "__$<>$__", oo = (n, t) => { n[t] = 0 }, jn = async (n, t, e, s, i, o, a) => { if (s > ze() && e) { const r = mi(n, t); if (await i.set(r, Fe([e, s === 1 / 0 ? X : s, a], Boolean)), o) { const l = {}, c = []; ae(o, h => { const f = Ut(h, Io), g = f ? h.source + (h.flags ? Nl + h.flags : "") : h; g && (f && !l[g] && Zt(c, g), oo(l, f ? io(g) : so(g))) }); const d = ie(Ne(l), async h => { const f = await i.get(h) || {}; oo(f, r), await i.set(h, f) }), u = async () => { if (vt(c)) { const h = await i.get(qs) || []; Zt(h, ...c), await i.set(qs, h) } }; await Tt.all([...d, u()]) } } }, ao = async (n, t, e) => { const s = mi(n, t); await e.remove(s) }, Fl = async (n, t, e, s) => { const i = await e.get(mi(n, t)); if (i) { const [o, a, r] = i; if (r === s && (!a || a > ze())) return i; await ao(n, t, e) } }, _n = async (n, t, e, s) => { const i = await Fl(n, t, e, s); return i ? i[0] : X }, Pa = async n => Tt.all(n.map(t => t.clear())), Su = async (n, t, e) => { const s = `${t}`, i = {}, o = so(n); i[o] = await e.get(o); let a; if (t) { const d = so(s); i[d] = await e.get(d), a = await e.get(qs); const u = []; a && vt(a) && (ae(a, h => { const [f, g] = h.split(Nl); ht(Io, f, g).test(s) && Zt(u, h) }), await Tt.all(ie(u, async h => { const f = io(h); i[f] = await e.get(f) }))) } const r = async d => { try { await e.remove(d); for (const u in i) { const h = i[u]; h && rn(h, d) } } catch { } }, l = {}; await Tt.all(ie(Ne(i), async d => { const u = i[d]; if (u) { const h = []; for (const f in u) l[f] || (oo(l, f), Zt(h, r(f))); await Tt.all(h) } })); const c = vt(a || []); await Tt.all(ie(Ne(i), async d => { const u = i[d]; u && (vt(Ne(u)) ? await e.set(d, u) : (await e.remove(d), d.includes(Il) && a && (a = Fe(a, h => io(h) !== d)))) })), c !== vt(a || []) && await e.set(qs, a) }; var Mu = n => { const { data: t, config: e } = n, s = { ...e }, { headers: i = {}, params: o = {} } = s, a = ge(n); s.headers = { ...i }, s.params = { ...o }; const r = ht(ee, n.type, a, n.url, s, t); return rs(r, { ...n, config: s }) }; const ro = async (n, { policy: t = "all" } = {}) => { if (n && n.key) { const { id: e, l1Cache: s, l2Cache: i } = ge(n), o = qt(n), { f: a, c: r, s: l, e: c, t: d } = ls(n); if (r) return a(); let u = t !== "l2" ? await _n(e, o, s) : X; return t === "l2" ? u = await _n(e, o, i, d) : t === "all" && !u && l && c(xn) > ze() && (u = await _n(e, o, i, d)), u } }, Ii = async (n, t, { policy: e = "all" } = {}) => { const i = (re(n) ? n : [n]).map(async o => { const { hitSource: a } = o, { id: r, l1Cache: l, l2Cache: c } = ge(o), d = qt(o), { e: u, s: h, t: f, c: g } = ls(o); if (g) return; let m = t; if (_t(t)) { let v = e !== "l2" ? await _n(r, d, l) : X; if ((e === "l2" || e === "all" && !v && h && u(xn) > ze()) && (v = await _n(r, d, c, f)), m = t(v), m === X) return } return Tt.all([e !== "l2" && jn(r, d, m, u(No), l, a), e === "l2" || e === "all" && h ? jn(r, d, m, u(xn), c, a, f) : X]) }); return Tt.all(i) }, Pu = async n => { if (!n) { await Tt.all([Pa(Xs), Pa(Gs)]); return } const e = (re(n) ? n : [n]).map(s => { const { id: i, l1Cache: o, l2Cache: a } = ge(s), { c: r } = ls(s); if (r) return; const l = qt(s); return Tt.all([ao(i, l, o), ao(i, l, a)]) }); await Tt.all(e) }, Cu = async n => { const { autoHitCache: t } = Fo, { l1Cache: e, l2Cache: s } = ge(n), i = qt(n), { name: o } = an(n), a = { global: [...Xs, ...Gs], self: [e, s], close: [] }[t]; a && vt(a) && await Tt.all(ie(a, r => Su(i, o, r))) }, Ca = {}, Tu = (n, t, e) => { n = n.endsWith("/") ? n.slice(0, -1) : n, t !== "" && (t = t.match(/^(\/|https?:\/\/)/) ? t : `/${t}`); const s = n + t, i = ie(Fe(Ne(e), o => e[o] !== X), o => `${o}=${e[o]}`).join("&"); return i ? +s.includes("?") ? `${s}&${i}` : `${s}?${i}` : s }; function Ou (n, t) { let e = rt, s; const i = ht(Tt, a => { s = a }); return { abort: () => { Le(i, a => a && a.abort()) }, onDownload: a => { Le(i, r => r && r.onDownload && r.onDownload(a)) }, onUpload: a => { Le(i, r => r && r.onUpload && r.onUpload(a)) }, response: async () => { const { beforeRequest: a = Ot, responded: r, requestAdapter: l, cacheLogger: c } = du(n), d = qt(n), { s: u, t: h, m: f, e: g } = ls(n), { id: m, l1Cache: v, l2Cache: p, snapshots: b } = ge(n), { cacheFor: y } = an(n), { hitSource: k } = n; let w = await (_t(y) ? y() : t ? X : _n(m, d, v)); if (f === xn && !w) { const lt = await Fl(m, d, p, h); if (lt) { const [bt, St] = lt; await jn(m, d, bt, St, v, k), w = bt } } const L = Mu(n); await a(L); const { baseURL: A, url: x, type: S, data: C } = L, { params: T = {}, headers: R = {}, transform: I = Us, shareRequest: H } = an(L), E = Ca[m] = Ca[m] || {}; let B = E[d], F = Us, G = X, nt = Ot; if (_t(r)) F = r; else if (Me(r)) { const { onSuccess: lt, onError: bt, onComplete: St } = r; F = _t(lt) ? lt : F, G = _t(bt) ? bt : G, nt = _t(St) ? St : nt } if (w !== X) return s(), fu(c, ku)(w, L, f, h), nt(L), w; if (e = st, !H || !B) { const lt = l({ url: Tu(A, x, T), type: S, data: C, headers: R }, L); B = E[d] = lt } s(B); const kt = async (lt, bt, St = rt) => { const ft = await lt, Rt = await I(ft, bt || {}); b.save(n); try { await Cu(L) } catch { } const $t = L.data; if ((!$t || !Al($t)) && St) try { await Tt.all([jn(m, d, Rt, g(No), v, k), u && jn(m, d, Rt, g(xn), p, k, h)]) } catch { } return Rt }; return El(Le(Tt.all([B.response(), B.headers()]), ([lt, bt]) => (rn(E, d), kt(F(lt, L), bt)), lt => (rn(E, d), _t(G) ? kt(G(lt, L), X, st) : Dl(lt))), () => { nt(L) }) }, fromCache: () => e } } const Ta = (n, t) => () => { const e = t.indexOf(n); e >= 0 && t.splice(e, 1) }; class ee { constructor(t, e, s, i, o) { this.dhs = [], this.uhs = [], this.fromCache = X; const a = () => { a.a() }; a.a = Ot; const r = this, l = Ol(e); r.abort = a, r.baseURL = l.baseURL || "", r.url = s, r.type = t, r.context = e; const c = {}, d = "cacheFor", u = Me(l[d]) ? l[d][t] : X, h = i && i.hitSource; ae(["timeout", "shareRequest"], f => { l[f] !== X && (c[f] = l[f]) }), u !== X && (c[d] = u), h && (r.hitSource = ie(re(h) ? h : [h], f => Ut(f, ee) ? qt(f) : f), rn(i, "hitSource")), r.config = { ...c, headers: {}, params: {}, ...i || {} }, r.data = o, r.meta = i ? i.meta : r.meta, r.key = r.generateKey() } onDownload (t) { return Zt(this.dhs, t), Ta(t, this.dhs) } onUpload (t) { return Zt(this.uhs, t), Ta(t, this.uhs) } send (t = st) { const e = this, { response: s, onDownload: i, onUpload: o, abort: a, fromCache: r } = Ou(e, t); return vt(e.dhs) > 0 && i((l, c) => ae(e.dhs, d => d({ loaded: l, total: c }))), vt(e.uhs) > 0 && o((l, c) => ae(e.uhs, d => d({ loaded: l, total: c }))), e.abort.a = a, e.fromCache = X, e.promise = Le(s(), l => (e.fromCache = r(), l)), e.promise } setName (t) { an(this).name = t } generateKey () { return uu(this) } then (t, e) { return Le(this.send(), t, e) } catch (t) { return Ze(this.send(), t) } finally (t) { return El(this.send(), t) } } const vi = cs(), Ni = "undefined", Lu = (n, ...t) => n.push(...t), Au = (n, t) => n.map(t), $u = (n, t) => n.filter(t); typeof window === Ni && (typeof process !== Ni && process.cwd); const Vl = () => { const n = {}; return { eventMap: n, on (t, e) { const s = n[t] = n[t] || []; return Lu(s, e), () => { n[t] = $u(s, i => i !== e) } }, off (t, e) { const s = n[t]; if (s) if (e) { const i = s.indexOf(e); i > -1 && s.splice(i, 1) } else delete n[t] }, emit (t, e) { const s = n[t] || []; return Au(s, i => i(e)) } } }, Ae = "success", Du = () => { let n = {}; const t = Vl(); return { set (s, i) { n[s] = i, t.emit(Ae, { type: "set", key: s, value: i, container: n }) }, get: s => { const i = n[s]; return t.emit(Ae, { type: "get", key: s, value: i, container: n }), i }, remove (s) { rn(n, s), t.emit(Ae, { type: "remove", key: s, container: n }) }, clear: () => { n = {}, t.emit(Ae, { type: "clear", key: "", container: n }) }, emitter: t } }, Te = () => (vi(typeof localStorage < "u", "l2Cache is not defined."), localStorage), Eu = () => { const n = Vl(); return { set: (e, s) => { Te().setItem(e, Rl(s)), n.emit(Ae, { type: "set", key: e, value: s, container: Te() }) }, get: e => { const s = Te().getItem(e), i = s && vu(s); return n.emit(Ae, { type: "get", key: e, value: i, container: Te() }), i }, remove: e => { Te().removeItem(e), n.emit(Ae, { type: "remove", key: e, container: Te() }) }, clear: () => { Te().clear(), n.emit(Ae, { type: "clear", key: "", container: Te() }) }, emitter: n } }, Oa = Set; class Ru { constructor(t) { this.records = {}, this.occupy = 0, vi(t >= 0, "expected snapshots limit to be >= 0"), this.capacity = t } save (t) { const { name: e } = an(t), { records: s, occupy: i, capacity: o } = this; e && i < o && ((s[e] = s[e] || ht(Oa)).add(t), this.occupy += 1) } match (t, e = !0) { let s, i, o, a = t; Me(t) && (a = t.name, o = t.filter), Ut(a, Io) ? i = a : Cl(a) && (s = a); const { records: r } = this; let l = ht(Oa); s ? l = r[s] || l : i && ae(Fe(Ne(r), d => i.test(d)), d => { r[d].forEach(u => l.add(u)) }); const c = _t(o) ? Fe([...l], o) : [...l]; return e ? c : c[0] } } const Bl = "GET", Iu = "HEAD", Nu = "POST", Fu = "PUT", Vu = "PATCH", Bu = "DELETE", zu = "OPTIONS", La = { cacheFor: { [Bl]: 3e5 }, shareRequest: rt, snapshots: 1e3 }; let ju = 0; class Hu { constructor(t) { var e, s; const i = this; i.id = (t.id || (ju += 1)).toString(), i.l1Cache = t.l1Cache || Du(), i.l2Cache = t.l2Cache || Eu(), i.options = { ...La, ...t }, i.snapshots = ht(Ru, (s = (e = t.snapshots) !== null && e !== void 0 ? e : La.snapshots) !== null && s !== void 0 ? s : 0) } Get (t, e) { return ht(ee, Bl, this, t, e) } Post (t, e = {}, s) { return ht(ee, Nu, this, t, s, e) } Delete (t, e = {}, s) { return ht(ee, Bu, this, t, s, e) } Put (t, e = {}, s) { return ht(ee, Fu, this, t, s, e) } Head (t, e) { return ht(ee, Iu, this, t, e) } Patch (t, e = {}, s) { return ht(ee, Vu, this, t, s, e) } Options (t, e) { return ht(ee, zu, this, t, e) } } let Hn = X; const Xs = [], Gs = [], Wu = n => { const t = ht(Hu, n), e = t.options.statesHook; Hn && vi(Hn === e, "expected to use the same `statesHook`"), Hn = e; const { l1Cache: s, l2Cache: i } = t; return !Xs.includes(s) && Zt(Xs, s), !Gs.includes(i) && Zt(Gs, i), t }, Js = () => (vi(!!Hn, "`statesHook` is not set in alova instance"), Hn); var Uu = { name: "Vue", create: n => et(n), dehydrate: n => n.value, update: (n, t) => { t.value = n }, effectRequest ({ handler: n, removeStates: t, immediate: e, watchingStates: s }) { Ai() ? (Xn(t), Se(() => e && n())) : Ks(() => { e && n() }); const i = pu(); ae(s || [], (o, a) => { ne(o, () => { i(() => { n(a) }) }, { deep: rt }) }) }, computed: n => K(n), watch: (n, t) => { ne(n, t, { deep: rt }) }, onMounted: n => { Ai() ? Se(n) : Ks(n, 10) }, onUnmounted: n => { Ai() && Xn(n) } }; const Yu = { authRole: null }, Aa = { authRole: "login" }, Ku = { authRole: "logout" }, qu = { authRole: "refreshToken" }, $s = ({ meta: n }, t) => { if (Me(n)) { for (const e in n) if (Object.prototype.hasOwnProperty.call(n, e)) { const s = t[e]; if (Ut(s, RegExp) ? s.test(n[e]) : n[e] === s) return rt } } return st }, zl = (n, t) => ht(Tt, e => { Zt(t, { method: n, resolve: e }) }), $a = (n, t, e, s) => { if ($s(n, (t == null ? void 0 : t.metaMatches) || e)) return (_t(t) ? t : Me(t) && _t(t.handler) ? t.handler : Ot)(s, n) }, Xu = async (n, t, e, s, i, o) => { const a = vt(s) >= 2; let r = i == null ? void 0 : i.isExpired(...s); if (Ut(r, Tt) && (r = await r), r) try { let l = rt; if (a && o && (l = st, await zl(n, t)), l && (e(rt), await (i == null ? void 0 : i.handler(...s)), e(st), ae(t, ({ resolve: c }) => c())), a) { const { config: c } = n, d = c.transform; c.transform = X; const u = await n; return c.transform = d, u } } finally { e(st), Ge(t, 0, vt(t)) } }, Gu = n => { let t = X, e = X, s = X; if (_t(n)) t = n; else if (Me(n)) { const { onSuccess: i, onError: o, onComplete: a } = n; t = _t(i) ? i : t, e = _t(o) ? o : e, s = _t(a) ? a : s } return { onSuccess: t, onError: e, onComplete: s } }, Ju = ({ visitorMeta: n, login: t, logout: e, refreshToken: s, assignToken: i = Ot }) => { let o = st; const a = []; return { waitingList: a, onAuthRequired: c => async d => { const u = $s(d, n || Yu), h = $s(d, (t == null ? void 0 : t.metaMatches) || Aa); return !u && !h && !$s(d, (s == null ? void 0 : s.metaMatches) || qu) && (o && await zl(d, a), await Xu(d, a, f => { o = f }, [d], s)), !u && !h && await i(d), c == null ? void 0 : c(d) }, onResponseRefreshToken: c => { const d = Gu(c); return { ...d, onSuccess: async (u, h) => (await $a(h, t, Aa, u), await $a(h, e, Ku, u), (d.onSuccess || Us)(u, h)) } } } }, Qu = cs("useRequest"), jl = cs("useWatcher"), Hl = cs("useFetcher"), Wl = n => ({ 1: Qu, 2: jl, 3: Hl })[n], Ul = (n, t) => n(Ut(t, ee), "expected a method instance."), Zu = (n, t) => { let e = bu; return function (...i) { const o = n.bind(this, ...i), a = ue(t) ? t : t(...i); e && no(e), a > 0 ? e = Ks(o, a) : o() } }, th = (n, t) => { const e = {}; for (const s in n) e[s] = t(n[s], s, n); return e }, Fi = "undefined", eh = (n, ...t) => n.push(...t), nh = (n, t) => n.map(t), sh = (n, t) => n.filter(t); typeof window === Fi && (typeof process !== Fi && process.cwd); const Yl = () => { const n = {}; return { eventMap: n, on (t, e) { const s = n[t] = n[t] || []; return eh(s, e), () => { n[t] = sh(s, i => i !== e) } }, off (t, e) { const s = n[t]; if (s) if (e) { const i = s.indexOf(e); i > -1 && s.splice(i, 1) } else delete n[t] }, emit (t, e) { const s = n[t] || []; return nh(s, i => i(e)) } } }, lo = "success", co = "error", uo = "complete"; var ih = (n, t, e, s) => ({ m: X, sf: [], rf: [], fs: {}, em: e, ht: n, c: t, ro: s }); class ln { constructor(t, e) { this.method = t, this.args = e } clone () { return { ...this } } static spawn (t, e) { return new ln(t, e) } } class oh extends ln { constructor(t, e, s) { super(t.method, t.args), this.data = e, this.fromCache = s } } class ah extends ln { constructor(t, e) { super(t.method, t.args), this.error = e } } class Da extends ln { constructor(t, e, s, i, o) { super(t.method, t.args), this.status = e, this.data = s, this.fromCache = e === "error" ? !1 : i, this.error = o } } const rh = (n, t) => t(), Qs = {}, lh = (n, t) => (Qs[n] || {})[t] || {}, ch = (n, t, e, s) => { const i = Qs[n] = Qs[n] || {}; i[t] = { s: e, h: s } }, dh = (n, t) => { const e = Qs[n]; e && rn(e, t) }; function ho (n, t, e = []) { const s = Wl(n.ht); let i = Ll(t, s, e); const { fs: o, ht: a, c: r } = n, { loading: l, data: c, error: d } = o, u = a === 3, { force: h = st, middleware: f = rh } = r, g = ge(i), { id: m } = g, v = qt(i), { abortLast: p = rt } = r; return n.m = i, (async () => { let b = Ot, y = Ot, k = st, w = $l(X), L = Ot, A = Ot; const x = await ro(i); let S = () => !!x, C = st; u || (y = F => ch(m, v, F, n), y(o), b = () => dh(m, v)); const T = F => { k = rt; const { force: G = h, method: nt = i } = F || {}, kt = Eo(G, [ht(ln, i, e)]), lt = ft => ({ loaded: Rt, total: $t }) => { o[ft].v = { loaded: Rt, total: $t } }; i = nt, Zt(n.sf, y), Zt(n.rf, b), C || (l.v = !!kt || !x); const { downloading: bt, uploading: St } = n.ro.trackedKeys; return L = bt ? i.onDownload(lt("downloading")) : L, A = St ? i.onUpload(lt("uploading")) : A, w = i.send(kt), S = () => i.fromCache || st, w }, R = { method: i, cachedResponse: x, config: r, abort: () => i.abort() }, I = () => a !== 2 || !p || n.m === i, H = f(u ? { ...R, args: e, fetch: (F, ...G) => (Ul(s, F), ho(n, F, G)), proxyStates: hu(o, "data"), controlFetching (F = rt) { C = F } } : { ...R, args: e, send: (...F) => ho(n, t, F), proxyStates: o, controlLoading (F = rt) { C = F } }, T); let E = X; const B = ln.spawn(i, e); try { const F = await H, G = nt => { if (!u) I() && (c.v = nt); else if (n.c.updateState !== st) { const kt = lh(m, v).s; kt && (kt.data.v = nt) } return I() && (d.v = X, !C && (l.v = st), n.em.emit(lo, ht(oh, B, nt, S())), n.em.emit(uo, ht(Da, B, lo, nt, S(), X))), nt }; E = F !== X ? G(F) : k ? await Le(w, G, () => G(X)) : X, !k && !C && (l.v = st) } catch (F) { throw I() && (d.v = F, !C && (l.v = st), n.em.emit(co, ht(ah, B, F)), n.em.emit(uo, ht(Da, B, co, X, S(), F))), F } return L(), A(), E })() } const uh = n => n.current; function Vo (n, t, e, s, i = st, o, a = 0) { var r; e = { ...e }; const { middleware: l, __referingObj: c = { trackedKeys: {}, bindError: st } } = e; let d = l ? st : !!i; if (i && !l) try { const E = Ll(t, Wl(n)), B = ge(E), F = B.l1Cache.get(mi(B.id, qt(E))); let G = X; if (F && !Ut(F, Tt)) { const [kt, lt] = F; (!lt || lt > ze()) && (G = kt) } d = !!Eo((r = e.force) !== null && r !== void 0 ? r : st) || !G } catch { } const { create: u, effectRequest: h, ref: f, objectify: g, exposeProvider: m, transformState2Proxy: v } = Ro(Js(), c), p = { total: 0, loaded: 0 }, { managedStates: b = {} } = e, y = u(_t(s) ? s() : s, "data"), k = u(d, "loading"), w = u(X, "error"), L = u({ ...p }, "downloading"), A = u({ ...p }, "uploading"), x = { ...th(b, (E, B) => v(E, B)), ...g([y, k, w, L, A]) }, S = Yl(), C = uh(f(ih(n, e, S, c))); C.fs = x, C.em = S, C.c = e, C.ro = c; const T = o !== X, R = (E = t, B) => ho(C, E, B), I = (E = c, B) => Ze(R(B), F => { if (!E.bindError && !E.trackedKeys.error) throw F }), H = f(Zu((E, B, F) => I(B, F), E => ue(E) ? re(a) ? a[E] : a : 0)); return Fo.ssr || h({ handler: T ? E => H.current(E, c, t) : () => I(c), removeStates: () => ae(C.rf, E => E()), saveStates: E => ae(C.sf, B => B(E)), frontStates: x, watchingStates: o, immediate: i ?? rt }), m({ ...g([y, k, w, L, A]), abort: () => C.m && C.m.abort(), send: (E, B) => R(B, E), onSuccess (E) { S.on(lo, E) }, onError (E) { c.bindError = rt, S.on(co, E) }, onComplete (E) { S.on(uo, E) } }) } function hh (n = {}) { const t = Vo(3, Ot, n), { send: e } = t; return rn(t, "send"), rs(t, { fetch: (s, ...i) => (Ul(Hl, s), e(i, s)) }) } function Bo (n, t = {}) { const { immediate: e = rt, initialData: s } = t, i = Vo(1, n, t, s, !!e), { send: o } = i; return rs(i, { send: (...a) => o(a) }) } function fh (n, t, e = {}) { jl(t && vt(t) > 0, "expected at least one watching state"); const { immediate: s, debounce: i = 0, initialData: o } = e, a = Vo(2, n, e, o, !!s, t, i), { send: r } = a; return rs(a, { send: (...l) => r(l) }) } var ph = { forward: n => Ut(n, Date) ? n.getTime() : X, backward: n => ht(Date, n) }, gh = { forward: n => Ut(n, RegExp) ? n.source : void 0, backward: n => ht(RegExp, n) }; const mh = (n = {}) => { const t = { date: ph, regexp: gh, ...n }; return { serialize: i => (eo(i) && (i = Ys(re(i) ? [...i] : { ...i }, o => { let a = X; const r = Ne(t).reduce((c, d) => { if (!a) { const u = t[d].forward(c); u !== X && (a = d, c = u) } return c }, o); return bi.prototype.toString.call(o) === "[object Object]" ? o = { ...o } : re(o) && (o = [...o]), a !== X ? [a, r] : o })), i), deserialize: i => eo(i) ? Ys(i, o => { if (re(o) && vt(o) === 2) { const a = t[o[0]]; o = a ? a.backward(o[1]) : o } return o }, st) : i } }; var bh = n => { let t = {}; return { snapshots: () => t, save (e, s = st) { const i = qt(e); (!t[i] || s) && (t[i] = { entity: e }) }, get: e => t[qt(Ut(e, ee) ? e : n(e))], remove (e) { e ? delete t[e] : t = {} } } }; const bn = cs("usePagination"), Ea = (n, t) => bn(ue(n) && n < vt(t), "index must be a number that less than list length"); var vh = (n, t = {}) => { const { create: e, computed: s, ref: i, watch: o, exposeProvider: a, objectify: r, __referingObj: l } = Ro(Js()), { preloadPreviousPage: c = rt, preloadNextPage: d = rt, total: u = U => U.total, data: h = U => U.data, append: f = st, initialPage: g = 1, initialPageSize: m = 10, watchingStates: v = [], initialData: p, immediate: b = rt, middleware: y = Ot, force: k = Ot, ...w } = t, L = i(n), A = i(st), x = e(g, "page"), S = e(m, "pageSize"), C = e(p ? h(p) || [] : [], "data"), T = e(p ? u(p) : X, "total"), { snapshots: R, get: I, save: H, remove: E } = i(bh(U => L.current(U, S.v))).current, B = U => h(U) || U, F = hh({ __referingObj: l, force: ({ args: U }) => U[0] }), { loading: G, fetch: nt, abort: kt, onSuccess: lt } = F, bt = i(G), St = (U = x.v) => { const Y = S.v, Z = n(U, Y); return H(Z), Z }; o(v, () => { x.v = g, A.current = rt }); const ft = i({}), Rt = s(() => { const U = T.v; return U !== X ? Math.ceil(U / S.v) : X }, [S, T], "pageCount"), $t = U => (...Y) => ft.current[U](...Y), hn = fh(St, [...v, x.e, S.e], { __referingObj: l, immediate: b, initialData: p, middleware (U, Y) { return y({ ...U, delegatingActions: { refresh: $t("refresh"), insert: $t("insert"), remove: $t("remove"), replace: $t("replace"), reload: $t("reload"), getState: Z => ({ page: x, pageSize: S, data: C, pageCount: Rt, total: T, isLastPage: Ci })[Z].v } }, $l), Y() }, force: U => U.args[1] || (_t(k) ? k(U) : k), ...w }), { send: Cn } = hn, Pi = hn.__proxyState("data"), da = async U => { const { rawData: Y = Pi.v, preloadPage: Z, fetchMethod: ct, forceRequest: xt = st, isNextPage: wt = st } = U, { e: It } = ls(ct); if (It(No) <= ze()) return st; if (xt) return rt; if (await ro(ct)) return st; const Nt = Rt.v, Bt = Nt ? Z > Nt : wt ? vt(B(Y)) < S.v : st; return Z > 0 && !Bt }, ua = async (U, Y = st) => { const Z = x.v + 1, ct = St(Z); d && await da({ rawData: U, preloadPage: Z, fetchMethod: ct, isNextPage: rt, forceRequest: Y }) && Ze(nt(ct, Y), Ot) }, sd = async U => { const Y = x.v - 1, Z = St(Y); c && await da({ rawData: U, preloadPage: Y, fetchMethod: Z }) && Ze(nt(Z), Ot) }, Ci = s(() => { const U = Pi.v; if (!U) return rt; const Y = B(U), Z = x.v, ct = Rt.v, xt = re(Y) ? vt(Y) : 0; return ct ? Z >= ct : xt < S.v }, [x, Rt, Pi, S], "isLastPage"), Ti = async () => { const U = I(x.v); U && await Ii(U.entity, Y => { if (Y) { const Z = B(Y) || []; return Ge(Z, 0, vt(Z), ...C.v), Y } }) }; lt(({ method: U, data: Y }) => { const Z = I(x.v); if (Z && qt(Z.entity) === qt(U)) { const ct = B(Y); if (f) { const xt = C.v, wt = S.v, It = vt(xt) % wt; if (It > 0) { const Nt = [...C.v]; Ge(Nt, (x.v - 1) * wt, It, ...ct), C.v = Nt } } else C.v = ct } }), hn.onSuccess(({ data: U, args: [Y, Z], method: ct }) => { const { total: xt } = I(ct) || {}, wt = U; T.v = xt !== X ? xt : u(wt), Z || (sd(wt), ua(wt)); const It = S.v, Nt = B(wt); if (bn(re(Nt), "Got wrong array, did you return the correct array of list in `data` function"), f) { if (A.current && (C.v = []), Y === X) C.v = [...C.v, ...Nt]; else if (Y) { const Bt = [...C.v]; Ge(Bt, (Y - 1) * It, It, ...Nt), C.v = Bt } } else C.v = Nt }), hn.onComplete(() => { A.current = st }); const ps = U => { const Y = C.v.indexOf(U); return bn(Y >= 0, "item is not found in list"), Y }, { addQueue: Oi, onComplete: ha } = i(gu()).current, Li = (U = x.v) => { let Y = U; if (f) { if (!ue(U)) { const Z = ps(U); Y = Math.floor(Z / S.v) + 1 } bn(Y <= x.v, "refresh page can't greater than page"), Ze(Cn(Y, rt), Ot) } else bn(ue(Y), "unable to calculate refresh page by item in pagination mode"), Ze(Y === x.v ? Cn(X, rt) : nt(n(Y, S.v), rt), Ot) }, fa = async (U = st) => { const Y = x.v, Z = R(); let ct = _u(Z); if (U) E(); else { const xt = ie(Fe([I(Y - 1), I(Y), I(Y + 1)], Boolean), ({ entity: wt }) => qt(wt)); ct = ie(Fe(Ne(Z), wt => !Ma(xt, wt)), wt => { const It = Z[wt]; return delete Z[wt], It }) } await Pu(ie(ct, ({ entity: xt }) => xt)) }, pa = async () => { bt.current && kt(), await fa(); const U = I(x.v + 1); if (U) { const Y = B(await ro(U.entity) || {}) || []; ua(X, vt(Y) < S.v) } }, ga = U => { if (U === 0) return; const Y = T.v; if (ue(Y)) { const Z = Math.max(Y + U, 0); T.v = Z; const ct = x.v; ae([I(ct - 1), I(ct), I(ct + 1)], xt => { xt && (xt.total = Z) }) } }, ma = (U, Y = 0) => (ha(pa), Oi(async () => { const Z = ue(Y) ? Y : ps(Y) + 1; let ct = X; const xt = [...C.v]; if (vt(xt) % S.v === 0 && (ct = xt.pop()), Ge(xt, Z, 0, U), C.v = xt, ga(1), await Ti(), ct) { const wt = I(x.v + 1); wt && await Ii(wt.entity, It => { if (It) { const Nt = B(It) || []; return Nt.unshift(ct), Nt.pop(), It } }) } })), ba = (...U) => (ha(pa), Oi(async () => { const Y = ie(U, Bt => { const fn = ue(Bt) ? Bt : ps(Bt); return Ea(fn, C.v), fn }), Z = x.v, ct = Z + 1, xt = I(ct), wt = []; xt && await Ii(xt.entity, Bt => { if (Bt) { const fn = B(Bt); return re(fn) && Zt(wt, ...Ge(fn, 0, vt(Y))), Bt } }); const It = Ci.v, Nt = vt(wt); if (Nt > 0 || It) { const Bt = Fe(C.v, (fn, id) => !Ma(Y, id)); !f && It && vt(Bt) <= 0 ? x.v = Z - 1 : Nt > 0 && Zt(Bt, ...wt), C.v = Bt } else Nt <= 0 && !It && Li(Z); return ga(-vt(Y)), Ti() })), va = (U, Y) => Oi(async () => { bn(Y !== X, "expect specify the replace position"); const Z = ue(Y) ? Y : ps(Y); Ea(Z, C.v); const ct = [...C.v]; Ge(ct, Z, 1, U), C.v = ct, await Ti() }), _a = () => { Le(fa(rt), () => { A.current = rt, x.v === g ? Ze(Cn(), Ot) : x.v = g }) }; return ft.current = { refresh: Li, insert: ma, remove: ba, replace: va, reload: _a }, a({ ...hn, ...r([C, x, Rt, S, T, Ci]), fetching: F.loading, onFetchSuccess: F.onSuccess, onFetchError: F.onError, onFetchComplete: F.onComplete, refresh: Li, insert: ma, remove: ba, replace: va, reload: _a }) }; const Ra = Symbol("FormRestore"), _h = (n, t) => `alova/form-${t || qt(n)}`, yh = {}, Ia = n => { const t = e => re(e) ? [...e] : Me(e) ? { ...e } : e; return Ys(t(n), t) }; var _i = (n, t = {}) => { const e = yh, { id: s, initialForm: i, store: o, resetAfterSubmiting: a, immediate: r = st, middleware: l } = t; Js(); const { create: c, ref: d, onMounted: u, watch: h, objectify: f, exposeProvider: g, __referingObj: m } = Ro(Js()), v = Me(o), p = v ? o.enable : o, b = s ? e[s] : X, y = c(Ia(i), "form"), k = n, w = Yl(), L = d(Eo(k, [y.v])), A = ge(L.current).l2Cache, x = _h(L.current, s), S = d(st), C = d(mh(v ? o.serializers : X)), T = d(!1), R = Bo((...G) => k(y.v, ...G), { ...t, __referingObj: m, middleware: l ? (G, nt) => l({ ...G, delegatingActions: { updateForm: H, reset: I } }, nt) : X, immediate: p || b ? st : r }), I = () => { S.current = rt; const G = Ia(i); G && (y.v = G), p && A.remove(x) }, H = G => { y.v = { ...y.v, ...G } }, E = g({ ...R, ...f([y]), updateForm: H, reset: I, onRestore (G) { w.on(Ra, G) } }); s && (b || (T.current = rt), T.current && (e[s] = { hookProvider: E, config: t })); const { send: B, onSuccess: F } = E; return u(() => { if (p && !b) { const G = C.current.deserialize(A.get(x)); G && (y.v = G, w.emit(Ra, X), p && r && B()) } }), h([y], () => { if (S.current || !p) { S.current = st; return } A.set(x, C.current.serialize(y.v)) }), F(() => { a && I() }), b && !T.current ? b.hookProvider : E }; const xh = n => Cl(n) || Al(n); function wh () { return (n, t) => { const e = t.config, s = e.timeout || 0, i = new AbortController, { data: o, headers: a } = n, r = /content-type/i.test(bi.keys(a).join()), l = o && o.toString() === "[object FormData]"; !r && !l && (a["Content-Type"] = "application/json;charset=UTF-8"); const c = fetch(n.url, { ...e, method: n.type, signal: i.signal, body: xh(o) ? o : Rl(o) }); let d, u = st; return s > 0 && (d = Ks(() => { u = rt, i.abort() }, s)), { response: () => c.then(h => (no(d), h.clone()), h => Dl(u ? ht(Error, "fetchError: network timeout") : h)), headers: () => c.then(({ headers: h }) => h, () => ({})), onDownload: async h => { let f = st; const g = await c.catch(() => { f = rt }); if (!g) return; const { headers: m, body: v } = g.clone(), p = v ? v.getReader() : X, b = Number(m.get("Content-Length") || m.get("content-length") || 0); if (b <= 0) return; let y = 0; if (p) { const k = () => p.read().then(({ done: w, value: L = new Uint8Array }) => { if (w || f) f && h(b, 0); else return y += L.byteLength, h(b, y), k() }); k() } }, onUpload () { console.error("fetch API does'nt support uploading progress. please consider to change `@alova/adapter-xhr` or `@alova/adapter-axios`") }, abort: () => { i.abort(), no(d) } } } } const kh = async n => { const t = await n.clone().json(); return new Promise((e, s) => { if (n.status >= 400) { if (n.status === 401) { const i = Jt(); Jt().clearAuth().then(() => { i.setRedirect("portal/login") }) } t.errors && (t.errors = Object.assign({}, ...Object.keys(t.errors).map(i => { var o, a; return { [i]: Array.isArray((o = t == null ? void 0 : t.errors) == null ? void 0 : o[i]) ? t.errors[i][0] : (a = t.errors) == null ? void 0 : a[i] } }))), s(t) } else e(t) }) }, { onAuthRequired: Sh, onResponseRefreshToken: Mh } = Ju({ refreshToken: { isExpired: () => !1, handler: async () => { await Jt().clearAuth() } }, assignToken: n => { const t = Jt(); n.config.headers.Authorization = "Bearer " + t.token }, login (n, t) { var e; (e = t.promise) == null || e.then(s => { Jt().saveAuthUser(s.data, s.token) }) }, async logout () { const n = Jt(); Jt().clearAuth().then(() => { n.setRedirect("portal/login") }) } }), Ph = "https://naija-places.toneflix.com.ng/api", Ve = Wu({ baseURL: Ph, statesHook: Uu, responded: Mh(kh), requestAdapter: wh(), beforeRequest: Sh((n, t) => { n.config.headers["Access-Control-Allow-Credentials"] = "true", n.config.headers["X-Requested-With"] = "XMLHttpRequest", n.config.headers.Accept = "application/json" }) }), Ch = { class: "fixed inset-0 z-40 flex md:hidden", role: "dialog", "aria-modal": "true" }, Th = { class: "relative flex flex-col flex-1 w-full max-w-xs bg-white dark:bg-gray-800" }, Oh = { class: "absolute top-0 right-0 pt-2 -mr-12" }, Lh = _("span", { class: "sr-only" }, "Close sidebar", -1), Ah = _("i", { class: "w-6 h-6 text-xl text-white 0 ri-close-line" }, null, -1), $h = [Lh, Ah], Dh = { class: "flex-1 h-0 pt-5 pb-4 overflow-y-auto" }, Eh = { class: "flex items-center flex-shrink-0 px-4" }, Rh = { href: "/" }, Ih = ["src"], Nh = { class: "px-2 mt-5 space-y-1" }, Fh = ["href", "onClick"], Vh = { class: "flex flex-shrink-0 p-4 bg-white border-t border-gray-200 dark:bg-gray-700 dark:border-t-0" }, Bh = { href: "#", class: "flex-shrink-0 block w-full group" }, zh = { class: "flex items-center" }, jh = ["src", "alt"], Hh = { class: "ml-3" }, Wh = { class: "text-sm font-medium text-gray-700 dark:text-white" }, Uh = { class: "text-xs font-medium text-gray-500 dark:text-gray-300 group-hover:text-gray-400" }, Yh = _("div", { class: "flex-shrink-0 w-14" }, null, -1), Kh = { class: "hidden md:flex md:w-64 md:flex-col md:fixed md:inset-y-0" }, qh = { class: "flex flex-col flex-1 min-h-0 bg-white border-r border-gray-200 dark:bg-gray-800 dark:border-r-0" }, Xh = { class: "flex flex-col flex-1 pt-5 pb-4 overflow-y-auto" }, Gh = { class: "flex items-center flex-shrink-0 px-4" }, Jh = { href: "/" }, Qh = ["src"], Zh = { class: "flex-1 px-2 mt-5 space-y-1" }, tf = ["href", "onClick"], ef = { class: "flex flex-shrink-0 p-4 bg-white border-t border-gray-200 dark:bg-gray-700 dark:border-t-0" }, nf = { href: "#", class: "flex-shrink-0 block w-full group" }, sf = { class: "flex items-center" }, of = ["src", "alt"], af = { class: "ml-3" }, rf = { class: "text-sm font-medium text-gray-700 dark:text-white" }, lf = { class: "text-xs font-medium text-gray-500 dark:text-gray-300 group-hover:text-gray-400" }, cf = { class: "flex flex-col flex-1 md:pl-64" }, df = { class: "sticky top-0 z-10 flex flex-shrink-0 h-16 bg-white shadow dark:bg-gray-700" }, uf = _("span", { class: "sr-only" }, "Open sidebar", -1), hf = _("i", { class: "w-6 h-6 text-xl ri-menu-2-fill" }, null, -1), ff = [uf, hf], pf = { class: "flex justify-between flex-1 px-4" }, gf = _("div", { class: "flex flex-1" }, null, -1), mf = { class: "flex items-center ml-4 md:ml-6" }, bf = _("span", { class: "sr-only" }, "Toggle Dark Mode", -1), vf = _("i", { class: "text-xs text-gray-400 ri-sun-line" }, null, -1), _f = [vf], yf = _("i", { class: "text-xs text-black ri-moon-fill" }, null, -1), xf = [yf], wf = { class: "relative ml-3" }, kf = _("span", { class: "sr-only" }, "Open user menu", -1), Sf = ["src", "alt"], Mf = { class: "absolute right-0 w-48 py-1 mt-2 origin-top-right bg-white rounded-md shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none", role: "menu", "aria-orientation": "vertical", "aria-labelledby": "user-menu-button", tabindex: "-1" }, Pf = { class: "flex-1" }, Cf = { class: "py-6" }, Tf = { class: "px-4 mx-auto max-w-7xl sm:px-6 lg:px-8" }, Of = { class: "text-2xl font-semibold text-gray-900 dark:text-white" }, Lf = { class: "px-4 mx-auto max-w-7xl sm:px-6 md:px-8" }, Af = { class: "py-4" }, $f = z({ __name: "LayoutDashboard", props: { pageTitle: { type: String, default: "Dashboard" } }, setup (n) { var h; const t = K(() => Jt().user), e = Gn(), s = Gn(), i = et(!1), o = et(!1), { site: a, isDark: r } = Pn(); Jt().$subscribe((f, g) => { g.redirect && (s.go(g.redirect), Jt().setRedirect()) }), (h = t.value) != null && h.id || s.go("/portal/login"); const l = f => e.route.path === f ? "dark:bg-gray-900 dark:text-white text-gray-900 bg-gray-300 group active hover:bg-gray-50 hover:text-gray-900 text-gray-600" : "dark:text-gray-300 dark:hover:bg-gray-700 dark:hover:text-white hover:bg-gray-50 hover:text-gray-900 text-gray-700 group-hover:text-gray-500", { send: c, onSuccess: d } = Bo(() => { const f = Ve.Post("v1/account/logout"); return f.meta = { authRole: "logout" }, f }, { immediate: !1 }); d(() => { s.go("/portal/login") }); const u = [{ label: "Dashboard", icon: "ri-dashboard-line", link: "/portal/home", click: () => e.go("/portal/home") }, { label: "API Keys", icon: "ri-key-line", link: "/portal/api-keys", click: () => e.go("/portal/api-keys") }, { label: "Documentation", icon: "ri-book-line", link: "/api-documentation", click: () => e.go("/api-documentation") }]; return (f, g) => (M(), O("div", null, [Wt(_("div", Ch, [_("div", { class: "fixed inset-0 bg-gray-600 bg-opacity-75", "aria-hidden": "true", onClick: g[0] || (g[0] = m => i.value = !i.value) }), _("div", Th, [_("div", Oh, [_("button", { type: "button", class: "flex items-center justify-center w-10 h-10 ml-1 rounded-full focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white", onClick: g[1] || (g[1] = m => i.value = !1) }, $h)]), _("div", Dh, [_("div", Eh, [_("a", Rh, [_("img", { class: "w-auto h-8", src: P(a).themeConfig.logo, alt: "Logo" }, null, 8, Ih)])]), _("nav", Nh, [(M(), O(dt, null, Et(u, m => _("a", { class: Q(["flex items-center px-2 py-2 text-sm font-medium rounded-md group", l(m.link)]), href: m.link, key: m.link, onClick: sn(m.click, ["prevent"]) }, [_("i", { class: Q(["flex-shrink-0 mr-4 text-xl text-gray-400 group-[.active]:text-gray-700 dark:group-[.active]:text-gray-300", m.icon]) }, null, 2), Lt(" " + q(m.label), 1)], 10, Fh)), 64))])]), _("div", Vh, [_("a", Bh, [_("div", zh, [_("div", null, [_("img", { class: "inline-block rounded-full h-9 w-9", src: t.value.imageUrl, alt: t.value.fullname }, null, 8, jh)]), _("div", Hh, [_("p", Wh, q(t.value.fullname), 1), _("p", Uh, q(t.value.email), 1)])])])])]), Yh], 512), [[gs, i.value]]), _("div", Kh, [_("div", qh, [_("div", Xh, [_("div", Gh, [_("a", Jh, [_("img", { class: "w-auto h-8", src: P(a).themeConfig.logo, alt: "Logo" }, null, 8, Qh)])]), _("nav", Zh, [(M(), O(dt, null, Et(u, m => _("a", { class: Q(["flex items-center px-2 py-2 text-sm font-medium rounded-md group", l(m.link)]), href: m.link, key: m.link, onClick: sn(m.click, ["prevent"]) }, [_("i", { class: Q(["flex-shrink-0 mr-4 text-xl text-gray-400 group-[.active]:text-gray-700 dark:group-[.active]:text-gray-300", m.icon]) }, null, 2), Lt(" " + q(m.label), 1)], 10, tf)), 64))])]), _("div", ef, [_("a", nf, [_("div", sf, [_("div", null, [_("img", { class: "inline-block rounded-full h-9 w-9", src: t.value.imageUrl, alt: t.value.fullname }, null, 8, of)]), _("div", af, [_("p", rf, q(t.value.fullname), 1), _("p", lf, q(t.value.email), 1)])])])])])]), _("div", cf, [_("div", df, [_("button", { type: "button", class: "px-4 text-gray-500 border-r border-gray-200 dark:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-primary dark:focus:ring-gray-700 md:hidden", onClick: g[2] || (g[2] = m => i.value = !i.value) }, ff), _("div", pf, [gf, _("div", mf, [_("button", { type: "button", class: "relative inline-flex flex-shrink-0 h-6 transition-colors duration-200 ease-in-out bg-gray-200 border-2 border-transparent rounded-full cursor-pointer w-11 focus:outline-none focus:ring-1 focus:ring-offset-2 focus:ring-primary", role: "switch", "aria-checked": "false", onClick: g[3] || (g[3] = m => r.value = !P(r)) }, [bf, _("span", { class: Q(["relative inline-block w-6 h-6 transition duration-200 ease-in-out transform translate-x-0 bg-white rounded-full shadow pointer-events-none ring-0", P(r) ? "translate-x-5" : "translate-x-0"]) }, [Wt(_("span", { class: Q(["absolute inset-0 flex items-center justify-center w-full h-full transition-opacity duration-200 ease-in opacity-100", P(r) ? "opacity-0 ease-out duration-100" : "opacity-100 ease-in duration-200"]), "aria-hidden": "true" }, _f, 2), [[gs, !P(r)]]), Wt(_("span", { class: Q(["absolute inset-0 flex items-center justify-center w-full h-full transition-opacity duration-100 ease-out opacity-0", P(r) ? "opacity-100 ease-in duration-200" : "opacity-0 ease-out duration-100"]), "aria-hidden": "true" }, xf, 2), [[gs, P(r)]])], 2)]), _("div", wf, [_("div", null, [_("button", { type: "button", class: "flex items-center max-w-xs text-sm bg-white rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary", id: "user-menu-button", "aria-expanded": "false", "aria-haspopup": "true", onClick: g[4] || (g[4] = m => o.value = !o.value) }, [kf, _("img", { class: "w-8 h-8 rounded-full", src: t.value.imageUrl, alt: t.value.fullname }, null, 8, Sf)])]), j(li, { "enter-active-class": "transition duration-100 ease-out", "enter-from-class": "transform scale-95 opacity-0", "enter-to-class": "transform scale-100 opacity-100", "leave-active-class": "transition duration-75 ease-in", "leave-from-class": "transform scale-100 opacity-100", "leave-to-class": "transform scale-95 opacity-0" }, { default: D(() => [Wt(_("div", Mf, [_("a", { href: "/portal/home?logout=true", class: "block px-4 py-2 text-sm text-gray-700", role: "menuitem", tabindex: "-1", id: "user-menu-item-2", onClick: g[5] || (g[5] = (...m) => P(c) && P(c)(...m)) }, "Logout")], 512), [[gs, o.value]])]), _: 1 })])])])]), _("main", Pf, [_("div", Cf, [_("div", Tf, [_("h1", Of, q(n.pageTitle), 1)]), _("div", Lf, [_("div", Af, [$(f.$slots, "default")])])])])])])) } }), Df = Object.freeze(Object.defineProperty({ __proto__: null, default: $f }, Symbol.toStringTag, { value: "Module" })); var Ds = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function Kl (n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } var ql = { exports: {} }; (function (n) {
  (function (t, e) { n.exports = e(t) })(typeof Ds < "u" ? Ds : typeof window < "u" ? window : Ds, function (t) {
    if (typeof t > "u" && typeof t.document > "u") return !1; var e = "Notiflix", s = `

Visit documentation page to learn more: https://notiflix.github.io/documentation`, i = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif', o = { Success: "Success", Failure: "Failure", Warning: "Warning", Info: "Info" }, a, r = { wrapID: "NotiflixNotifyWrap", overlayID: "NotiflixNotifyOverlay", width: "280px", position: "right-top", distance: "10px", opacity: 1, borderRadius: "5px", rtl: !1, timeout: 3e3, messageMaxLength: 110, backOverlay: !1, backOverlayColor: "rgba(0,0,0,0.5)", plainText: !0, showOnlyTheLastOne: !1, clickToClose: !1, pauseOnHover: !0, ID: "NotiflixNotify", className: "notiflix-notify", zindex: 4001, fontFamily: "Quicksand", fontSize: "13px", cssAnimation: !0, cssAnimationDuration: 400, cssAnimationStyle: "fade", closeButton: !1, useIcon: !0, useFontAwesome: !1, fontAwesomeIconStyle: "basic", fontAwesomeIconSize: "34px", success: { background: "#32c682", textColor: "#fff", childClassName: "notiflix-notify-success", notiflixIconColor: "rgba(0,0,0,0.2)", fontAwesomeClassName: "fas fa-check-circle", fontAwesomeIconColor: "rgba(0,0,0,0.2)", backOverlayColor: "rgba(50,198,130,0.2)" }, failure: { background: "#ff5549", textColor: "#fff", childClassName: "notiflix-notify-failure", notiflixIconColor: "rgba(0,0,0,0.2)", fontAwesomeClassName: "fas fa-times-circle", fontAwesomeIconColor: "rgba(0,0,0,0.2)", backOverlayColor: "rgba(255,85,73,0.2)" }, warning: { background: "#eebf31", textColor: "#fff", childClassName: "notiflix-notify-warning", notiflixIconColor: "rgba(0,0,0,0.2)", fontAwesomeClassName: "fas fa-exclamation-circle", fontAwesomeIconColor: "rgba(0,0,0,0.2)", backOverlayColor: "rgba(238,191,49,0.2)" }, info: { background: "#26c0d3", textColor: "#fff", childClassName: "notiflix-notify-info", notiflixIconColor: "rgba(0,0,0,0.2)", fontAwesomeClassName: "fas fa-info-circle", fontAwesomeIconColor: "rgba(0,0,0,0.2)", backOverlayColor: "rgba(38,192,211,0.2)" } }, l = function (p) {
        return console.error("%c " + e + " Error ", "padding:2px;border-radius:20px;color:#fff;background:#ff5549", `
`+ p + s)
      }, c = function (p) {
        return p || (p = "head"), t.document[p] === null ? (l(`
Notiflix needs to be appended to the "<`+ p + '>" element, but you called it before the "<' + p + '>" element has been created.'), !1) : !0
      }, d = function (p, b) { if (!c("head")) return !1; if (p() !== null && !t.document.getElementById(b)) { var y = t.document.createElement("style"); y.id = b, y.innerHTML = p(), t.document.head.appendChild(y) } }, u = function () { var p = {}, b = !1, y = 0; Object.prototype.toString.call(arguments[0]) === "[object Boolean]" && (b = arguments[0], y++); for (var k = function (w) { for (var L in w) Object.prototype.hasOwnProperty.call(w, L) && (b && Object.prototype.toString.call(w[L]) === "[object Object]" ? p[L] = u(p[L], w[L]) : p[L] = w[L]) }; y < arguments.length; y++)k(arguments[y]); return p }, h = function (p) { var b = t.document.createElement("div"); return b.innerHTML = p, b.textContent || b.innerText || "" }, f = function () { var p = '[id^=NotiflixNotifyWrap]{pointer-events:none;position:fixed;z-index:4001;opacity:1;right:10px;top:10px;width:280px;max-width:96%;-webkit-box-sizing:border-box;box-sizing:border-box;background:transparent}[id^=NotiflixNotifyWrap].nx-flex-center-center{max-height:calc(100vh - 20px);overflow-x:hidden;overflow-y:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;margin:auto}[id^=NotiflixNotifyWrap]::-webkit-scrollbar{width:0;height:0}[id^=NotiflixNotifyWrap]::-webkit-scrollbar-thumb{background:transparent}[id^=NotiflixNotifyWrap]::-webkit-scrollbar-track{background:transparent}[id^=NotiflixNotifyWrap] *{-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixNotifyOverlay]{-webkit-transition:background .3s ease-in-out;-o-transition:background .3s ease-in-out;transition:background .3s ease-in-out}[id^=NotiflixNotifyWrap]>div{pointer-events:all;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-family:"Quicksand",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;width:100%;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;position:relative;margin:0 0 10px;border-radius:5px;background:#1e1e1e;color:#fff;padding:10px 12px;font-size:14px;line-height:1.4}[id^=NotiflixNotifyWrap]>div:last-child{margin:0}[id^=NotiflixNotifyWrap]>div.nx-with-callback{cursor:pointer}[id^=NotiflixNotifyWrap]>div.nx-with-icon{padding:8px;min-height:56px}[id^=NotiflixNotifyWrap]>div.nx-paused{cursor:auto}[id^=NotiflixNotifyWrap]>div.nx-notify-click-to-close{cursor:pointer}[id^=NotiflixNotifyWrap]>div.nx-with-close-button{padding:10px 36px 10px 12px}[id^=NotiflixNotifyWrap]>div.nx-with-icon.nx-with-close-button{padding:6px 36px 6px 6px}[id^=NotiflixNotifyWrap]>div>span.nx-message{cursor:inherit;font-weight:normal;font-family:inherit!important;word-break:break-all;word-break:break-word}[id^=NotiflixNotifyWrap]>div>span.nx-close-button{cursor:pointer;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out;position:absolute;right:8px;top:0;bottom:0;margin:auto;color:inherit;width:20px;height:20px}[id^=NotiflixNotifyWrap]>div>span.nx-close-button:hover{-webkit-transform:rotate(90deg);transform:rotate(90deg)}[id^=NotiflixNotifyWrap]>div>span.nx-close-button>svg{position:absolute;width:16px;height:16px;right:2px;top:2px}[id^=NotiflixNotifyWrap]>div>.nx-message-icon{position:absolute;width:40px;height:40px;font-size:30px;line-height:40px;text-align:center;left:8px;top:0;bottom:0;margin:auto;border-radius:inherit}[id^=NotiflixNotifyWrap]>div>.nx-message-icon-fa.nx-message-icon-fa-shadow{color:inherit;background:rgba(0,0,0,.15);-webkit-box-shadow:inset 0 0 34px rgba(0,0,0,.2);box-shadow:inset 0 0 34px rgba(0,0,0,.2);text-shadow:0 0 10px rgba(0,0,0,.3)}[id^=NotiflixNotifyWrap]>div>span.nx-with-icon{position:relative;float:left;width:calc(100% - 40px);margin:0 0 0 40px;padding:0 0 0 10px;-webkit-box-sizing:border-box;box-sizing:border-box}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>.nx-message-icon{left:auto;right:8px}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>span.nx-with-icon{padding:0 10px 0 0;margin:0 40px 0 0}[id^=NotiflixNotifyWrap]>div.nx-rtl-on>span.nx-close-button{right:auto;left:8px}[id^=NotiflixNotifyWrap]>div.nx-with-icon.nx-with-close-button.nx-rtl-on{padding:6px 6px 6px 36px}[id^=NotiflixNotifyWrap]>div.nx-with-close-button.nx-rtl-on{padding:10px 12px 10px 36px}[id^=NotiflixNotifyOverlay].nx-with-animation,[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-fade{-webkit-animation:notify-animation-fade .3s ease-in-out 0s normal;animation:notify-animation-fade .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-fade{0%{opacity:0}100%{opacity:1}}@keyframes notify-animation-fade{0%{opacity:0}100%{opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-zoom{-webkit-animation:notify-animation-zoom .3s ease-in-out 0s normal;animation:notify-animation-zoom .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-zoom{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes notify-animation-zoom{0%{-webkit-transform:scale(0);transform:scale(0)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(1);transform:scale(1)}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-right{-webkit-animation:notify-animation-from-right .3s ease-in-out 0s normal;animation:notify-animation-from-right .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-right{0%{right:-300px;opacity:0}50%{right:8px;opacity:1}100%{right:0;opacity:1}}@keyframes notify-animation-from-right{0%{right:-300px;opacity:0}50%{right:8px;opacity:1}100%{right:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-left{-webkit-animation:notify-animation-from-left .3s ease-in-out 0s normal;animation:notify-animation-from-left .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-left{0%{left:-300px;opacity:0}50%{left:8px;opacity:1}100%{left:0;opacity:1}}@keyframes notify-animation-from-left{0%{left:-300px;opacity:0}50%{left:8px;opacity:1}100%{left:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-top{-webkit-animation:notify-animation-from-top .3s ease-in-out 0s normal;animation:notify-animation-from-top .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-top{0%{top:-50px;opacity:0}50%{top:8px;opacity:1}100%{top:0;opacity:1}}@keyframes notify-animation-from-top{0%{top:-50px;opacity:0}50%{top:8px;opacity:1}100%{top:0;opacity:1}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-bottom{-webkit-animation:notify-animation-from-bottom .3s ease-in-out 0s normal;animation:notify-animation-from-bottom .3s ease-in-out 0s normal}@-webkit-keyframes notify-animation-from-bottom{0%{bottom:-50px;opacity:0}50%{bottom:8px;opacity:1}100%{bottom:0;opacity:1}}@keyframes notify-animation-from-bottom{0%{bottom:-50px;opacity:0}50%{bottom:8px;opacity:1}100%{bottom:0;opacity:1}}[id^=NotiflixNotifyOverlay].nx-with-animation.nx-remove,[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-fade.nx-remove{opacity:0;-webkit-animation:notify-remove-fade .3s ease-in-out 0s normal;animation:notify-remove-fade .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-fade{0%{opacity:1}100%{opacity:0}}@keyframes notify-remove-fade{0%{opacity:1}100%{opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-zoom.nx-remove{-webkit-transform:scale(0);transform:scale(0);-webkit-animation:notify-remove-zoom .3s ease-in-out 0s normal;animation:notify-remove-zoom .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-zoom{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(0);transform:scale(0)}}@keyframes notify-remove-zoom{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.05);transform:scale(1.05)}100%{-webkit-transform:scale(0);transform:scale(0)}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-top.nx-remove{opacity:0;-webkit-animation:notify-remove-to-top .3s ease-in-out 0s normal;animation:notify-remove-to-top .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-top{0%{top:0;opacity:1}50%{top:8px;opacity:1}100%{top:-50px;opacity:0}}@keyframes notify-remove-to-top{0%{top:0;opacity:1}50%{top:8px;opacity:1}100%{top:-50px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-right.nx-remove{opacity:0;-webkit-animation:notify-remove-to-right .3s ease-in-out 0s normal;animation:notify-remove-to-right .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-right{0%{right:0;opacity:1}50%{right:8px;opacity:1}100%{right:-300px;opacity:0}}@keyframes notify-remove-to-right{0%{right:0;opacity:1}50%{right:8px;opacity:1}100%{right:-300px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-bottom.nx-remove{opacity:0;-webkit-animation:notify-remove-to-bottom .3s ease-in-out 0s normal;animation:notify-remove-to-bottom .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-bottom{0%{bottom:0;opacity:1}50%{bottom:8px;opacity:1}100%{bottom:-50px;opacity:0}}@keyframes notify-remove-to-bottom{0%{bottom:0;opacity:1}50%{bottom:8px;opacity:1}100%{bottom:-50px;opacity:0}}[id^=NotiflixNotifyWrap]>div.nx-with-animation.nx-from-left.nx-remove{opacity:0;-webkit-animation:notify-remove-to-left .3s ease-in-out 0s normal;animation:notify-remove-to-left .3s ease-in-out 0s normal}@-webkit-keyframes notify-remove-to-left{0%{left:0;opacity:1}50%{left:8px;opacity:1}100%{left:-300px;opacity:0}}@keyframes notify-remove-to-left{0%{left:0;opacity:1}50%{left:8px;opacity:1}100%{left:-300px;opacity:0}}'; return p || null }, g = 0, m = function (p, b, y, k) { if (!c("body")) return !1; a || v.Notify.init({}); var w = u(!0, a, {}); if (typeof y == "object" && !Array.isArray(y) || typeof k == "object" && !Array.isArray(k)) { var L = {}; typeof y == "object" ? L = y : typeof k == "object" && (L = k), a = u(!0, a, L) } var A = a[p.toLocaleLowerCase("en")]; g++, typeof b != "string" && (b = "Notiflix " + p), a.plainText && (b = h(b)), !a.plainText && b.length > a.messageMaxLength && (a = u(!0, a, { closeButton: !0, messageMaxLength: 150 }), b = 'Possible HTML Tags Error: The "plainText" option is "false" and the notification content length is more than the "messageMaxLength" option.'), b.length > a.messageMaxLength && (b = b.substring(0, a.messageMaxLength) + "..."), a.fontAwesomeIconStyle === "shadow" && (A.fontAwesomeIconColor = A.background), a.cssAnimation || (a.cssAnimationDuration = 0); var x = t.document.getElementById(r.wrapID) || t.document.createElement("div"); if (x.id = r.wrapID, x.style.width = a.width, x.style.zIndex = a.zindex, x.style.opacity = a.opacity, a.position === "center-center" ? (x.style.left = a.distance, x.style.top = a.distance, x.style.right = a.distance, x.style.bottom = a.distance, x.style.margin = "auto", x.classList.add("nx-flex-center-center"), x.style.maxHeight = "calc((100vh - " + a.distance + ") - " + a.distance + ")", x.style.display = "flex", x.style.flexWrap = "wrap", x.style.flexDirection = "column", x.style.justifyContent = "center", x.style.alignItems = "center", x.style.pointerEvents = "none") : a.position === "center-top" ? (x.style.left = a.distance, x.style.right = a.distance, x.style.top = a.distance, x.style.bottom = "auto", x.style.margin = "auto") : a.position === "center-bottom" ? (x.style.left = a.distance, x.style.right = a.distance, x.style.bottom = a.distance, x.style.top = "auto", x.style.margin = "auto") : a.position === "right-bottom" ? (x.style.right = a.distance, x.style.bottom = a.distance, x.style.top = "auto", x.style.left = "auto") : a.position === "left-top" ? (x.style.left = a.distance, x.style.top = a.distance, x.style.right = "auto", x.style.bottom = "auto") : a.position === "left-bottom" ? (x.style.left = a.distance, x.style.bottom = a.distance, x.style.top = "auto", x.style.right = "auto") : (x.style.right = a.distance, x.style.top = a.distance, x.style.left = "auto", x.style.bottom = "auto"), a.backOverlay) { var S = t.document.getElementById(r.overlayID) || t.document.createElement("div"); S.id = r.overlayID, S.style.width = "100%", S.style.height = "100%", S.style.position = "fixed", S.style.zIndex = a.zindex - 1, S.style.left = 0, S.style.top = 0, S.style.right = 0, S.style.bottom = 0, S.style.background = A.backOverlayColor || a.backOverlayColor, S.className = a.cssAnimation ? "nx-with-animation" : "", S.style.animationDuration = a.cssAnimation ? a.cssAnimationDuration + "ms" : "", t.document.getElementById(r.overlayID) || t.document.body.appendChild(S) } t.document.getElementById(r.wrapID) || t.document.body.appendChild(x); var C = t.document.createElement("div"); C.id = a.ID + "-" + g, C.className = a.className + " " + A.childClassName + " " + (a.cssAnimation ? "nx-with-animation" : "") + " " + (a.useIcon ? "nx-with-icon" : "") + " nx-" + a.cssAnimationStyle + " " + (a.closeButton && typeof y != "function" ? "nx-with-close-button" : "") + " " + (typeof y == "function" ? "nx-with-callback" : "") + " " + (a.clickToClose ? "nx-notify-click-to-close" : ""), C.style.fontSize = a.fontSize, C.style.color = A.textColor, C.style.background = A.background, C.style.borderRadius = a.borderRadius, C.style.pointerEvents = "all", a.rtl && (C.setAttribute("dir", "rtl"), C.classList.add("nx-rtl-on")), C.style.fontFamily = '"' + a.fontFamily + '", ' + i, a.cssAnimation && (C.style.animationDuration = a.cssAnimationDuration + "ms"); var T = ""; if (a.closeButton && typeof y != "function" && (T = '<span class="nx-close-button"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><g><path fill="' + A.notiflixIconColor + '" d="M0.38 2.19l7.8 7.81 -7.8 7.81c-0.51,0.5 -0.51,1.31 -0.01,1.81 0.25,0.25 0.57,0.38 0.91,0.38 0.34,0 0.67,-0.14 0.91,-0.38l7.81 -7.81 7.81 7.81c0.24,0.24 0.57,0.38 0.91,0.38 0.34,0 0.66,-0.14 0.9,-0.38 0.51,-0.5 0.51,-1.31 0,-1.81l-7.81 -7.81 7.81 -7.81c0.51,-0.5 0.51,-1.31 0,-1.82 -0.5,-0.5 -1.31,-0.5 -1.81,0l-7.81 7.81 -7.81 -7.81c-0.5,-0.5 -1.31,-0.5 -1.81,0 -0.51,0.51 -0.51,1.32 0,1.82z"/></g></svg></span>'), a.useIcon) if (a.useFontAwesome) C.innerHTML = '<i style="color:' + A.fontAwesomeIconColor + "; font-size:" + a.fontAwesomeIconSize + ';" class="nx-message-icon nx-message-icon-fa ' + A.fontAwesomeClassName + " " + (a.fontAwesomeIconStyle === "shadow" ? "nx-message-icon-fa-shadow" : "nx-message-icon-fa-basic") + '"></i><span class="nx-message nx-with-icon">' + b + "</span>" + (a.closeButton ? T : ""); else { var R = ""; p === o.Success ? R = '<svg class="nx-message-icon" xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><g><path fill="' + A.notiflixIconColor + '" d="M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm-2.4 -13.29l11.52 -12.96c0.37,-0.41 1.01,-0.45 1.42,-0.08 0.42,0.37 0.46,1 0.09,1.42l-12.16 13.67c-0.19,0.22 -0.46,0.34 -0.75,0.34 -0.23,0 -0.45,-0.07 -0.63,-0.22l-7.6 -6.07c-0.43,-0.35 -0.5,-0.99 -0.16,-1.42 0.35,-0.43 0.99,-0.5 1.42,-0.16l6.85 5.48z"/></g></svg>' : p === o.Failure ? R = '<svg class="nx-message-icon" xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><g><path fill="' + A.notiflixIconColor + '" d="M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm1.42 -17.98l6.13 6.12c0.39,0.4 0.39,1.04 0,1.43 -0.19,0.19 -0.45,0.29 -0.71,0.29 -0.27,0 -0.53,-0.1 -0.72,-0.29l-6.12 -6.13 -6.13 6.13c-0.19,0.19 -0.44,0.29 -0.71,0.29 -0.27,0 -0.52,-0.1 -0.71,-0.29 -0.39,-0.39 -0.39,-1.03 0,-1.43l6.13 -6.12 -6.13 -6.13c-0.39,-0.39 -0.39,-1.03 0,-1.42 0.39,-0.39 1.03,-0.39 1.42,0l6.13 6.12 6.12 -6.12c0.4,-0.39 1.04,-0.39 1.43,0 0.39,0.39 0.39,1.03 0,1.42l-6.13 6.13z"/></g></svg>' : p === o.Warning ? R = '<svg class="nx-message-icon" xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><g><path fill="' + A.notiflixIconColor + '" d="M21.91 3.48l17.8 30.89c0.84,1.46 -0.23,3.25 -1.91,3.25l-35.6 0c-1.68,0 -2.75,-1.79 -1.91,-3.25l17.8 -30.89c0.85,-1.47 2.97,-1.47 3.82,0zm16.15 31.84l-17.8 -30.89c-0.11,-0.2 -0.41,-0.2 -0.52,0l-17.8 30.89c-0.12,0.2 0.05,0.4 0.26,0.4l35.6 0c0.21,0 0.38,-0.2 0.26,-0.4zm-19.01 -4.12l0 -1.05c0,-0.53 0.42,-0.95 0.95,-0.95 0.53,0 0.95,0.42 0.95,0.95l0 1.05c0,0.53 -0.42,0.95 -0.95,0.95 -0.53,0 -0.95,-0.42 -0.95,-0.95zm0 -4.66l0 -13.39c0,-0.52 0.42,-0.95 0.95,-0.95 0.53,0 0.95,0.43 0.95,0.95l0 13.39c0,0.53 -0.42,0.96 -0.95,0.96 -0.53,0 -0.95,-0.43 -0.95,-0.96z"/></g></svg>' : p === o.Info && (R = '<svg class="nx-message-icon" xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><g><path fill="' + A.notiflixIconColor + '" d="M20 0c11.03,0 20,8.97 20,20 0,11.03 -8.97,20 -20,20 -11.03,0 -20,-8.97 -20,-20 0,-11.03 8.97,-20 20,-20zm0 37.98c9.92,0 17.98,-8.06 17.98,-17.98 0,-9.92 -8.06,-17.98 -17.98,-17.98 -9.92,0 -17.98,8.06 -17.98,17.98 0,9.92 8.06,17.98 17.98,17.98zm-0.99 -23.3c0,-0.54 0.44,-0.98 0.99,-0.98 0.55,0 0.99,0.44 0.99,0.98l0 15.86c0,0.55 -0.44,0.99 -0.99,0.99 -0.55,0 -0.99,-0.44 -0.99,-0.99l0 -15.86zm0 -5.22c0,-0.55 0.44,-0.99 0.99,-0.99 0.55,0 0.99,0.44 0.99,0.99l0 1.09c0,0.54 -0.44,0.99 -0.99,0.99 -0.55,0 -0.99,-0.45 -0.99,-0.99l0 -1.09z"/></g></svg>'), C.innerHTML = R + '<span class="nx-message nx-with-icon">' + b + "</span>" + (a.closeButton ? T : "") } else C.innerHTML = '<span class="nx-message">' + b + "</span>" + (a.closeButton ? T : ""); if (a.position === "left-bottom" || a.position === "right-bottom") { var I = t.document.getElementById(r.wrapID); I.insertBefore(C, I.firstChild) } else t.document.getElementById(r.wrapID).appendChild(C); var H = t.document.getElementById(C.id); if (H) { var E, B, F = function () { H.classList.add("nx-remove"); var ft = t.document.getElementById(r.overlayID); ft && x.childElementCount <= 0 && ft.classList.add("nx-remove"), clearTimeout(E) }, G = function () { if (H && H.parentNode !== null && H.parentNode.removeChild(H), x.childElementCount <= 0 && x.parentNode !== null) { x.parentNode.removeChild(x); var ft = t.document.getElementById(r.overlayID); ft && ft.parentNode !== null && ft.parentNode.removeChild(ft) } clearTimeout(B) }; if (a.closeButton && typeof y != "function") { var nt = t.document.getElementById(C.id).querySelector("span.nx-close-button"); nt.addEventListener("click", function () { F(); var ft = setTimeout(function () { G(), clearTimeout(ft) }, a.cssAnimationDuration) }) } if ((typeof y == "function" || a.clickToClose) && H.addEventListener("click", function () { typeof y == "function" && y(), F(); var ft = setTimeout(function () { G(), clearTimeout(ft) }, a.cssAnimationDuration) }), !a.closeButton && typeof y != "function") { var kt = function () { E = setTimeout(function () { F() }, a.timeout), B = setTimeout(function () { G() }, a.timeout + a.cssAnimationDuration) }; kt(), a.pauseOnHover && (H.addEventListener("mouseenter", function () { H.classList.add("nx-paused"), clearTimeout(E), clearTimeout(B) }), H.addEventListener("mouseleave", function () { H.classList.remove("nx-paused"), kt() })) } } if (a.showOnlyTheLastOne && g > 0) for (var lt = t.document.querySelectorAll("[id^=" + a.ID + "-]:not([id=" + a.ID + "-" + g + "])"), bt = 0; bt < lt.length; bt++) { var St = lt[bt]; St.parentNode !== null && St.parentNode.removeChild(St) } a = u(!0, a, w) }, v = { Notify: { init: function (p) { a = u(!0, r, p), d(f, "NotiflixNotifyInternalCSS") }, merge: function (p) { if (a) a = u(!0, a, p); else return l("You have to initialize the Notify module before call Merge function."), !1 }, success: function (p, b, y) { m(o.Success, p, b, y) }, failure: function (p, b, y) { m(o.Failure, p, b, y) }, warning: function (p, b, y) { m(o.Warning, p, b, y) }, info: function (p, b, y) { m(o.Info, p, b, y) } } }; return typeof t.Notiflix == "object" ? u(!0, t.Notiflix, { Notify: v.Notify }) : { Notify: v.Notify }
  })
})(ql); var Ef = ql.exports; const Rf = Kl(Ef); var Xl = { exports: {} }; (function (n, t) {
  (function (e, s) { n.exports = s() })(Ds, function () {
    return function (e) { function s (o) { if (i[o]) return i[o].exports; var a = i[o] = { i: o, l: !1, exports: {} }; return e[o].call(a.exports, a, a.exports, s), a.l = !0, a.exports } var i = {}; return s.m = e, s.c = i, s.d = function (o, a, r) { s.o(o, a) || Object.defineProperty(o, a, { configurable: !1, enumerable: !0, get: r }) }, s.n = function (o) { var a = o && o.__esModule ? function () { return o.default } : function () { return o }; return s.d(a, "a", a), a }, s.o = function (o, a) { return Object.prototype.hasOwnProperty.call(o, a) }, s.p = "", s(s.s = 8) }([function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = "swal-button"; s.CLASS_NAMES = { MODAL: "swal-modal", OVERLAY: "swal-overlay", SHOW_MODAL: "swal-overlay--show-modal", MODAL_TITLE: "swal-title", MODAL_TEXT: "swal-text", ICON: "swal-icon", ICON_CUSTOM: "swal-icon--custom", CONTENT: "swal-content", FOOTER: "swal-footer", BUTTON_CONTAINER: "swal-button-container", BUTTON: o, CONFIRM_BUTTON: o + "--confirm", CANCEL_BUTTON: o + "--cancel", DANGER_BUTTON: o + "--danger", BUTTON_LOADING: o + "--loading", BUTTON_LOADER: o + "__loader" }, s.default = s.CLASS_NAMES }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }), s.getNode = function (o) { var a = "." + o; return document.querySelector(a) }, s.stringToNode = function (o) { var a = document.createElement("div"); return a.innerHTML = o.trim(), a.firstChild }, s.insertAfter = function (o, a) { var r = a.nextSibling; a.parentNode.insertBefore(o, r) }, s.removeNode = function (o) { o.parentElement.removeChild(o) }, s.throwErr = function (o) { throw o = o.replace(/ +(?= )/g, ""), "SweetAlert: " + (o = o.trim()) }, s.isPlainObject = function (o) { if (Object.prototype.toString.call(o) !== "[object Object]") return !1; var a = Object.getPrototypeOf(o); return a === null || a === Object.prototype }, s.ordinalSuffixOf = function (o) { var a = o % 10, r = o % 100; return a === 1 && r !== 11 ? o + "st" : a === 2 && r !== 12 ? o + "nd" : a === 3 && r !== 13 ? o + "rd" : o + "th" } }, function (e, s, i) {
      function o (h) { for (var f in h) s.hasOwnProperty(f) || (s[f] = h[f]) } Object.defineProperty(s, "__esModule", { value: !0 }), o(i(25)); var a = i(26); s.overlayMarkup = a.default, o(i(27)), o(i(28)), o(i(29)); var r = i(0), l = r.default.MODAL_TITLE, c = r.default.MODAL_TEXT, d = r.default.ICON, u = r.default.FOOTER; s.iconMarkup = `
  <div class="`+ d + '"></div>', s.titleMarkup = `
  <div class="`+ l + `"></div>
`, s.textMarkup = `
  <div class="`+ c + '"></div>', s.footerMarkup = `
  <div class="`+ u + `"></div>
`}, function (e, s, i) {
      Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(1); s.CONFIRM_KEY = "confirm", s.CANCEL_KEY = "cancel"; var a = { visible: !0, text: null, value: null, className: "", closeModal: !0 }, r = Object.assign({}, a, { visible: !1, text: "Cancel", value: null }), l = Object.assign({}, a, { text: "OK", value: !0 }); s.defaultButtonList = { cancel: r, confirm: l }; var c = function (f) { switch (f) { case s.CONFIRM_KEY: return l; case s.CANCEL_KEY: return r; default: var g = f.charAt(0).toUpperCase() + f.slice(1); return Object.assign({}, a, { text: g, value: f }) } }, d = function (f, g) { var m = c(f); return g === !0 ? Object.assign({}, m, { visible: !0 }) : typeof g == "string" ? Object.assign({}, m, { visible: !0, text: g }) : o.isPlainObject(g) ? Object.assign({ visible: !0 }, m, g) : Object.assign({}, m, { visible: !1 }) }, u = function (f) { for (var g = {}, m = 0, v = Object.keys(f); m < v.length; m++) { var p = v[m], b = f[p], y = d(p, b); g[p] = y } return g.cancel || (g.cancel = r), g }, h = function (f) {
        var g = {}; switch (f.length) {
          case 1: g[s.CANCEL_KEY] = Object.assign({}, r, { visible: !1 }); break; case 2: g[s.CANCEL_KEY] = d(s.CANCEL_KEY, f[0]), g[s.CONFIRM_KEY] = d(s.CONFIRM_KEY, f[1]); break; default: o.throwErr("Invalid number of 'buttons' in array (" + f.length + `).
      If you want more than 2 buttons, you need to use an object!`)
        }return g
      }; s.getButtonListOpts = function (f) { var g = s.defaultButtonList; return typeof f == "string" ? g[s.CONFIRM_KEY] = d(s.CONFIRM_KEY, f) : Array.isArray(f) ? g = h(f) : o.isPlainObject(f) ? g = u(f) : f === !0 ? g = h([!0, !0]) : f === !1 ? g = h([!1, !1]) : f === void 0 && (g = s.defaultButtonList), g }
    }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(1), a = i(2), r = i(0), l = r.default.MODAL, c = r.default.OVERLAY, d = i(30), u = i(31), h = i(32), f = i(33); s.injectElIntoModal = function (p) { var b = o.getNode(l), y = o.stringToNode(p); return b.appendChild(y), y }; var g = function (p) { p.className = l, p.textContent = "" }, m = function (p, b) { g(p); var y = b.className; y && p.classList.add(y) }; s.initModalContent = function (p) { var b = o.getNode(l); m(b, p), d.default(p.icon), u.initTitle(p.title), u.initText(p.text), f.default(p.content), h.default(p.buttons, p.dangerMode) }; var v = function () { var p = o.getNode(c), b = o.stringToNode(a.modalMarkup); p.appendChild(b) }; s.default = v }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(3), a = { isOpen: !1, promise: null, actions: {}, timer: null }, r = Object.assign({}, a); s.resetState = function () { r = Object.assign({}, a) }, s.setActionValue = function (c) { if (typeof c == "string") return l(o.CONFIRM_KEY, c); for (var d in c) l(d, c[d]) }; var l = function (c, d) { r.actions[c] || (r.actions[c] = {}), Object.assign(r.actions[c], { value: d }) }; s.setActionOptionsFor = function (c, d) { var u = (d === void 0 ? {} : d).closeModal, h = u === void 0 || u; Object.assign(r.actions[c], { closeModal: h }) }, s.default = r }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(1), a = i(3), r = i(0), l = r.default.OVERLAY, c = r.default.SHOW_MODAL, d = r.default.BUTTON, u = r.default.BUTTON_LOADING, h = i(5); s.openModal = function () { o.getNode(l).classList.add(c), h.default.isOpen = !0 }; var f = function () { o.getNode(l).classList.remove(c), h.default.isOpen = !1 }; s.onAction = function (g) { g === void 0 && (g = a.CANCEL_KEY); var m = h.default.actions[g], v = m.value; if (m.closeModal === !1) { var p = d + "--" + g; o.getNode(p).classList.add(u) } else f(); h.default.promise.resolve(v) }, s.getState = function () { var g = Object.assign({}, h.default); return delete g.promise, delete g.timer, g }, s.stopLoading = function () { for (var g = document.querySelectorAll("." + d), m = 0; m < g.length; m++)g[m].classList.remove(u) } }, function (e, s) { var i; i = function () { return this }(); try { i = i || Function("return this")() || (0, eval)("this") } catch { typeof window == "object" && (i = window) } e.exports = i }, function (e, s, i) { (function (o) { e.exports = o.sweetAlert = i(9) }).call(s, i(7)) }, function (e, s, i) { (function (o) { e.exports = o.swal = i(10) }).call(s, i(7)) }, function (e, s, i) { typeof window < "u" && i(11), i(16); var o = i(23).default; e.exports = o }, function (e, s, i) { var o = i(12); typeof o == "string" && (o = [[e.i, o, ""]]); var a = { insertAt: "top" }; a.transform = void 0, i(14)(o, a), o.locals && (e.exports = o.locals) }, function (e, s, i) { s = e.exports = i(13)(void 0), s.push([e.i, '.swal-icon--error{border-color:#f27474;-webkit-animation:animateErrorIcon .5s;animation:animateErrorIcon .5s}.swal-icon--error__x-mark{position:relative;display:block;-webkit-animation:animateXMark .5s;animation:animateXMark .5s}.swal-icon--error__line{position:absolute;height:5px;width:47px;background-color:#f27474;display:block;top:37px;border-radius:2px}.swal-icon--error__line--left{-webkit-transform:rotate(45deg);transform:rotate(45deg);left:17px}.swal-icon--error__line--right{-webkit-transform:rotate(-45deg);transform:rotate(-45deg);right:16px}@-webkit-keyframes animateErrorIcon{0%{-webkit-transform:rotateX(100deg);transform:rotateX(100deg);opacity:0}to{-webkit-transform:rotateX(0deg);transform:rotateX(0deg);opacity:1}}@keyframes animateErrorIcon{0%{-webkit-transform:rotateX(100deg);transform:rotateX(100deg);opacity:0}to{-webkit-transform:rotateX(0deg);transform:rotateX(0deg);opacity:1}}@-webkit-keyframes animateXMark{0%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}50%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}80%{-webkit-transform:scale(1.15);transform:scale(1.15);margin-top:-6px}to{-webkit-transform:scale(1);transform:scale(1);margin-top:0;opacity:1}}@keyframes animateXMark{0%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}50%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}80%{-webkit-transform:scale(1.15);transform:scale(1.15);margin-top:-6px}to{-webkit-transform:scale(1);transform:scale(1);margin-top:0;opacity:1}}.swal-icon--warning{border-color:#f8bb86;-webkit-animation:pulseWarning .75s infinite alternate;animation:pulseWarning .75s infinite alternate}.swal-icon--warning__body{width:5px;height:47px;top:10px;border-radius:2px;margin-left:-2px}.swal-icon--warning__body,.swal-icon--warning__dot{position:absolute;left:50%;background-color:#f8bb86}.swal-icon--warning__dot{width:7px;height:7px;border-radius:50%;margin-left:-4px;bottom:-11px}@-webkit-keyframes pulseWarning{0%{border-color:#f8d486}to{border-color:#f8bb86}}@keyframes pulseWarning{0%{border-color:#f8d486}to{border-color:#f8bb86}}.swal-icon--success{border-color:#a5dc86}.swal-icon--success:after,.swal-icon--success:before{content:"";border-radius:50%;position:absolute;width:60px;height:120px;background:#fff;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.swal-icon--success:before{border-radius:120px 0 0 120px;top:-7px;left:-33px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:60px 60px;transform-origin:60px 60px}.swal-icon--success:after{border-radius:0 120px 120px 0;top:-11px;left:30px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:0 60px;transform-origin:0 60px;-webkit-animation:rotatePlaceholder 4.25s ease-in;animation:rotatePlaceholder 4.25s ease-in}.swal-icon--success__ring{width:80px;height:80px;border:4px solid hsla(98,55%,69%,.2);border-radius:50%;box-sizing:content-box;position:absolute;left:-4px;top:-4px;z-index:2}.swal-icon--success__hide-corners{width:5px;height:90px;background-color:#fff;padding:1px;position:absolute;left:28px;top:8px;z-index:1;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.swal-icon--success__line{height:5px;background-color:#a5dc86;display:block;border-radius:2px;position:absolute;z-index:2}.swal-icon--success__line--tip{width:25px;left:14px;top:46px;-webkit-transform:rotate(45deg);transform:rotate(45deg);-webkit-animation:animateSuccessTip .75s;animation:animateSuccessTip .75s}.swal-icon--success__line--long{width:47px;right:8px;top:38px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-animation:animateSuccessLong .75s;animation:animateSuccessLong .75s}@-webkit-keyframes rotatePlaceholder{0%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}5%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}12%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}to{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}}@keyframes rotatePlaceholder{0%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}5%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}12%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}to{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}}@-webkit-keyframes animateSuccessTip{0%{width:0;left:1px;top:19px}54%{width:0;left:1px;top:19px}70%{width:50px;left:-8px;top:37px}84%{width:17px;left:21px;top:48px}to{width:25px;left:14px;top:45px}}@keyframes animateSuccessTip{0%{width:0;left:1px;top:19px}54%{width:0;left:1px;top:19px}70%{width:50px;left:-8px;top:37px}84%{width:17px;left:21px;top:48px}to{width:25px;left:14px;top:45px}}@-webkit-keyframes animateSuccessLong{0%{width:0;right:46px;top:54px}65%{width:0;right:46px;top:54px}84%{width:55px;right:0;top:35px}to{width:47px;right:8px;top:38px}}@keyframes animateSuccessLong{0%{width:0;right:46px;top:54px}65%{width:0;right:46px;top:54px}84%{width:55px;right:0;top:35px}to{width:47px;right:8px;top:38px}}.swal-icon--info{border-color:#c9dae1}.swal-icon--info:before{width:5px;height:29px;bottom:17px;border-radius:2px;margin-left:-2px}.swal-icon--info:after,.swal-icon--info:before{content:"";position:absolute;left:50%;background-color:#c9dae1}.swal-icon--info:after{width:7px;height:7px;border-radius:50%;margin-left:-3px;top:19px}.swal-icon{width:80px;height:80px;border-width:4px;border-style:solid;border-radius:50%;padding:0;position:relative;box-sizing:content-box;margin:20px auto}.swal-icon:first-child{margin-top:32px}.swal-icon--custom{width:auto;height:auto;max-width:100%;border:none;border-radius:0}.swal-icon img{max-width:100%;max-height:100%}.swal-title{color:rgba(0,0,0,.65);font-weight:600;text-transform:none;position:relative;display:block;padding:13px 16px;font-size:27px;line-height:normal;text-align:center;margin-bottom:0}.swal-title:first-child{margin-top:26px}.swal-title:not(:first-child){padding-bottom:0}.swal-title:not(:last-child){margin-bottom:13px}.swal-text{font-size:16px;position:relative;float:none;line-height:normal;vertical-align:top;text-align:left;display:inline-block;margin:0;padding:0 10px;font-weight:400;color:rgba(0,0,0,.64);max-width:calc(100% - 20px);overflow-wrap:break-word;box-sizing:border-box}.swal-text:first-child{margin-top:45px}.swal-text:last-child{margin-bottom:45px}.swal-footer{text-align:right;padding-top:13px;margin-top:13px;padding:13px 16px;border-radius:inherit;border-top-left-radius:0;border-top-right-radius:0}.swal-button-container{margin:5px;display:inline-block;position:relative}.swal-button{background-color:#7cd1f9;color:#fff;border:none;box-shadow:none;border-radius:5px;font-weight:600;font-size:14px;padding:10px 24px;margin:0;cursor:pointer}.swal-button:not([disabled]):hover{background-color:#78cbf2}.swal-button:active{background-color:#70bce0}.swal-button:focus{outline:none;box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(43,114,165,.29)}.swal-button[disabled]{opacity:.5;cursor:default}.swal-button::-moz-focus-inner{border:0}.swal-button--cancel{color:#555;background-color:#efefef}.swal-button--cancel:not([disabled]):hover{background-color:#e8e8e8}.swal-button--cancel:active{background-color:#d7d7d7}.swal-button--cancel:focus{box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(116,136,150,.29)}.swal-button--danger{background-color:#e64942}.swal-button--danger:not([disabled]):hover{background-color:#df4740}.swal-button--danger:active{background-color:#cf423b}.swal-button--danger:focus{box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(165,43,43,.29)}.swal-content{padding:0 20px;margin-top:20px;font-size:medium}.swal-content:last-child{margin-bottom:20px}.swal-content__input,.swal-content__textarea{-webkit-appearance:none;background-color:#fff;border:none;font-size:14px;display:block;box-sizing:border-box;width:100%;border:1px solid rgba(0,0,0,.14);padding:10px 13px;border-radius:2px;transition:border-color .2s}.swal-content__input:focus,.swal-content__textarea:focus{outline:none;border-color:#6db8ff}.swal-content__textarea{resize:vertical}.swal-button--loading{color:transparent}.swal-button--loading~.swal-button__loader{opacity:1}.swal-button__loader{position:absolute;height:auto;width:43px;z-index:2;left:50%;top:50%;-webkit-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);text-align:center;pointer-events:none;opacity:0}.swal-button__loader div{display:inline-block;float:none;vertical-align:baseline;width:9px;height:9px;padding:0;border:none;margin:2px;opacity:.4;border-radius:7px;background-color:hsla(0,0%,100%,.9);transition:background .2s;-webkit-animation:swal-loading-anim 1s infinite;animation:swal-loading-anim 1s infinite}.swal-button__loader div:nth-child(3n+2){-webkit-animation-delay:.15s;animation-delay:.15s}.swal-button__loader div:nth-child(3n+3){-webkit-animation-delay:.3s;animation-delay:.3s}@-webkit-keyframes swal-loading-anim{0%{opacity:.4}20%{opacity:.4}50%{opacity:1}to{opacity:.4}}@keyframes swal-loading-anim{0%{opacity:.4}20%{opacity:.4}50%{opacity:1}to{opacity:.4}}.swal-overlay{position:fixed;top:0;bottom:0;left:0;right:0;text-align:center;font-size:0;overflow-y:auto;background-color:rgba(0,0,0,.4);z-index:10000;pointer-events:none;opacity:0;transition:opacity .3s}.swal-overlay:before{content:" ";display:inline-block;vertical-align:middle;height:100%}.swal-overlay--show-modal{opacity:1;pointer-events:auto}.swal-overlay--show-modal .swal-modal{opacity:1;pointer-events:auto;box-sizing:border-box;-webkit-animation:showSweetAlert .3s;animation:showSweetAlert .3s;will-change:transform}.swal-modal{width:478px;opacity:0;pointer-events:none;background-color:#fff;text-align:center;border-radius:5px;position:static;margin:20px auto;display:inline-block;vertical-align:middle;-webkit-transform:scale(1);transform:scale(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;z-index:10001;transition:opacity .2s,-webkit-transform .3s;transition:transform .3s,opacity .2s;transition:transform .3s,opacity .2s,-webkit-transform .3s}@media (max-width:500px){.swal-modal{width:calc(100% - 20px)}}@-webkit-keyframes showSweetAlert{0%{-webkit-transform:scale(1);transform:scale(1)}1%{-webkit-transform:scale(.5);transform:scale(.5)}45%{-webkit-transform:scale(1.05);transform:scale(1.05)}80%{-webkit-transform:scale(.95);transform:scale(.95)}to{-webkit-transform:scale(1);transform:scale(1)}}@keyframes showSweetAlert{0%{-webkit-transform:scale(1);transform:scale(1)}1%{-webkit-transform:scale(.5);transform:scale(.5)}45%{-webkit-transform:scale(1.05);transform:scale(1.05)}80%{-webkit-transform:scale(.95);transform:scale(.95)}to{-webkit-transform:scale(1);transform:scale(1)}}', ""]) }, function (e, s) {
      function i (a, r) {
        var l = a[1] || "", c = a[3]; if (!c) return l; if (r && typeof btoa == "function") {
          var d = o(c); return [l].concat(c.sources.map(function (u) { return "/*# sourceURL=" + c.sourceRoot + u + " */" })).concat([d]).join(`
`)
        } return [l].join(`
`)
      } function o (a) { return "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(a)))) + " */" } e.exports = function (a) { var r = []; return r.toString = function () { return this.map(function (l) { var c = i(l, a); return l[2] ? "@media " + l[2] + "{" + c + "}" : c }).join("") }, r.i = function (l, c) { typeof l == "string" && (l = [[null, l, ""]]); for (var d = {}, u = 0; u < this.length; u++) { var h = this[u][0]; typeof h == "number" && (d[h] = !0) } for (u = 0; u < l.length; u++) { var f = l[u]; typeof f[0] == "number" && d[f[0]] || (c && !f[2] ? f[2] = c : c && (f[2] = "(" + f[2] + ") and (" + c + ")"), r.push(f)) } }, r }
    }, function (e, s, i) {
      function o (x, S) { for (var C = 0; C < x.length; C++) { var T = x[C], R = v[T.id]; if (R) { R.refs++; for (var I = 0; I < R.parts.length; I++)R.parts[I](T.parts[I]); for (; I < T.parts.length; I++)R.parts.push(h(T.parts[I], S)) } else { for (var H = [], I = 0; I < T.parts.length; I++)H.push(h(T.parts[I], S)); v[T.id] = { id: T.id, refs: 1, parts: H } } } } function a (x, S) { for (var C = [], T = {}, R = 0; R < x.length; R++) { var I = x[R], H = S.base ? I[0] + S.base : I[0], E = I[1], B = I[2], F = I[3], G = { css: E, media: B, sourceMap: F }; T[H] ? T[H].parts.push(G) : C.push(T[H] = { id: H, parts: [G] }) } return C } function r (x, S) { var C = b(x.insertInto); if (!C) throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid."); var T = w[w.length - 1]; if (x.insertAt === "top") T ? T.nextSibling ? C.insertBefore(S, T.nextSibling) : C.appendChild(S) : C.insertBefore(S, C.firstChild), w.push(S); else { if (x.insertAt !== "bottom") throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'."); C.appendChild(S) } } function l (x) { if (x.parentNode === null) return !1; x.parentNode.removeChild(x); var S = w.indexOf(x); S >= 0 && w.splice(S, 1) } function c (x) { var S = document.createElement("style"); return x.attrs.type = "text/css", u(S, x.attrs), r(x, S), S } function d (x) { var S = document.createElement("link"); return x.attrs.type = "text/css", x.attrs.rel = "stylesheet", u(S, x.attrs), r(x, S), S } function u (x, S) { Object.keys(S).forEach(function (C) { x.setAttribute(C, S[C]) }) } function h (x, S) { var C, T, R, I; if (S.transform && x.css) { if (!(I = S.transform(x.css))) return function () { }; x.css = I } if (S.singleton) { var H = k++; C = y || (y = c(S)), T = f.bind(null, C, H, !1), R = f.bind(null, C, H, !0) } else x.sourceMap && typeof URL == "function" && typeof URL.createObjectURL == "function" && typeof URL.revokeObjectURL == "function" && typeof Blob == "function" && typeof btoa == "function" ? (C = d(S), T = m.bind(null, C, S), R = function () { l(C), C.href && URL.revokeObjectURL(C.href) }) : (C = c(S), T = g.bind(null, C), R = function () { l(C) }); return T(x), function (E) { if (E) { if (E.css === x.css && E.media === x.media && E.sourceMap === x.sourceMap) return; T(x = E) } else R() } } function f (x, S, C, T) { var R = C ? "" : T.css; if (x.styleSheet) x.styleSheet.cssText = A(S, R); else { var I = document.createTextNode(R), H = x.childNodes; H[S] && x.removeChild(H[S]), H.length ? x.insertBefore(I, H[S]) : x.appendChild(I) } } function g (x, S) { var C = S.css, T = S.media; if (T && x.setAttribute("media", T), x.styleSheet) x.styleSheet.cssText = C; else { for (; x.firstChild;)x.removeChild(x.firstChild); x.appendChild(document.createTextNode(C)) } } function m (x, S, C) {
        var T = C.css, R = C.sourceMap, I = S.convertToAbsoluteUrls === void 0 && R; (S.convertToAbsoluteUrls || I) && (T = L(T)), R && (T += `
/*# sourceMappingURL=data:application/json;base64,`+ btoa(unescape(encodeURIComponent(JSON.stringify(R)))) + " */"); var H = new Blob([T], { type: "text/css" }), E = x.href; x.href = URL.createObjectURL(H), E && URL.revokeObjectURL(E)
      } var v = {}, p = function (x) { var S; return function () { return S === void 0 && (S = x.apply(this, arguments)), S } }(function () { return window && document && document.all && !window.atob }), b = function (x) { var S = {}; return function (C) { return S[C] === void 0 && (S[C] = x.call(this, C)), S[C] } }(function (x) { return document.querySelector(x) }), y = null, k = 0, w = [], L = i(15); e.exports = function (x, S) { if (typeof DEBUG < "u" && DEBUG && typeof document != "object") throw new Error("The style-loader cannot be used in a non-browser environment"); S = S || {}, S.attrs = typeof S.attrs == "object" ? S.attrs : {}, S.singleton || (S.singleton = p()), S.insertInto || (S.insertInto = "head"), S.insertAt || (S.insertAt = "bottom"); var C = a(x, S); return o(C, S), function (T) { for (var R = [], I = 0; I < C.length; I++) { var H = C[I], E = v[H.id]; E.refs--, R.push(E) } T && o(a(T, S), S); for (var I = 0; I < R.length; I++) { var E = R[I]; if (E.refs === 0) { for (var B = 0; B < E.parts.length; B++)E.parts[B](); delete v[E.id] } } } }; var A = function () {
        var x = []; return function (S, C) {
          return x[S] = C, x.filter(Boolean).join(`
`)
        }
      }()
    }, function (e, s) { e.exports = function (i) { var o = typeof window < "u" && window.location; if (!o) throw new Error("fixUrls requires window.location"); if (!i || typeof i != "string") return i; var a = o.protocol + "//" + o.host, r = a + o.pathname.replace(/\/[^\/]*$/, "/"); return i.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (l, c) { var d = c.trim().replace(/^"(.*)"$/, function (h, f) { return f }).replace(/^'(.*)'$/, function (h, f) { return f }); if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(d)) return l; var u; return u = d.indexOf("//") === 0 ? d : d.indexOf("/") === 0 ? a + d : r + d.replace(/^\.\//, ""), "url(" + JSON.stringify(u) + ")" }) } }, function (e, s, i) { var o = i(17); typeof window > "u" || window.Promise || (window.Promise = o), i(21), String.prototype.includes || (String.prototype.includes = function (a, r) { return typeof r != "number" && (r = 0), !(r + a.length > this.length) && this.indexOf(a, r) !== -1 }), Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", { value: function (a, r) { if (this == null) throw new TypeError('"this" is null or not defined'); var l = Object(this), c = l.length >>> 0; if (c === 0) return !1; for (var d = 0 | r, u = Math.max(d >= 0 ? d : c - Math.abs(d), 0); u < c;) { if (function (h, f) { return h === f || typeof h == "number" && typeof f == "number" && isNaN(h) && isNaN(f) }(l[u], a)) return !0; u++ } return !1 } }), typeof window < "u" && function (a) { a.forEach(function (r) { r.hasOwnProperty("remove") || Object.defineProperty(r, "remove", { configurable: !0, enumerable: !0, writable: !0, value: function () { this.parentNode.removeChild(this) } }) }) }([Element.prototype, CharacterData.prototype, DocumentType.prototype]) }, function (e, s, i) { (function (o) { (function (a) { function r () { } function l (p, b) { return function () { p.apply(b, arguments) } } function c (p) { if (typeof this != "object") throw new TypeError("Promises must be constructed via new"); if (typeof p != "function") throw new TypeError("not a function"); this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], m(p, this) } function d (p, b) { for (; p._state === 3;)p = p._value; if (p._state === 0) return void p._deferreds.push(b); p._handled = !0, c._immediateFn(function () { var y = p._state === 1 ? b.onFulfilled : b.onRejected; if (y === null) return void (p._state === 1 ? u : h)(b.promise, p._value); var k; try { k = y(p._value) } catch (w) { return void h(b.promise, w) } u(b.promise, k) }) } function u (p, b) { try { if (b === p) throw new TypeError("A promise cannot be resolved with itself."); if (b && (typeof b == "object" || typeof b == "function")) { var y = b.then; if (b instanceof c) return p._state = 3, p._value = b, void f(p); if (typeof y == "function") return void m(l(y, b), p) } p._state = 1, p._value = b, f(p) } catch (k) { h(p, k) } } function h (p, b) { p._state = 2, p._value = b, f(p) } function f (p) { p._state === 2 && p._deferreds.length === 0 && c._immediateFn(function () { p._handled || c._unhandledRejectionFn(p._value) }); for (var b = 0, y = p._deferreds.length; b < y; b++)d(p, p._deferreds[b]); p._deferreds = null } function g (p, b, y) { this.onFulfilled = typeof p == "function" ? p : null, this.onRejected = typeof b == "function" ? b : null, this.promise = y } function m (p, b) { var y = !1; try { p(function (k) { y || (y = !0, u(b, k)) }, function (k) { y || (y = !0, h(b, k)) }) } catch (k) { if (y) return; y = !0, h(b, k) } } var v = setTimeout; c.prototype.catch = function (p) { return this.then(null, p) }, c.prototype.then = function (p, b) { var y = new this.constructor(r); return d(this, new g(p, b, y)), y }, c.all = function (p) { var b = Array.prototype.slice.call(p); return new c(function (y, k) { function w (x, S) { try { if (S && (typeof S == "object" || typeof S == "function")) { var C = S.then; if (typeof C == "function") return void C.call(S, function (T) { w(x, T) }, k) } b[x] = S, --L == 0 && y(b) } catch (T) { k(T) } } if (b.length === 0) return y([]); for (var L = b.length, A = 0; A < b.length; A++)w(A, b[A]) }) }, c.resolve = function (p) { return p && typeof p == "object" && p.constructor === c ? p : new c(function (b) { b(p) }) }, c.reject = function (p) { return new c(function (b, y) { y(p) }) }, c.race = function (p) { return new c(function (b, y) { for (var k = 0, w = p.length; k < w; k++)p[k].then(b, y) }) }, c._immediateFn = typeof o == "function" && function (p) { o(p) } || function (p) { v(p, 0) }, c._unhandledRejectionFn = function (p) { typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", p) }, c._setImmediateFn = function (p) { c._immediateFn = p }, c._setUnhandledRejectionFn = function (p) { c._unhandledRejectionFn = p }, e !== void 0 && e.exports ? e.exports = c : a.Promise || (a.Promise = c) })(this) }).call(s, i(18).setImmediate) }, function (e, s, i) { function o (r, l) { this._id = r, this._clearFn = l } var a = Function.prototype.apply; s.setTimeout = function () { return new o(a.call(setTimeout, window, arguments), clearTimeout) }, s.setInterval = function () { return new o(a.call(setInterval, window, arguments), clearInterval) }, s.clearTimeout = s.clearInterval = function (r) { r && r.close() }, o.prototype.unref = o.prototype.ref = function () { }, o.prototype.close = function () { this._clearFn.call(window, this._id) }, s.enroll = function (r, l) { clearTimeout(r._idleTimeoutId), r._idleTimeout = l }, s.unenroll = function (r) { clearTimeout(r._idleTimeoutId), r._idleTimeout = -1 }, s._unrefActive = s.active = function (r) { clearTimeout(r._idleTimeoutId); var l = r._idleTimeout; l >= 0 && (r._idleTimeoutId = setTimeout(function () { r._onTimeout && r._onTimeout() }, l)) }, i(19), s.setImmediate = setImmediate, s.clearImmediate = clearImmediate }, function (e, s, i) { (function (o, a) { (function (r, l) { function c (y) { typeof y != "function" && (y = new Function("" + y)); for (var k = new Array(arguments.length - 1), w = 0; w < k.length; w++)k[w] = arguments[w + 1]; var L = { callback: y, args: k }; return m[g] = L, f(g), g++ } function d (y) { delete m[y] } function u (y) { var k = y.callback, w = y.args; switch (w.length) { case 0: k(); break; case 1: k(w[0]); break; case 2: k(w[0], w[1]); break; case 3: k(w[0], w[1], w[2]); break; default: k.apply(l, w) } } function h (y) { if (v) setTimeout(h, 0, y); else { var k = m[y]; if (k) { v = !0; try { u(k) } finally { d(y), v = !1 } } } } if (!r.setImmediate) { var f, g = 1, m = {}, v = !1, p = r.document, b = Object.getPrototypeOf && Object.getPrototypeOf(r); b = b && b.setTimeout ? b : r, {}.toString.call(r.process) === "[object process]" ? function () { f = function (y) { a.nextTick(function () { h(y) }) } }() : function () { if (r.postMessage && !r.importScripts) { var y = !0, k = r.onmessage; return r.onmessage = function () { y = !1 }, r.postMessage("", "*"), r.onmessage = k, y } }() ? function () { var y = "setImmediate$" + Math.random() + "$", k = function (w) { w.source === r && typeof w.data == "string" && w.data.indexOf(y) === 0 && h(+w.data.slice(y.length)) }; r.addEventListener ? r.addEventListener("message", k, !1) : r.attachEvent("onmessage", k), f = function (w) { r.postMessage(y + w, "*") } }() : r.MessageChannel ? function () { var y = new MessageChannel; y.port1.onmessage = function (k) { h(k.data) }, f = function (k) { y.port2.postMessage(k) } }() : p && "onreadystatechange" in p.createElement("script") ? function () { var y = p.documentElement; f = function (k) { var w = p.createElement("script"); w.onreadystatechange = function () { h(k), w.onreadystatechange = null, y.removeChild(w), w = null }, y.appendChild(w) } }() : function () { f = function (y) { setTimeout(h, 0, y) } }(), b.setImmediate = c, b.clearImmediate = d } })(typeof self > "u" ? o === void 0 ? this : o : self) }).call(s, i(7), i(20)) }, function (e, s) { function i () { throw new Error("setTimeout has not been defined") } function o () { throw new Error("clearTimeout has not been defined") } function a (y) { if (h === setTimeout) return setTimeout(y, 0); if ((h === i || !h) && setTimeout) return h = setTimeout, setTimeout(y, 0); try { return h(y, 0) } catch { try { return h.call(null, y, 0) } catch { return h.call(this, y, 0) } } } function r (y) { if (f === clearTimeout) return clearTimeout(y); if ((f === o || !f) && clearTimeout) return f = clearTimeout, clearTimeout(y); try { return f(y) } catch { try { return f.call(null, y) } catch { return f.call(this, y) } } } function l () { p && m && (p = !1, m.length ? v = m.concat(v) : b = -1, v.length && c()) } function c () { if (!p) { var y = a(l); p = !0; for (var k = v.length; k;) { for (m = v, v = []; ++b < k;)m && m[b].run(); b = -1, k = v.length } m = null, p = !1, r(y) } } function d (y, k) { this.fun = y, this.array = k } function u () { } var h, f, g = e.exports = {}; (function () { try { h = typeof setTimeout == "function" ? setTimeout : i } catch { h = i } try { f = typeof clearTimeout == "function" ? clearTimeout : o } catch { f = o } })(); var m, v = [], p = !1, b = -1; g.nextTick = function (y) { var k = new Array(arguments.length - 1); if (arguments.length > 1) for (var w = 1; w < arguments.length; w++)k[w - 1] = arguments[w]; v.push(new d(y, k)), v.length !== 1 || p || a(c) }, d.prototype.run = function () { this.fun.apply(null, this.array) }, g.title = "browser", g.browser = !0, g.env = {}, g.argv = [], g.version = "", g.versions = {}, g.on = u, g.addListener = u, g.once = u, g.off = u, g.removeListener = u, g.removeAllListeners = u, g.emit = u, g.prependListener = u, g.prependOnceListener = u, g.listeners = function (y) { return [] }, g.binding = function (y) { throw new Error("process.binding is not supported") }, g.cwd = function () { return "/" }, g.chdir = function (y) { throw new Error("process.chdir is not supported") }, g.umask = function () { return 0 } }, function (e, s, i) { i(22).polyfill() }, function (e, s, i) { function o (r, l) { if (r == null) throw new TypeError("Cannot convert first argument to object"); for (var c = Object(r), d = 1; d < arguments.length; d++) { var u = arguments[d]; if (u != null) for (var h = Object.keys(Object(u)), f = 0, g = h.length; f < g; f++) { var m = h[f], v = Object.getOwnPropertyDescriptor(u, m); v !== void 0 && v.enumerable && (c[m] = u[m]) } } return c } function a () { Object.assign || Object.defineProperty(Object, "assign", { enumerable: !1, configurable: !0, writable: !0, value: o }) } e.exports = { assign: o, polyfill: a } }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(24), a = i(6), r = i(5), l = i(36), c = function () { for (var d = [], u = 0; u < arguments.length; u++)d[u] = arguments[u]; if (typeof window < "u") { var h = l.getOpts.apply(void 0, d); return new Promise(function (f, g) { r.default.promise = { resolve: f, reject: g }, o.default(h), setTimeout(function () { a.openModal() }) }) } }; c.close = a.onAction, c.getState = a.getState, c.setActionValue = r.setActionValue, c.stopLoading = a.stopLoading, c.setDefaults = l.setDefaults, s.default = c }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(1), a = i(0), r = a.default.MODAL, l = i(4), c = i(34), d = i(35), u = i(1); s.init = function (h) { o.getNode(r) || (document.body || u.throwErr("You can only use SweetAlert AFTER the DOM has loaded!"), c.default(), l.default()), l.initModalContent(h), d.default(h) }, s.default = s.init }, function (e, s, i) {
      Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(0), a = o.default.MODAL; s.modalMarkup = `
  <div class="`+ a + '" role="dialog" aria-modal="true"></div>', s.default = s.modalMarkup
    }, function (e, s, i) {
      Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(0), a = o.default.OVERLAY, r = `<div 
    class="`+ a + `"
    tabIndex="-1">
  </div>`; s.default = r
    }, function (e, s, i) {
      Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(0), a = o.default.ICON; s.errorIconMarkup = function () {
        var r = a + "--error", l = r + "__line"; return `
    <div class="`+ r + `__x-mark">
      <span class="`+ l + " " + l + `--left"></span>
      <span class="`+ l + " " + l + `--right"></span>
    </div>
  `}, s.warningIconMarkup = function () {
          var r = a + "--warning"; return `
    <span class="`+ r + `__body">
      <span class="`+ r + `__dot"></span>
    </span>
  `}, s.successIconMarkup = function () {
          var r = a + "--success"; return `
    <span class="`+ r + "__line " + r + `__line--long"></span>
    <span class="`+ r + "__line " + r + `__line--tip"></span>

    <div class="`+ r + `__ring"></div>
    <div class="`+ r + `__hide-corners"></div>
  `}
    }, function (e, s, i) {
      Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(0), a = o.default.CONTENT; s.contentMarkup = `
  <div class="`+ a + `">

  </div>
`}, function (e, s, i) {
      Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(0), a = o.default.BUTTON_CONTAINER, r = o.default.BUTTON, l = o.default.BUTTON_LOADER; s.buttonMarkup = `
  <div class="`+ a + `">

    <button
      class="`+ r + `"
    ></button>

    <div class="`+ l + `">
      <div></div>
      <div></div>
      <div></div>
    </div>

  </div>
`}, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(4), a = i(2), r = i(0), l = r.default.ICON, c = r.default.ICON_CUSTOM, d = ["error", "warning", "success", "info"], u = { error: a.errorIconMarkup(), warning: a.warningIconMarkup(), success: a.successIconMarkup() }, h = function (m, v) { var p = l + "--" + m; v.classList.add(p); var b = u[m]; b && (v.innerHTML = b) }, f = function (m, v) { v.classList.add(c); var p = document.createElement("img"); p.src = m, v.appendChild(p) }, g = function (m) { if (m) { var v = o.injectElIntoModal(a.iconMarkup); d.includes(m) ? h(m, v) : f(m, v) } }; s.default = g }, function (e, s, i) {
      Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(2), a = i(4), r = function (l) { navigator.userAgent.includes("AppleWebKit") && (l.style.display = "none", l.offsetHeight, l.style.display = "") }; s.initTitle = function (l) { if (l) { var c = a.injectElIntoModal(o.titleMarkup); c.textContent = l, r(c) } }, s.initText = function (l) {
        if (l) {
          var c = document.createDocumentFragment(); l.split(`
`).forEach(function (u, h, f) { c.appendChild(document.createTextNode(u)), h < f.length - 1 && c.appendChild(document.createElement("br")) }); var d = a.injectElIntoModal(o.textMarkup); d.appendChild(c), r(d)
        }
      }
    }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(1), a = i(4), r = i(0), l = r.default.BUTTON, c = r.default.DANGER_BUTTON, d = i(3), u = i(2), h = i(6), f = i(5), g = function (v, p, b) { var y = p.text, k = p.value, w = p.className, L = p.closeModal, A = o.stringToNode(u.buttonMarkup), x = A.querySelector("." + l), S = l + "--" + v; x.classList.add(S), w && (Array.isArray(w) ? w : w.split(" ")).filter(function (T) { return T.length > 0 }).forEach(function (T) { x.classList.add(T) }), b && v === d.CONFIRM_KEY && x.classList.add(c), x.textContent = y; var C = {}; return C[v] = k, f.setActionValue(C), f.setActionOptionsFor(v, { closeModal: L }), x.addEventListener("click", function () { return h.onAction(v) }), A }, m = function (v, p) { var b = a.injectElIntoModal(u.footerMarkup); for (var y in v) { var k = v[y], w = g(y, k, p); k.visible && b.appendChild(w) } b.children.length === 0 && b.remove() }; s.default = m }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(3), a = i(4), r = i(2), l = i(5), c = i(6), d = i(0), u = d.default.CONTENT, h = function (m) { m.addEventListener("input", function (v) { var p = v.target, b = p.value; l.setActionValue(b) }), m.addEventListener("keyup", function (v) { if (v.key === "Enter") return c.onAction(o.CONFIRM_KEY) }), setTimeout(function () { m.focus(), l.setActionValue("") }, 0) }, f = function (m, v, p) { var b = document.createElement(v), y = u + "__" + v; b.classList.add(y); for (var k in p) { var w = p[k]; b[k] = w } v === "input" && h(b), m.appendChild(b) }, g = function (m) { if (m) { var v = a.injectElIntoModal(r.contentMarkup), p = m.element, b = m.attributes; typeof p == "string" ? f(v, p, b) : v.appendChild(p) } }; s.default = g }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(1), a = i(2), r = function () { var l = o.stringToNode(a.overlayMarkup); document.body.appendChild(l) }; s.default = r }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(5), a = i(6), r = i(1), l = i(3), c = i(0), d = c.default.MODAL, u = c.default.BUTTON, h = c.default.OVERLAY, f = function (T) { T.preventDefault(), b() }, g = function (T) { T.preventDefault(), y() }, m = function (T) { if (o.default.isOpen) switch (T.key) { case "Escape": return a.onAction(l.CANCEL_KEY) } }, v = function (T) { if (o.default.isOpen) switch (T.key) { case "Tab": return f(T) } }, p = function (T) { if (o.default.isOpen) return T.key === "Tab" && T.shiftKey ? g(T) : void 0 }, b = function () { var T = r.getNode(u); T && (T.tabIndex = 0, T.focus()) }, y = function () { var T = r.getNode(d), R = T.querySelectorAll("." + u), I = R.length - 1, H = R[I]; H && H.focus() }, k = function (T) { T[T.length - 1].addEventListener("keydown", v) }, w = function (T) { T[0].addEventListener("keydown", p) }, L = function () { var T = r.getNode(d), R = T.querySelectorAll("." + u); R.length && (k(R), w(R)) }, A = function (T) { if (r.getNode(h) === T.target) return a.onAction(l.CANCEL_KEY) }, x = function (T) { var R = r.getNode(h); R.removeEventListener("click", A), T && R.addEventListener("click", A) }, S = function (T) { o.default.timer && clearTimeout(o.default.timer), T && (o.default.timer = window.setTimeout(function () { return a.onAction(l.CANCEL_KEY) }, T)) }, C = function (T) { T.closeOnEsc ? document.addEventListener("keyup", m) : document.removeEventListener("keyup", m), T.dangerMode ? b() : y(), L(), x(T.closeOnClickOutside), S(T.timer) }; s.default = C }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(1), a = i(3), r = i(37), l = i(38), c = { title: null, text: null, icon: null, buttons: a.defaultButtonList, content: null, className: null, closeOnClickOutside: !0, closeOnEsc: !0, dangerMode: !1, timer: null }, d = Object.assign({}, c); s.setDefaults = function (p) { d = Object.assign({}, c, p) }; var u = function (p) { var b = p && p.button, y = p && p.buttons; return b !== void 0 && y !== void 0 && o.throwErr("Cannot set both 'button' and 'buttons' options!"), b !== void 0 ? { confirm: b } : y }, h = function (p) { return o.ordinalSuffixOf(p + 1) }, f = function (p, b) { o.throwErr(h(b) + " argument ('" + p + "') is invalid") }, g = function (p, b) { var y = p + 1, k = b[y]; o.isPlainObject(k) || k === void 0 || o.throwErr("Expected " + h(y) + " argument ('" + k + "') to be a plain object") }, m = function (p, b) { var y = p + 1, k = b[y]; k !== void 0 && o.throwErr("Unexpected " + h(y) + " argument (" + k + ")") }, v = function (p, b, y, k) { var w = typeof b, L = w === "string", A = b instanceof Element; if (L) { if (y === 0) return { text: b }; if (y === 1) return { text: b, title: k[0] }; if (y === 2) return g(y, k), { icon: b }; f(b, y) } else { if (A && y === 0) return g(y, k), { content: b }; if (o.isPlainObject(b)) return m(y, k), b; f(b, y) } }; s.getOpts = function () { for (var p = [], b = 0; b < arguments.length; b++)p[b] = arguments[b]; var y = {}; p.forEach(function (L, A) { var x = v(0, L, A, p); Object.assign(y, x) }); var k = u(y); y.buttons = a.getButtonListOpts(k), delete y.button, y.content = r.getContentOpts(y.content); var w = Object.assign({}, c, d, y); return Object.keys(w).forEach(function (L) { l.DEPRECATED_OPTS[L] && l.logDeprecation(L) }), w } }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }); var o = i(1), a = { element: "input", attributes: { placeholder: "" } }; s.getContentOpts = function (r) { var l = {}; return o.isPlainObject(r) ? Object.assign(l, r) : r instanceof Element ? { element: r } : r === "input" ? a : null } }, function (e, s, i) { Object.defineProperty(s, "__esModule", { value: !0 }), s.logDeprecation = function (o) { var a = s.DEPRECATED_OPTS[o], r = a.onlyRename, l = a.replacement, c = a.subOption, d = a.link, u = r ? "renamed" : "deprecated", h = 'SweetAlert warning: "' + o + '" option has been ' + u + "."; l && (h += " Please use" + (c ? ' "' + c + '" in ' : " ") + '"' + l + '" instead.'); var f = "https://sweetalert.js.org"; h += d ? " More details: " + f + d : " More details: " + f + "/guides/#upgrading-from-1x", console.warn(h) }, s.DEPRECATED_OPTS = { type: { replacement: "icon", link: "/docs/#icon" }, imageUrl: { replacement: "icon", link: "/docs/#icon" }, customClass: { replacement: "className", onlyRename: !0, link: "/docs/#classname" }, imageSize: {}, showCancelButton: { replacement: "buttons", link: "/docs/#buttons" }, showConfirmButton: { replacement: "button", link: "/docs/#button" }, confirmButtonText: { replacement: "button", link: "/docs/#button" }, confirmButtonColor: {}, cancelButtonText: { replacement: "buttons", link: "/docs/#buttons" }, closeOnConfirm: { replacement: "button", subOption: "closeModal", link: "/docs/#button" }, closeOnCancel: { replacement: "buttons", subOption: "closeModal", link: "/docs/#buttons" }, showLoaderOnConfirm: { replacement: "buttons" }, animation: {}, inputType: { replacement: "content", link: "/docs/#content" }, inputValue: { replacement: "content", link: "/docs/#content" }, inputPlaceholder: { replacement: "content", link: "/docs/#content" }, html: { replacement: "content", link: "/docs/#content" }, allowEscapeKey: { replacement: "closeOnEsc", onlyRename: !0, link: "/docs/#closeonesc" }, allowClickOutside: { replacement: "closeOnClickOutside", onlyRename: !0, link: "/docs/#closeonclickoutside" } } }])
  })
})(Xl); var If = Xl.exports; const Nf = Kl(If), { Notify: Ff } = Rf, wn = (n, t = "success") => { Ff[t](n, void 0, { useIcon: !1, position: "left-bottom" }) }, Vf = (n, t = "Confirm", e) => new Promise((s, i) => { Nf({ text: n, title: t, buttons: e, dangerMode: !0 }).then(async o => { o && s(o) }) }), Bf = n => { navigator.clipboard.writeText(n), wn("Copied to clipboard.") }, zf = { key: 0, class: "px-4 py-5 sm:px-6" }, jf = { class: "flex flex-wrap items-center justify-between -mt-4 -ml-4 sm:flex-nowrap" }, Hf = _("div", { class: "mt-4 ml-4" }, null, -1), Wf = { class: "flex-shrink-0 mt-4 ml-4" }, Uf = { key: 1, class: "overflow-hidden bg-white shadow dark:bg-gray-700 sm:rounded-md" }, Yf = { key: 0, class: "flex justify-center p-4" }, Kf = { key: 1, class: "text-center" }, qf = _("i", { class: "mx-auto text-5xl text-gray-400 ri-folder-add-line" }, null, -1), Xf = _("h3", { class: "mt-2 text-sm font-medium text-gray-900 dark:text-white" }, " No API Keys ", -1), Gf = _("p", { class: "mt-1 text-sm text-gray-500 dark:text-gray-200" }, " Get started by creating a new one. ", -1), Jf = { class: "my-6" }, Qf = _("i", { class: "mr-2 -ml-1 text-xl ri-add-fill" }, null, -1), Zf = { role: "list", class: "divide-y divide-gray-200" }, tp = { href: "#", class: "block hover:bg-gray-50 dark:hover:bg-gray-800" }, ep = { class: "flex items-center px-4 py-4 sm:px-6" }, np = { class: "flex items-center flex-1 min-w-0" }, sp = { class: "flex-1 min-w-0 px-4 md:grid md:grid-cols-2 md:gap-4" }, ip = { class: "flex items-center gap-3" }, op = _("i", { class: "text-sm ri-delete-bin-fill" }, null, -1), ap = { class: "text-sm font-medium truncate text-primary dark:text-white" }, rp = { class: "flex items-center gap-2 mt-2 text-sm text-gray-500 dark:text-gray-400" }, lp = { class: "truncate max-w-60" }, cp = { class: "items-center hidden md:flex" }, dp = { class: "text-sm text-gray-900 dark:text-white" }, up = ["datetime"], hp = _("div", null, [_("i", { class: "w-5 h-5 text-gray-400 dark:text-white ri-arrow-right-s-line" })], -1), fp = { key: 2, class: "mt-10 sm:mt-0" }, pp = { class: "md:grid md:grid-cols-3 md:gap-6" }, gp = { class: "mt-5 md:mt-0 md:col-span-3" }, mp = { class: "overflow-hidden shadow sm:rounded-md" }, bp = { class: "px-4 py-5 bg-white dark:bg-gray-800 sm:p-6" }, vp = { class: "grid grid-cols-6 gap-6" }, _p = { class: "col-span-6" }, yp = _("label", { for: "name", class: "block text-sm font-medium text-gray-700 dark:text-white" }, "Key name", -1), xp = { key: 0, class: "mt-2 text-sm text-red-700" }, wp = { class: "flex gap-3 px-4 py-3 text-right bg-gray-50 dark:bg-gray-700 sm:px-6" }, kp = z({ __name: "PageApiKeys", setup (n) { const t = et(!1), { data: e, update: s, loading: i } = vh((h, f) => Ve.Get("v1/account/api-keys", { hitSource: [/^createKey/], params: { page: h, limit: f } }), { initialPageSize: 30, initialData: { data: [] } }), o = K(() => { var h; return (h = l.value) == null ? void 0 : h.errors }), { send: a, form: r, error: l, loading: c } = _i(h => Ve.Post("v1/account/api-keys", h, { name: "createKey" }), { store: !0, resetAfterSubmiting: !0, initialForm: { name: "" } }).onSuccess(({ data: h }) => { t.value = !1, s({ data: [...e.value, h.data] }), wn("API key created successfully!") }), d = et(null), u = async h => { await Vf("Once deleted, all applications dependent on this key will no longer be able to access the API.", "Cornfirm Delete", [!0, "Yes Delete"]).then(async () => { d.value = h, await Ve.Delete("v1/account/api-keys/" + h, { name: "deleteKey" }).send().finally(() => { d.value = null }), s({ data: e.value.filter(f => f.id !== h) }), wn("API key deleted successfully!") }) }; return (h, f) => { var m, v; const g = Qt("CSpinner"); return M(), O(dt, null, [t.value ? N("", !0) : (M(), O("div", zf, [_("div", jf, [Hf, _("div", Wf, [j(Xe, { class: "text-white bg-primary hover:bg-primary focus:ring-primary", onClick: f[0] || (f[0] = p => t.value = !0) }, { default: D(() => [Lt(" Create new API key ")]), _: 1 })])])])), t.value ? (M(), O("div", fp, [_("div", pp, [_("div", gp, [_("form", { onSubmit: f[4] || (f[4] = sn((...p) => P(a) && P(a)(...p), ["prevent"])) }, [_("div", mp, [_("div", bp, [_("div", vp, [_("div", _p, [yp, Wt(_("input", { "onUpdate:modelValue": f[2] || (f[2] = p => P(r).name = p), type: "text", name: "name", id: "name", autocomplete: "off", class: "block w-full mt-1 text-black border-gray-500 border-solid rounded-md shadow-sm dark:bg-gray-400 focus:ring-green-500 focus:border-primary sm:text-sm" }, null, 512), [[se, P(r).name]]), (v = o.value) != null && v.name ? (M(), O("p", xp, q(o.value.name), 1)) : N("", !0)])])]), _("div", wp, [j(Xe, { class: "text-white bg-red-600 hover:bg-red-600 focus:ring-red-600", onClick: f[3] || (f[3] = p => t.value = !1) }, { default: D(() => [Lt(" Cancel ")]), _: 1 }), j(Xe, { type: "submit", class: "text-white bg-primary hover:bg-primary focus:ring-primary", loading: P(c) }, { default: D(() => [Lt(" Create ")]), _: 1 }, 8, ["loading"])])])], 32)])])])) : (M(), O("div", Uf, [P(i) ? (M(), O("div", Yf, [j(g, { size: "xl" })])) : (m = P(e)) != null && m.length ? N("", !0) : (M(), O("div", Kf, [qf, Xf, Gf, _("div", Jf, [j(Xe, { type: "button", class: "inline-flex items-center bg-green-600 hover:bg-green-700 focus:ring-green-500", onClick: f[1] || (f[1] = p => t.value = !0) }, { default: D(() => [Qf, Lt(" New API KEY ")]), _: 1 })])])), _("ul", Zf, [(M(!0), O(dt, null, Et(P(e), p => (M(), O("li", { key: p.id }, [_("a", tp, [_("div", ep, [_("div", np, [_("div", sp, [_("div", ip, [_("div", null, [j(Xe, { dense: "", type: "button", class: "px-1.5 py-1 text-white bg-red-600 hover:bg-red-700 focus:ring-red-500", loading: d.value === p.id, onClick: b => u(p.id) }, { default: D(() => [op]), _: 2 }, 1032, ["loading", "onClick"])]), _("div", null, [_("p", ap, q(p.name), 1), _("p", rp, [p.key.includes("****") ? N("", !0) : (M(), W(Xe, { key: 0, class: "px-1 py-0.5 text-white hover:bg-gray-600 focus:ring-1", icon: "ri-file-copy-fill", onClick: b => P(Bf)(p.key) }, null, 8, ["onClick"])), _("span", lp, q(p.key), 1)])])]), _("div", cp, [_("div", null, [_("p", dp, [Lt(" Created on "), _("time", { datetime: p.createdAt }, q(p.createDate), 9, up)])])])])]), hp])])]))), 128))])]))], 64) } } }), Sp = Object.freeze(Object.defineProperty({ __proto__: null, default: kp }, Symbol.toStringTag, { value: "Module" }));/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function ds (n) { return n + .5 | 0 } const $e = (n, t, e) => Math.max(Math.min(n, e), t); function Rn (n) { return $e(ds(n * 2.55), 0, 255) } function Be (n) { return $e(ds(n * 255), 0, 255) } function _e (n) { return $e(ds(n / 2.55) / 100, 0, 1) } function Na (n) { return $e(ds(n * 100), 0, 100) } const te = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, fo = [..."0123456789ABCDEF"], Mp = n => fo[n & 15], Pp = n => fo[(n & 240) >> 4] + fo[n & 15], bs = n => (n & 240) >> 4 === (n & 15), Cp = n => bs(n.r) && bs(n.g) && bs(n.b) && bs(n.a); function Tp (n) { var t = n.length, e; return n[0] === "#" && (t === 4 || t === 5 ? e = { r: 255 & te[n[1]] * 17, g: 255 & te[n[2]] * 17, b: 255 & te[n[3]] * 17, a: t === 5 ? te[n[4]] * 17 : 255 } : (t === 7 || t === 9) && (e = { r: te[n[1]] << 4 | te[n[2]], g: te[n[3]] << 4 | te[n[4]], b: te[n[5]] << 4 | te[n[6]], a: t === 9 ? te[n[7]] << 4 | te[n[8]] : 255 })), e } const Op = (n, t) => n < 255 ? t(n) : ""; function Lp (n) { var t = Cp(n) ? Mp : Pp; return n ? "#" + t(n.r) + t(n.g) + t(n.b) + Op(n.a, t) : void 0 } const Ap = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function Gl (n, t, e) { const s = t * Math.min(e, 1 - e), i = (o, a = (o + n / 30) % 12) => e - s * Math.max(Math.min(a - 3, 9 - a, 1), -1); return [i(0), i(8), i(4)] } function $p (n, t, e) { const s = (i, o = (i + n / 60) % 6) => e - e * t * Math.max(Math.min(o, 4 - o, 1), 0); return [s(5), s(3), s(1)] } function Dp (n, t, e) { const s = Gl(n, 1, .5); let i; for (t + e > 1 && (i = 1 / (t + e), t *= i, e *= i), i = 0; i < 3; i++)s[i] *= 1 - t - e, s[i] += t; return s } function Ep (n, t, e, s, i) { return n === i ? (t - e) / s + (t < e ? 6 : 0) : t === i ? (e - n) / s + 2 : (n - t) / s + 4 } function zo (n) { const e = n.r / 255, s = n.g / 255, i = n.b / 255, o = Math.max(e, s, i), a = Math.min(e, s, i), r = (o + a) / 2; let l, c, d; return o !== a && (d = o - a, c = r > .5 ? d / (2 - o - a) : d / (o + a), l = Ep(e, s, i, d, o), l = l * 60 + .5), [l | 0, c || 0, r] } function jo (n, t, e, s) { return (Array.isArray(t) ? n(t[0], t[1], t[2]) : n(t, e, s)).map(Be) } function Ho (n, t, e) { return jo(Gl, n, t, e) } function Rp (n, t, e) { return jo(Dp, n, t, e) } function Ip (n, t, e) { return jo($p, n, t, e) } function Jl (n) { return (n % 360 + 360) % 360 } function Np (n) { const t = Ap.exec(n); let e = 255, s; if (!t) return; t[5] !== s && (e = t[6] ? Rn(+t[5]) : Be(+t[5])); const i = Jl(+t[2]), o = +t[3] / 100, a = +t[4] / 100; return t[1] === "hwb" ? s = Rp(i, o, a) : t[1] === "hsv" ? s = Ip(i, o, a) : s = Ho(i, o, a), { r: s[0], g: s[1], b: s[2], a: e } } function Fp (n, t) { var e = zo(n); e[0] = Jl(e[0] + t), e = Ho(e), n.r = e[0], n.g = e[1], n.b = e[2] } function Vp (n) { if (!n) return; const t = zo(n), e = t[0], s = Na(t[1]), i = Na(t[2]); return n.a < 255 ? `hsla(${e}, ${s}%, ${i}%, ${_e(n.a)})` : `hsl(${e}, ${s}%, ${i}%)` } const Fa = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, Va = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; function Bp () { const n = {}, t = Object.keys(Va), e = Object.keys(Fa); let s, i, o, a, r; for (s = 0; s < t.length; s++) { for (a = r = t[s], i = 0; i < e.length; i++)o = e[i], r = r.replace(o, Fa[o]); o = parseInt(Va[a], 16), n[r] = [o >> 16 & 255, o >> 8 & 255, o & 255] } return n } let vs; function zp (n) { vs || (vs = Bp(), vs.transparent = [0, 0, 0, 0]); const t = vs[n.toLowerCase()]; return t && { r: t[0], g: t[1], b: t[2], a: t.length === 4 ? t[3] : 255 } } const jp = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/; function Hp (n) { const t = jp.exec(n); let e = 255, s, i, o; if (t) { if (t[7] !== s) { const a = +t[7]; e = t[8] ? Rn(a) : $e(a * 255, 0, 255) } return s = +t[1], i = +t[3], o = +t[5], s = 255 & (t[2] ? Rn(s) : $e(s, 0, 255)), i = 255 & (t[4] ? Rn(i) : $e(i, 0, 255)), o = 255 & (t[6] ? Rn(o) : $e(o, 0, 255)), { r: s, g: i, b: o, a: e } } } function Wp (n) { return n && (n.a < 255 ? `rgba(${n.r}, ${n.g}, ${n.b}, ${_e(n.a)})` : `rgb(${n.r}, ${n.g}, ${n.b})`) } const Vi = n => n <= .0031308 ? n * 12.92 : Math.pow(n, 1 / 2.4) * 1.055 - .055, gn = n => n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4); function Up (n, t, e) { const s = gn(_e(n.r)), i = gn(_e(n.g)), o = gn(_e(n.b)); return { r: Be(Vi(s + e * (gn(_e(t.r)) - s))), g: Be(Vi(i + e * (gn(_e(t.g)) - i))), b: Be(Vi(o + e * (gn(_e(t.b)) - o))), a: n.a + e * (t.a - n.a) } } function _s (n, t, e) { if (n) { let s = zo(n); s[t] = Math.max(0, Math.min(s[t] + s[t] * e, t === 0 ? 360 : 1)), s = Ho(s), n.r = s[0], n.g = s[1], n.b = s[2] } } function Ql (n, t) { return n && Object.assign(t || {}, n) } function Ba (n) { var t = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(n) ? n.length >= 3 && (t = { r: n[0], g: n[1], b: n[2], a: 255 }, n.length > 3 && (t.a = Be(n[3]))) : (t = Ql(n, { r: 0, g: 0, b: 0, a: 1 }), t.a = Be(t.a)), t } function Yp (n) { return n.charAt(0) === "r" ? Hp(n) : Np(n) } class Qn { constructor(t) { if (t instanceof Qn) return t; const e = typeof t; let s; e === "object" ? s = Ba(t) : e === "string" && (s = Tp(t) || zp(t) || Yp(t)), this._rgb = s, this._valid = !!s } get valid () { return this._valid } get rgb () { var t = Ql(this._rgb); return t && (t.a = _e(t.a)), t } set rgb (t) { this._rgb = Ba(t) } rgbString () { return this._valid ? Wp(this._rgb) : void 0 } hexString () { return this._valid ? Lp(this._rgb) : void 0 } hslString () { return this._valid ? Vp(this._rgb) : void 0 } mix (t, e) { if (t) { const s = this.rgb, i = t.rgb; let o; const a = e === o ? .5 : e, r = 2 * a - 1, l = s.a - i.a, c = ((r * l === -1 ? r : (r + l) / (1 + r * l)) + 1) / 2; o = 1 - c, s.r = 255 & c * s.r + o * i.r + .5, s.g = 255 & c * s.g + o * i.g + .5, s.b = 255 & c * s.b + o * i.b + .5, s.a = a * s.a + (1 - a) * i.a, this.rgb = s } return this } interpolate (t, e) { return t && (this._rgb = Up(this._rgb, t._rgb, e)), this } clone () { return new Qn(this.rgb) } alpha (t) { return this._rgb.a = Be(t), this } clearer (t) { const e = this._rgb; return e.a *= 1 - t, this } greyscale () { const t = this._rgb, e = ds(t.r * .3 + t.g * .59 + t.b * .11); return t.r = t.g = t.b = e, this } opaquer (t) { const e = this._rgb; return e.a *= 1 + t, this } negate () { const t = this._rgb; return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this } lighten (t) { return _s(this._rgb, 2, t), this } darken (t) { return _s(this._rgb, 2, -t), this } saturate (t) { return _s(this._rgb, 1, t), this } desaturate (t) { return _s(this._rgb, 1, -t), this } rotate (t) { return Fp(this._rgb, t), this } }/*!
 * Chart.js v4.4.3
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */function me () { } const Kp = (() => { let n = 0; return () => n++ })(); function at (n) { return n === null || typeof n > "u" } function yt (n) { if (Array.isArray && Array.isArray(n)) return !0; const t = Object.prototype.toString.call(n); return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]" } function ot (n) { return n !== null && Object.prototype.toString.call(n) === "[object Object]" } function Mt (n) { return (typeof n == "number" || n instanceof Number) && isFinite(+n) } function Xt (n, t) { return Mt(n) ? n : t } function tt (n, t) { return typeof n > "u" ? t : n } const qp = (n, t) => typeof n == "string" && n.endsWith("%") ? parseFloat(n) / 100 : +n / t, Zl = (n, t) => typeof n == "string" && n.endsWith("%") ? parseFloat(n) / 100 * t : +n; function pt (n, t, e) { if (n && typeof n.call == "function") return n.apply(e, t) } function ut (n, t, e, s) { let i, o, a; if (yt(n)) for (o = n.length, i = 0; i < o; i++)t.call(e, n[i], i); else if (ot(n)) for (a = Object.keys(n), o = a.length, i = 0; i < o; i++)t.call(e, n[a[i]], a[i]) } function Zs (n, t) { let e, s, i, o; if (!n || !t || n.length !== t.length) return !1; for (e = 0, s = n.length; e < s; ++e)if (i = n[e], o = t[e], i.datasetIndex !== o.datasetIndex || i.index !== o.index) return !1; return !0 } function ti (n) { if (yt(n)) return n.map(ti); if (ot(n)) { const t = Object.create(null), e = Object.keys(n), s = e.length; let i = 0; for (; i < s; ++i)t[e[i]] = ti(n[e[i]]); return t } return n } function tc (n) { return ["__proto__", "prototype", "constructor"].indexOf(n) === -1 } function Xp (n, t, e, s) { if (!tc(n)) return; const i = t[n], o = e[n]; ot(i) && ot(o) ? Zn(i, o, s) : t[n] = ti(o) } function Zn (n, t, e) { const s = yt(t) ? t : [t], i = s.length; if (!ot(n)) return n; e = e || {}; const o = e.merger || Xp; let a; for (let r = 0; r < i; ++r) { if (a = s[r], !ot(a)) continue; const l = Object.keys(a); for (let c = 0, d = l.length; c < d; ++c)o(l[c], n, a, e) } return n } function Wn (n, t) { return Zn(n, t, { merger: Gp }) } function Gp (n, t, e) { if (!tc(n)) return; const s = t[n], i = e[n]; ot(s) && ot(i) ? Wn(s, i) : Object.prototype.hasOwnProperty.call(t, n) || (t[n] = ti(i)) } const za = { "": n => n, x: n => n.x, y: n => n.y }; function Jp (n) { const t = n.split("."), e = []; let s = ""; for (const i of t) s += i, s.endsWith("\\") ? s = s.slice(0, -1) + "." : (e.push(s), s = ""); return e } function Qp (n) { const t = Jp(n); return e => { for (const s of t) { if (s === "") break; e = e && e[s] } return e } } function je (n, t) { return (za[t] || (za[t] = Qp(t)))(n) } function Wo (n) { return n.charAt(0).toUpperCase() + n.slice(1) } const ts = n => typeof n < "u", He = n => typeof n == "function", ja = (n, t) => { if (n.size !== t.size) return !1; for (const e of n) if (!t.has(e)) return !1; return !0 }; function Zp (n) { return n.type === "mouseup" || n.type === "click" || n.type === "contextmenu" } const mt = Math.PI, gt = 2 * mt, tg = gt + mt, ei = Number.POSITIVE_INFINITY, eg = mt / 180, Ct = mt / 2, Ue = mt / 4, Ha = mt * 2 / 3, De = Math.log10, fe = Math.sign; function Un (n, t, e) { return Math.abs(n - t) < e } function Wa (n) { const t = Math.round(n); n = Un(n, t, n / 1e3) ? t : n; const e = Math.pow(10, Math.floor(De(n))), s = n / e; return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * e } function ng (n) { const t = [], e = Math.sqrt(n); let s; for (s = 1; s < e; s++)n % s === 0 && (t.push(s), t.push(n / s)); return e === (e | 0) && t.push(e), t.sort((i, o) => i - o).pop(), t } function kn (n) { return !isNaN(parseFloat(n)) && isFinite(n) } function sg (n, t) { const e = Math.round(n); return e - t <= n && e + t >= n } function ec (n, t, e) { let s, i, o; for (s = 0, i = n.length; s < i; s++)o = n[s][e], isNaN(o) || (t.min = Math.min(t.min, o), t.max = Math.max(t.max, o)) } function oe (n) { return n * (mt / 180) } function Uo (n) { return n * (180 / mt) } function Ua (n) { if (!Mt(n)) return; let t = 1, e = 0; for (; Math.round(n * t) / t !== n;)t *= 10, e++; return e } function nc (n, t) { const e = t.x - n.x, s = t.y - n.y, i = Math.sqrt(e * e + s * s); let o = Math.atan2(s, e); return o < -.5 * mt && (o += gt), { angle: o, distance: i } } function po (n, t) { return Math.sqrt(Math.pow(t.x - n.x, 2) + Math.pow(t.y - n.y, 2)) } function ig (n, t) { return (n - t + tg) % gt - mt } function Gt (n) { return (n % gt + gt) % gt } function es (n, t, e, s) { const i = Gt(n), o = Gt(t), a = Gt(e), r = Gt(o - i), l = Gt(a - i), c = Gt(i - o), d = Gt(i - a); return i === o || i === a || s && o === a || r > l && c < d } function Dt (n, t, e) { return Math.max(t, Math.min(e, n)) } function og (n) { return Dt(n, -32768, 32767) } function xe (n, t, e, s = 1e-6) { return n >= Math.min(t, e) - s && n <= Math.max(t, e) + s } function Yo (n, t, e) { e = e || (a => n[a] < t); let s = n.length - 1, i = 0, o; for (; s - i > 1;)o = i + s >> 1, e(o) ? i = o : s = o; return { lo: i, hi: s } } const we = (n, t, e, s) => Yo(n, e, s ? i => { const o = n[i][t]; return o < e || o === e && n[i + 1][t] === e } : i => n[i][t] < e), ag = (n, t, e) => Yo(n, e, s => n[s][t] >= e); function rg (n, t, e) { let s = 0, i = n.length; for (; s < i && n[s] < t;)s++; for (; i > s && n[i - 1] > e;)i--; return s > 0 || i < n.length ? n.slice(s, i) : n } const sc = ["push", "pop", "shift", "splice", "unshift"]; function lg (n, t) { if (n._chartjs) { n._chartjs.listeners.push(t); return } Object.defineProperty(n, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [t] } }), sc.forEach(e => { const s = "_onData" + Wo(e), i = n[e]; Object.defineProperty(n, e, { configurable: !0, enumerable: !1, value (...o) { const a = i.apply(this, o); return n._chartjs.listeners.forEach(r => { typeof r[s] == "function" && r[s](...o) }), a } }) }) } function Ya (n, t) { const e = n._chartjs; if (!e) return; const s = e.listeners, i = s.indexOf(t); i !== -1 && s.splice(i, 1), !(s.length > 0) && (sc.forEach(o => { delete n[o] }), delete n._chartjs) } function ic (n) { const t = new Set(n); return t.size === n.length ? n : Array.from(t) } const oc = function () { return typeof window > "u" ? function (n) { return n() } : window.requestAnimationFrame }(); function ac (n, t) { let e = [], s = !1; return function (...i) { e = i, s || (s = !0, oc.call(window, () => { s = !1, n.apply(t, e) })) } } function cg (n, t) { let e; return function (...s) { return t ? (clearTimeout(e), e = setTimeout(n, t, s)) : n.apply(this, s), t } } const Ko = n => n === "start" ? "left" : n === "end" ? "right" : "center", zt = (n, t, e) => n === "start" ? t : n === "end" ? e : (t + e) / 2, dg = (n, t, e, s) => n === (s ? "left" : "right") ? e : n === "center" ? (t + e) / 2 : t; function rc (n, t, e) { const s = t.length; let i = 0, o = s; if (n._sorted) { const { iScale: a, _parsed: r } = n, l = a.axis, { min: c, max: d, minDefined: u, maxDefined: h } = a.getUserBounds(); u && (i = Dt(Math.min(we(r, l, c).lo, e ? s : we(t, l, a.getPixelForValue(c)).lo), 0, s - 1)), h ? o = Dt(Math.max(we(r, a.axis, d, !0).hi + 1, e ? 0 : we(t, l, a.getPixelForValue(d), !0).hi + 1), i, s) - i : o = s - i } return { start: i, count: o } } function lc (n) { const { xScale: t, yScale: e, _scaleRanges: s } = n, i = { xmin: t.min, xmax: t.max, ymin: e.min, ymax: e.max }; if (!s) return n._scaleRanges = i, !0; const o = s.xmin !== t.min || s.xmax !== t.max || s.ymin !== e.min || s.ymax !== e.max; return Object.assign(s, i), o } const ys = n => n === 0 || n === 1, Ka = (n, t, e) => -(Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * gt / e)), qa = (n, t, e) => Math.pow(2, -10 * n) * Math.sin((n - t) * gt / e) + 1, Yn = { linear: n => n, easeInQuad: n => n * n, easeOutQuad: n => -n * (n - 2), easeInOutQuad: n => (n /= .5) < 1 ? .5 * n * n : -.5 * (--n * (n - 2) - 1), easeInCubic: n => n * n * n, easeOutCubic: n => (n -= 1) * n * n + 1, easeInOutCubic: n => (n /= .5) < 1 ? .5 * n * n * n : .5 * ((n -= 2) * n * n + 2), easeInQuart: n => n * n * n * n, easeOutQuart: n => -((n -= 1) * n * n * n - 1), easeInOutQuart: n => (n /= .5) < 1 ? .5 * n * n * n * n : -.5 * ((n -= 2) * n * n * n - 2), easeInQuint: n => n * n * n * n * n, easeOutQuint: n => (n -= 1) * n * n * n * n + 1, easeInOutQuint: n => (n /= .5) < 1 ? .5 * n * n * n * n * n : .5 * ((n -= 2) * n * n * n * n + 2), easeInSine: n => -Math.cos(n * Ct) + 1, easeOutSine: n => Math.sin(n * Ct), easeInOutSine: n => -.5 * (Math.cos(mt * n) - 1), easeInExpo: n => n === 0 ? 0 : Math.pow(2, 10 * (n - 1)), easeOutExpo: n => n === 1 ? 1 : -Math.pow(2, -10 * n) + 1, easeInOutExpo: n => ys(n) ? n : n < .5 ? .5 * Math.pow(2, 10 * (n * 2 - 1)) : .5 * (-Math.pow(2, -10 * (n * 2 - 1)) + 2), easeInCirc: n => n >= 1 ? n : -(Math.sqrt(1 - n * n) - 1), easeOutCirc: n => Math.sqrt(1 - (n -= 1) * n), easeInOutCirc: n => (n /= .5) < 1 ? -.5 * (Math.sqrt(1 - n * n) - 1) : .5 * (Math.sqrt(1 - (n -= 2) * n) + 1), easeInElastic: n => ys(n) ? n : Ka(n, .075, .3), easeOutElastic: n => ys(n) ? n : qa(n, .075, .3), easeInOutElastic (n) { return ys(n) ? n : n < .5 ? .5 * Ka(n * 2, .1125, .45) : .5 + .5 * qa(n * 2 - 1, .1125, .45) }, easeInBack (n) { return n * n * ((1.70158 + 1) * n - 1.70158) }, easeOutBack (n) { return (n -= 1) * n * ((1.70158 + 1) * n + 1.70158) + 1 }, easeInOutBack (n) { let t = 1.70158; return (n /= .5) < 1 ? .5 * (n * n * (((t *= 1.525) + 1) * n - t)) : .5 * ((n -= 2) * n * (((t *= 1.525) + 1) * n + t) + 2) }, easeInBounce: n => 1 - Yn.easeOutBounce(1 - n), easeOutBounce (n) { return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + .75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + .9375 : 7.5625 * (n -= 2.625 / 2.75) * n + .984375 }, easeInOutBounce: n => n < .5 ? Yn.easeInBounce(n * 2) * .5 : Yn.easeOutBounce(n * 2 - 1) * .5 + .5 }; function qo (n) { if (n && typeof n == "object") { const t = n.toString(); return t === "[object CanvasPattern]" || t === "[object CanvasGradient]" } return !1 } function Xa (n) { return qo(n) ? n : new Qn(n) } function Bi (n) { return qo(n) ? n : new Qn(n).saturate(.5).darken(.1).hexString() } const ug = ["x", "y", "borderWidth", "radius", "tension"], hg = ["color", "borderColor", "backgroundColor"]; function fg (n) { n.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }), n.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: t => t !== "onProgress" && t !== "onComplete" && t !== "fn" }), n.set("animations", { colors: { type: "color", properties: hg }, numbers: { type: "number", properties: ug } }), n.describe("animations", { _fallback: "animation" }), n.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: t => t | 0 } } } }) } function pg (n) { n.set("layout", { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }) } const Ga = new Map; function gg (n, t) { t = t || {}; const e = n + JSON.stringify(t); let s = Ga.get(e); return s || (s = new Intl.NumberFormat(n, t), Ga.set(e, s)), s } function us (n, t, e) { return gg(t, e).format(n) } const cc = { values (n) { return yt(n) ? n : "" + n }, numeric (n, t, e) { if (n === 0) return "0"; const s = this.chart.options.locale; let i, o = n; if (e.length > 1) { const c = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value)); (c < 1e-4 || c > 1e15) && (i = "scientific"), o = mg(n, e) } const a = De(Math.abs(o)), r = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0), l = { notation: i, minimumFractionDigits: r, maximumFractionDigits: r }; return Object.assign(l, this.options.ticks.format), us(n, s, l) }, logarithmic (n, t, e) { if (n === 0) return "0"; const s = e[t].significand || n / Math.pow(10, Math.floor(De(n))); return [1, 2, 3, 5, 10, 15].includes(s) || t > .8 * e.length ? cc.numeric.call(this, n, t, e) : "" } }; function mg (n, t) { let e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value; return Math.abs(e) >= 1 && n !== Math.floor(n) && (e = n - Math.floor(n)), e } var yi = { formatters: cc }; function bg (n) { n.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", clip: !0, grace: 0, grid: { display: !0, lineWidth: 1, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (t, e) => e.lineWidth, tickColor: (t, e) => e.color, offset: !1 }, border: { display: !0, dash: [], dashOffset: 0, width: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: yi.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), n.route("scale.ticks", "color", "", "color"), n.route("scale.grid", "color", "", "borderColor"), n.route("scale.border", "color", "", "borderColor"), n.route("scale.title", "color", "", "color"), n.describe("scale", { _fallback: !1, _scriptable: t => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser", _indexable: t => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash" }), n.describe("scales", { _fallback: "scale" }), n.describe("scale.ticks", { _scriptable: t => t !== "backdropPadding" && t !== "callback", _indexable: t => t !== "backdropPadding" }) } const cn = Object.create(null), go = Object.create(null); function Kn (n, t) { if (!t) return n; const e = t.split("."); for (let s = 0, i = e.length; s < i; ++s) { const o = e[s]; n = n[o] || (n[o] = Object.create(null)) } return n } function zi (n, t, e) { return typeof t == "string" ? Zn(Kn(n, t), e) : Zn(Kn(n, ""), t) } class vg { constructor(t, e) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = s => s.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (s, i) => Bi(i.backgroundColor), this.hoverBorderColor = (s, i) => Bi(i.borderColor), this.hoverColor = (s, i) => Bi(i.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(e) } set (t, e) { return zi(this, t, e) } get (t) { return Kn(this, t) } describe (t, e) { return zi(go, t, e) } override (t, e) { return zi(cn, t, e) } route (t, e, s, i) { const o = Kn(this, t), a = Kn(this, s), r = "_" + e; Object.defineProperties(o, { [r]: { value: o[e], writable: !0 }, [e]: { enumerable: !0, get () { const l = this[r], c = a[i]; return ot(l) ? Object.assign({}, c, l) : tt(l, c) }, set (l) { this[r] = l } } }) } apply (t) { t.forEach(e => e(this)) } } var Pt = new vg({ _scriptable: n => !n.startsWith("on"), _indexable: n => n !== "events", hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }, [fg, pg, bg]); function _g (n) { return !n || at(n.size) || at(n.family) ? null : (n.style ? n.style + " " : "") + (n.weight ? n.weight + " " : "") + n.size + "px " + n.family } function ni (n, t, e, s, i) { let o = t[i]; return o || (o = t[i] = n.measureText(i).width, e.push(i)), o > s && (s = o), s } function yg (n, t, e, s) { s = s || {}; let i = s.data = s.data || {}, o = s.garbageCollect = s.garbageCollect || []; s.font !== t && (i = s.data = {}, o = s.garbageCollect = [], s.font = t), n.save(), n.font = t; let a = 0; const r = e.length; let l, c, d, u, h; for (l = 0; l < r; l++)if (u = e[l], u != null && !yt(u)) a = ni(n, i, o, a, u); else if (yt(u)) for (c = 0, d = u.length; c < d; c++)h = u[c], h != null && !yt(h) && (a = ni(n, i, o, a, h)); n.restore(); const f = o.length / 2; if (f > e.length) { for (l = 0; l < f; l++)delete i[o[l]]; o.splice(0, f) } return a } function Ye (n, t, e) { const s = n.currentDevicePixelRatio, i = e !== 0 ? Math.max(e / 2, .5) : 0; return Math.round((t - i) * s) / s + i } function Ja (n, t) { !t && !n || (t = t || n.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, n.width, n.height), t.restore()) } function mo (n, t, e, s) { dc(n, t, e, s, null) } function dc (n, t, e, s, i) { let o, a, r, l, c, d, u, h; const f = t.pointStyle, g = t.rotation, m = t.radius; let v = (g || 0) * eg; if (f && typeof f == "object" && (o = f.toString(), o === "[object HTMLImageElement]" || o === "[object HTMLCanvasElement]")) { n.save(), n.translate(e, s), n.rotate(v), n.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), n.restore(); return } if (!(isNaN(m) || m <= 0)) { switch (n.beginPath(), f) { default: i ? n.ellipse(e, s, i / 2, m, 0, 0, gt) : n.arc(e, s, m, 0, gt), n.closePath(); break; case "triangle": d = i ? i / 2 : m, n.moveTo(e + Math.sin(v) * d, s - Math.cos(v) * m), v += Ha, n.lineTo(e + Math.sin(v) * d, s - Math.cos(v) * m), v += Ha, n.lineTo(e + Math.sin(v) * d, s - Math.cos(v) * m), n.closePath(); break; case "rectRounded": c = m * .516, l = m - c, a = Math.cos(v + Ue) * l, u = Math.cos(v + Ue) * (i ? i / 2 - c : l), r = Math.sin(v + Ue) * l, h = Math.sin(v + Ue) * (i ? i / 2 - c : l), n.arc(e - u, s - r, c, v - mt, v - Ct), n.arc(e + h, s - a, c, v - Ct, v), n.arc(e + u, s + r, c, v, v + Ct), n.arc(e - h, s + a, c, v + Ct, v + mt), n.closePath(); break; case "rect": if (!g) { l = Math.SQRT1_2 * m, d = i ? i / 2 : l, n.rect(e - d, s - l, 2 * d, 2 * l); break } v += Ue; case "rectRot": u = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, r = Math.sin(v) * m, h = Math.sin(v) * (i ? i / 2 : m), n.moveTo(e - u, s - r), n.lineTo(e + h, s - a), n.lineTo(e + u, s + r), n.lineTo(e - h, s + a), n.closePath(); break; case "crossRot": v += Ue; case "cross": u = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, r = Math.sin(v) * m, h = Math.sin(v) * (i ? i / 2 : m), n.moveTo(e - u, s - r), n.lineTo(e + u, s + r), n.moveTo(e + h, s - a), n.lineTo(e - h, s + a); break; case "star": u = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, r = Math.sin(v) * m, h = Math.sin(v) * (i ? i / 2 : m), n.moveTo(e - u, s - r), n.lineTo(e + u, s + r), n.moveTo(e + h, s - a), n.lineTo(e - h, s + a), v += Ue, u = Math.cos(v) * (i ? i / 2 : m), a = Math.cos(v) * m, r = Math.sin(v) * m, h = Math.sin(v) * (i ? i / 2 : m), n.moveTo(e - u, s - r), n.lineTo(e + u, s + r), n.moveTo(e + h, s - a), n.lineTo(e - h, s + a); break; case "line": a = i ? i / 2 : Math.cos(v) * m, r = Math.sin(v) * m, n.moveTo(e - a, s - r), n.lineTo(e + a, s + r); break; case "dash": n.moveTo(e, s), n.lineTo(e + Math.cos(v) * (i ? i / 2 : m), s + Math.sin(v) * m); break; case !1: n.closePath(); break }n.fill(), t.borderWidth > 0 && n.stroke() } } function ke (n, t, e) { return e = e || .5, !t || n && n.x > t.left - e && n.x < t.right + e && n.y > t.top - e && n.y < t.bottom + e } function xi (n, t) { n.save(), n.beginPath(), n.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), n.clip() } function wi (n) { n.restore() } function xg (n, t, e, s, i) { if (!t) return n.lineTo(e.x, e.y); if (i === "middle") { const o = (t.x + e.x) / 2; n.lineTo(o, t.y), n.lineTo(o, e.y) } else i === "after" != !!s ? n.lineTo(t.x, e.y) : n.lineTo(e.x, t.y); n.lineTo(e.x, e.y) } function wg (n, t, e, s) { if (!t) return n.lineTo(e.x, e.y); n.bezierCurveTo(s ? t.cp1x : t.cp2x, s ? t.cp1y : t.cp2y, s ? e.cp2x : e.cp1x, s ? e.cp2y : e.cp1y, e.x, e.y) } function kg (n, t) { t.translation && n.translate(t.translation[0], t.translation[1]), at(t.rotation) || n.rotate(t.rotation), t.color && (n.fillStyle = t.color), t.textAlign && (n.textAlign = t.textAlign), t.textBaseline && (n.textBaseline = t.textBaseline) } function Sg (n, t, e, s, i) { if (i.strikethrough || i.underline) { const o = n.measureText(s), a = t - o.actualBoundingBoxLeft, r = t + o.actualBoundingBoxRight, l = e - o.actualBoundingBoxAscent, c = e + o.actualBoundingBoxDescent, d = i.strikethrough ? (l + c) / 2 : c; n.strokeStyle = n.fillStyle, n.beginPath(), n.lineWidth = i.decorationWidth || 2, n.moveTo(a, d), n.lineTo(r, d), n.stroke() } } function Mg (n, t) { const e = n.fillStyle; n.fillStyle = t.color, n.fillRect(t.left, t.top, t.width, t.height), n.fillStyle = e } function dn (n, t, e, s, i, o = {}) { const a = yt(t) ? t : [t], r = o.strokeWidth > 0 && o.strokeColor !== ""; let l, c; for (n.save(), n.font = i.string, kg(n, o), l = 0; l < a.length; ++l)c = a[l], o.backdrop && Mg(n, o.backdrop), r && (o.strokeColor && (n.strokeStyle = o.strokeColor), at(o.strokeWidth) || (n.lineWidth = o.strokeWidth), n.strokeText(c, e, s, o.maxWidth)), n.fillText(c, e, s, o.maxWidth), Sg(n, e, s, c, o), s += Number(i.lineHeight); n.restore() } function ns (n, t) { const { x: e, y: s, w: i, h: o, radius: a } = t; n.arc(e + a.topLeft, s + a.topLeft, a.topLeft, 1.5 * mt, mt, !0), n.lineTo(e, s + o - a.bottomLeft), n.arc(e + a.bottomLeft, s + o - a.bottomLeft, a.bottomLeft, mt, Ct, !0), n.lineTo(e + i - a.bottomRight, s + o), n.arc(e + i - a.bottomRight, s + o - a.bottomRight, a.bottomRight, Ct, 0, !0), n.lineTo(e + i, s + a.topRight), n.arc(e + i - a.topRight, s + a.topRight, a.topRight, 0, -Ct, !0), n.lineTo(e + a.topLeft, s) } const Pg = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, Cg = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/; function Tg (n, t) { const e = ("" + n).match(Pg); if (!e || e[1] === "normal") return t * 1.2; switch (n = +e[2], e[3]) { case "px": return n; case "%": n /= 100; break }return t * n } const Og = n => +n || 0; function Xo (n, t) { const e = {}, s = ot(t), i = s ? Object.keys(t) : t, o = ot(n) ? s ? a => tt(n[a], n[t[a]]) : a => n[a] : () => n; for (const a of i) e[a] = Og(o(a)); return e } function uc (n) { return Xo(n, { top: "y", right: "x", bottom: "y", left: "x" }) } function en (n) { return Xo(n, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function Ht (n) { const t = uc(n); return t.width = t.left + t.right, t.height = t.top + t.bottom, t } function At (n, t) { n = n || {}, t = t || Pt.font; let e = tt(n.size, t.size); typeof e == "string" && (e = parseInt(e, 10)); let s = tt(n.style, t.style); s && !("" + s).match(Cg) && (console.warn('Invalid font style specified: "' + s + '"'), s = void 0); const i = { family: tt(n.family, t.family), lineHeight: Tg(tt(n.lineHeight, t.lineHeight), e), size: e, style: s, weight: tt(n.weight, t.weight), string: "" }; return i.string = _g(i), i } function In (n, t, e, s) { let i, o, a; for (i = 0, o = n.length; i < o; ++i)if (a = n[i], a !== void 0 && a !== void 0) return a } function Lg (n, t, e) { const { min: s, max: i } = n, o = Zl(t, (i - s) / 2), a = (r, l) => e && r === 0 ? 0 : r + l; return { min: a(s, -Math.abs(o)), max: a(i, o) } } function We (n, t) { return Object.assign(Object.create(n), t) } function Go (n, t = [""], e, s, i = () => n[0]) { const o = e || n; typeof s > "u" && (s = gc("_fallback", n)); const a = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: n, _rootScopes: o, _fallback: s, _getTarget: i, override: r => Go([r, ...n], t, o, s) }; return new Proxy(a, { deleteProperty (r, l) { return delete r[l], delete r._keys, delete n[0][l], !0 }, get (r, l) { return fc(r, l, () => Fg(l, t, n, r)) }, getOwnPropertyDescriptor (r, l) { return Reflect.getOwnPropertyDescriptor(r._scopes[0], l) }, getPrototypeOf () { return Reflect.getPrototypeOf(n[0]) }, has (r, l) { return Za(r).includes(l) }, ownKeys (r) { return Za(r) }, set (r, l, c) { const d = r._storage || (r._storage = i()); return r[l] = d[l] = c, delete r._keys, !0 } }) } function Sn (n, t, e, s) { const i = { _cacheable: !1, _proxy: n, _context: t, _subProxy: e, _stack: new Set, _descriptors: hc(n, s), setContext: o => Sn(n, o, e, s), override: o => Sn(n.override(o), t, e, s) }; return new Proxy(i, { deleteProperty (o, a) { return delete o[a], delete n[a], !0 }, get (o, a, r) { return fc(o, a, () => $g(o, a, r)) }, getOwnPropertyDescriptor (o, a) { return o._descriptors.allKeys ? Reflect.has(n, a) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(n, a) }, getPrototypeOf () { return Reflect.getPrototypeOf(n) }, has (o, a) { return Reflect.has(n, a) }, ownKeys () { return Reflect.ownKeys(n) }, set (o, a, r) { return n[a] = r, delete o[a], !0 } }) } function hc (n, t = { scriptable: !0, indexable: !0 }) { const { _scriptable: e = t.scriptable, _indexable: s = t.indexable, _allKeys: i = t.allKeys } = n; return { allKeys: i, scriptable: e, indexable: s, isScriptable: He(e) ? e : () => e, isIndexable: He(s) ? s : () => s } } const Ag = (n, t) => n ? n + Wo(t) : t, Jo = (n, t) => ot(t) && n !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object); function fc (n, t, e) { if (Object.prototype.hasOwnProperty.call(n, t) || t === "constructor") return n[t]; const s = e(); return n[t] = s, s } function $g (n, t, e) { const { _proxy: s, _context: i, _subProxy: o, _descriptors: a } = n; let r = s[t]; return He(r) && a.isScriptable(t) && (r = Dg(t, r, n, e)), yt(r) && r.length && (r = Eg(t, r, n, a.isIndexable)), Jo(t, r) && (r = Sn(r, i, o && o[t], a)), r } function Dg (n, t, e, s) { const { _proxy: i, _context: o, _subProxy: a, _stack: r } = e; if (r.has(n)) throw new Error("Recursion detected: " + Array.from(r).join("->") + "->" + n); r.add(n); let l = t(o, a || s); return r.delete(n), Jo(n, l) && (l = Qo(i._scopes, i, n, l)), l } function Eg (n, t, e, s) { const { _proxy: i, _context: o, _subProxy: a, _descriptors: r } = e; if (typeof o.index < "u" && s(n)) return t[o.index % t.length]; if (ot(t[0])) { const l = t, c = i._scopes.filter(d => d !== l); t = []; for (const d of l) { const u = Qo(c, i, n, d); t.push(Sn(u, o, a && a[n], r)) } } return t } function pc (n, t, e) { return He(n) ? n(t, e) : n } const Rg = (n, t) => n === !0 ? t : typeof n == "string" ? je(t, n) : void 0; function Ig (n, t, e, s, i) { for (const o of t) { const a = Rg(e, o); if (a) { n.add(a); const r = pc(a._fallback, e, i); if (typeof r < "u" && r !== e && r !== s) return r } else if (a === !1 && typeof s < "u" && e !== s) return null } return !1 } function Qo (n, t, e, s) { const i = t._rootScopes, o = pc(t._fallback, e, s), a = [...n, ...i], r = new Set; r.add(s); let l = Qa(r, a, e, o || e, s); return l === null || typeof o < "u" && o !== e && (l = Qa(r, a, o, l, s), l === null) ? !1 : Go(Array.from(r), [""], i, o, () => Ng(t, e, s)) } function Qa (n, t, e, s, i) { for (; e;)e = Ig(n, t, e, s, i); return e } function Ng (n, t, e) { const s = n._getTarget(); t in s || (s[t] = {}); const i = s[t]; return yt(i) && ot(e) ? e : i || {} } function Fg (n, t, e, s) { let i; for (const o of t) if (i = gc(Ag(o, n), e), typeof i < "u") return Jo(n, i) ? Qo(e, s, n, i) : i } function gc (n, t) { for (const e of t) { if (!e) continue; const s = e[n]; if (typeof s < "u") return s } } function Za (n) { let t = n._keys; return t || (t = n._keys = Vg(n._scopes)), t } function Vg (n) { const t = new Set; for (const e of n) for (const s of Object.keys(e).filter(i => !i.startsWith("_"))) t.add(s); return Array.from(t) } function mc (n, t, e, s) { const { iScale: i } = n, { key: o = "r" } = this._parsing, a = new Array(s); let r, l, c, d; for (r = 0, l = s; r < l; ++r)c = r + e, d = t[c], a[r] = { r: i.parse(je(d, o), c) }; return a } const Bg = Number.EPSILON || 1e-14, Mn = (n, t) => t < n.length && !n[t].skip && n[t], bc = n => n === "x" ? "y" : "x"; function zg (n, t, e, s) { const i = n.skip ? t : n, o = t, a = e.skip ? t : e, r = po(o, i), l = po(a, o); let c = r / (r + l), d = l / (r + l); c = isNaN(c) ? 0 : c, d = isNaN(d) ? 0 : d; const u = s * c, h = s * d; return { previous: { x: o.x - u * (a.x - i.x), y: o.y - u * (a.y - i.y) }, next: { x: o.x + h * (a.x - i.x), y: o.y + h * (a.y - i.y) } } } function jg (n, t, e) { const s = n.length; let i, o, a, r, l, c = Mn(n, 0); for (let d = 0; d < s - 1; ++d)if (l = c, c = Mn(n, d + 1), !(!l || !c)) { if (Un(t[d], 0, Bg)) { e[d] = e[d + 1] = 0; continue } i = e[d] / t[d], o = e[d + 1] / t[d], r = Math.pow(i, 2) + Math.pow(o, 2), !(r <= 9) && (a = 3 / Math.sqrt(r), e[d] = i * a * t[d], e[d + 1] = o * a * t[d]) } } function Hg (n, t, e = "x") { const s = bc(e), i = n.length; let o, a, r, l = Mn(n, 0); for (let c = 0; c < i; ++c) { if (a = r, r = l, l = Mn(n, c + 1), !r) continue; const d = r[e], u = r[s]; a && (o = (d - a[e]) / 3, r[`cp1${e}`] = d - o, r[`cp1${s}`] = u - o * t[c]), l && (o = (l[e] - d) / 3, r[`cp2${e}`] = d + o, r[`cp2${s}`] = u + o * t[c]) } } function Wg (n, t = "x") { const e = bc(t), s = n.length, i = Array(s).fill(0), o = Array(s); let a, r, l, c = Mn(n, 0); for (a = 0; a < s; ++a)if (r = l, l = c, c = Mn(n, a + 1), !!l) { if (c) { const d = c[t] - l[t]; i[a] = d !== 0 ? (c[e] - l[e]) / d : 0 } o[a] = r ? c ? fe(i[a - 1]) !== fe(i[a]) ? 0 : (i[a - 1] + i[a]) / 2 : i[a - 1] : i[a] } jg(n, i, o), Hg(n, o, t) } function xs (n, t, e) { return Math.max(Math.min(n, e), t) } function Ug (n, t) { let e, s, i, o, a, r = ke(n[0], t); for (e = 0, s = n.length; e < s; ++e)a = o, o = r, r = e < s - 1 && ke(n[e + 1], t), o && (i = n[e], a && (i.cp1x = xs(i.cp1x, t.left, t.right), i.cp1y = xs(i.cp1y, t.top, t.bottom)), r && (i.cp2x = xs(i.cp2x, t.left, t.right), i.cp2y = xs(i.cp2y, t.top, t.bottom))) } function Yg (n, t, e, s, i) { let o, a, r, l; if (t.spanGaps && (n = n.filter(c => !c.skip)), t.cubicInterpolationMode === "monotone") Wg(n, i); else { let c = s ? n[n.length - 1] : n[0]; for (o = 0, a = n.length; o < a; ++o)r = n[o], l = zg(c, r, n[Math.min(o + 1, a - (s ? 0 : 1)) % a], t.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, c = r } t.capBezierPoints && Ug(n, e) } function Zo () { return typeof window < "u" && typeof document < "u" } function ta (n) { let t = n.parentNode; return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t } function si (n, t, e) { let s; return typeof n == "string" ? (s = parseInt(n, 10), n.indexOf("%") !== -1 && (s = s / 100 * t.parentNode[e])) : s = n, s } const ki = n => n.ownerDocument.defaultView.getComputedStyle(n, null); function Kg (n, t) { return ki(n).getPropertyValue(t) } const qg = ["top", "right", "bottom", "left"]; function nn (n, t, e) { const s = {}; e = e ? "-" + e : ""; for (let i = 0; i < 4; i++) { const o = qg[i]; s[o] = parseFloat(n[t + "-" + o + e]) || 0 } return s.width = s.left + s.right, s.height = s.top + s.bottom, s } const Xg = (n, t, e) => (n > 0 || t > 0) && (!e || !e.shadowRoot); function Gg (n, t) { const e = n.touches, s = e && e.length ? e[0] : n, { offsetX: i, offsetY: o } = s; let a = !1, r, l; if (Xg(i, o, n.target)) r = i, l = o; else { const c = t.getBoundingClientRect(); r = s.clientX - c.left, l = s.clientY - c.top, a = !0 } return { x: r, y: l, box: a } } function Je (n, t) { if ("native" in n) return n; const { canvas: e, currentDevicePixelRatio: s } = t, i = ki(e), o = i.boxSizing === "border-box", a = nn(i, "padding"), r = nn(i, "border", "width"), { x: l, y: c, box: d } = Gg(n, e), u = a.left + (d && r.left), h = a.top + (d && r.top); let { width: f, height: g } = t; return o && (f -= a.width + r.width, g -= a.height + r.height), { x: Math.round((l - u) / f * e.width / s), y: Math.round((c - h) / g * e.height / s) } } function Jg (n, t, e) { let s, i; if (t === void 0 || e === void 0) { const o = n && ta(n); if (!o) t = n.clientWidth, e = n.clientHeight; else { const a = o.getBoundingClientRect(), r = ki(o), l = nn(r, "border", "width"), c = nn(r, "padding"); t = a.width - c.width - l.width, e = a.height - c.height - l.height, s = si(r.maxWidth, o, "clientWidth"), i = si(r.maxHeight, o, "clientHeight") } } return { width: t, height: e, maxWidth: s || ei, maxHeight: i || ei } } const ws = n => Math.round(n * 10) / 10; function Qg (n, t, e, s) { const i = ki(n), o = nn(i, "margin"), a = si(i.maxWidth, n, "clientWidth") || ei, r = si(i.maxHeight, n, "clientHeight") || ei, l = Jg(n, t, e); let { width: c, height: d } = l; if (i.boxSizing === "content-box") { const h = nn(i, "border", "width"), f = nn(i, "padding"); c -= f.width + h.width, d -= f.height + h.height } return c = Math.max(0, c - o.width), d = Math.max(0, s ? c / s : d - o.height), c = ws(Math.min(c, a, l.maxWidth)), d = ws(Math.min(d, r, l.maxHeight)), c && !d && (d = ws(c / 2)), (t !== void 0 || e !== void 0) && s && l.height && d > l.height && (d = l.height, c = ws(Math.floor(d * s))), { width: c, height: d } } function tr (n, t, e) { const s = t || 1, i = Math.floor(n.height * s), o = Math.floor(n.width * s); n.height = Math.floor(n.height), n.width = Math.floor(n.width); const a = n.canvas; return a.style && (e || !a.style.height && !a.style.width) && (a.style.height = `${n.height}px`, a.style.width = `${n.width}px`), n.currentDevicePixelRatio !== s || a.height !== i || a.width !== o ? (n.currentDevicePixelRatio = s, a.height = i, a.width = o, n.ctx.setTransform(s, 0, 0, s, 0, 0), !0) : !1 } const Zg = function () { let n = !1; try { const t = { get passive () { return n = !0, !1 } }; Zo() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t)) } catch { } return n }(); function er (n, t) { const e = Kg(n, t), s = e && e.match(/^(\d+)(\.\d+)?px$/); return s ? +s[1] : void 0 } function Qe (n, t, e, s) { return { x: n.x + e * (t.x - n.x), y: n.y + e * (t.y - n.y) } } function tm (n, t, e, s) { return { x: n.x + e * (t.x - n.x), y: s === "middle" ? e < .5 ? n.y : t.y : s === "after" ? e < 1 ? n.y : t.y : e > 0 ? t.y : n.y } } function em (n, t, e, s) { const i = { x: n.cp2x, y: n.cp2y }, o = { x: t.cp1x, y: t.cp1y }, a = Qe(n, i, e), r = Qe(i, o, e), l = Qe(o, t, e), c = Qe(a, r, e), d = Qe(r, l, e); return Qe(c, d, e) } const nm = function (n, t) { return { x (e) { return n + n + t - e }, setWidth (e) { t = e }, textAlign (e) { return e === "center" ? e : e === "right" ? "left" : "right" }, xPlus (e, s) { return e - s }, leftForLtr (e, s) { return e - s } } }, sm = function () { return { x (n) { return n }, setWidth (n) { }, textAlign (n) { return n }, xPlus (n, t) { return n + t }, leftForLtr (n, t) { return n } } }; function yn (n, t, e) { return n ? nm(t, e) : sm() } function vc (n, t) { let e, s; (t === "ltr" || t === "rtl") && (e = n.canvas.style, s = [e.getPropertyValue("direction"), e.getPropertyPriority("direction")], e.setProperty("direction", t, "important"), n.prevTextDirection = s) } function _c (n, t) { t !== void 0 && (delete n.prevTextDirection, n.canvas.style.setProperty("direction", t[0], t[1])) } function yc (n) { return n === "angle" ? { between: es, compare: ig, normalize: Gt } : { between: xe, compare: (t, e) => t - e, normalize: t => t } } function nr ({ start: n, end: t, count: e, loop: s, style: i }) { return { start: n % e, end: t % e, loop: s && (t - n + 1) % e === 0, style: i } } function im (n, t, e) { const { property: s, start: i, end: o } = e, { between: a, normalize: r } = yc(s), l = t.length; let { start: c, end: d, loop: u } = n, h, f; if (u) { for (c += l, d += l, h = 0, f = l; h < f && a(r(t[c % l][s]), i, o); ++h)c--, d--; c %= l, d %= l } return d < c && (d += l), { start: c, end: d, loop: u, style: n.style } } function xc (n, t, e) { if (!e) return [n]; const { property: s, start: i, end: o } = e, a = t.length, { compare: r, between: l, normalize: c } = yc(s), { start: d, end: u, loop: h, style: f } = im(n, t, e), g = []; let m = !1, v = null, p, b, y; const k = () => l(i, y, p) && r(i, y) !== 0, w = () => r(o, p) === 0 || l(o, y, p), L = () => m || k(), A = () => !m || w(); for (let x = d, S = d; x <= u; ++x)b = t[x % a], !b.skip && (p = c(b[s]), p !== y && (m = l(p, i, o), v === null && L() && (v = r(p, i) === 0 ? x : S), v !== null && A() && (g.push(nr({ start: v, end: x, loop: h, count: a, style: f })), v = null), S = x, y = p)); return v !== null && g.push(nr({ start: v, end: u, loop: h, count: a, style: f })), g } function wc (n, t) { const e = [], s = n.segments; for (let i = 0; i < s.length; i++) { const o = xc(s[i], n.points, t); o.length && e.push(...o) } return e } function om (n, t, e, s) { let i = 0, o = t - 1; if (e && !s) for (; i < t && !n[i].skip;)i++; for (; i < t && n[i].skip;)i++; for (i %= t, e && (o += i); o > i && n[o % t].skip;)o--; return o %= t, { start: i, end: o } } function am (n, t, e, s) { const i = n.length, o = []; let a = t, r = n[t], l; for (l = t + 1; l <= e; ++l) { const c = n[l % i]; c.skip || c.stop ? r.skip || (s = !1, o.push({ start: t % i, end: (l - 1) % i, loop: s }), t = a = c.stop ? l : null) : (a = l, r.skip && (t = l)), r = c } return a !== null && o.push({ start: t % i, end: a % i, loop: s }), o } function rm (n, t) { const e = n.points, s = n.options.spanGaps, i = e.length; if (!i) return []; const o = !!n._loop, { start: a, end: r } = om(e, i, o, s); if (s === !0) return sr(n, [{ start: a, end: r, loop: o }], e, t); const l = r < a ? r + i : r, c = !!n._fullLoop && a === 0 && r === i - 1; return sr(n, am(e, a, l, c), e, t) } function sr (n, t, e, s) { return !s || !s.setContext || !e ? t : lm(n, t, e, s) } function lm (n, t, e, s) { const i = n._chart.getContext(), o = ir(n.options), { _datasetIndex: a, options: { spanGaps: r } } = n, l = e.length, c = []; let d = o, u = t[0].start, h = u; function f (g, m, v, p) { const b = r ? -1 : 1; if (g !== m) { for (g += l; e[g % l].skip;)g -= b; for (; e[m % l].skip;)m += b; g % l !== m % l && (c.push({ start: g % l, end: m % l, loop: v, style: p }), d = p, u = m % l) } } for (const g of t) { u = r ? u : g.start; let m = e[u % l], v; for (h = u + 1; h <= g.end; h++) { const p = e[h % l]; v = ir(s.setContext(We(i, { type: "segment", p0: m, p1: p, p0DataIndex: (h - 1) % l, p1DataIndex: h % l, datasetIndex: a }))), cm(v, d) && f(u, h - 1, g.loop, d), m = p, d = v } u < h - 1 && f(u, h - 1, g.loop, d) } return c } function ir (n) { return { backgroundColor: n.backgroundColor, borderCapStyle: n.borderCapStyle, borderDash: n.borderDash, borderDashOffset: n.borderDashOffset, borderJoinStyle: n.borderJoinStyle, borderWidth: n.borderWidth, borderColor: n.borderColor } } function cm (n, t) { if (!t) return !1; const e = [], s = function (i, o) { return qo(o) ? (e.includes(o) || e.push(o), e.indexOf(o)) : o }; return JSON.stringify(n, s) !== JSON.stringify(t, s) }/*!
 * Chart.js v4.4.3
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */class dm { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify (t, e, s, i) { const o = e.listeners[i], a = e.duration; o.forEach(r => r({ chart: t, initial: e.initial, numSteps: a, currentStep: Math.min(s - e.start, a) })) } _refresh () { this._request || (this._running = !0, this._request = oc.call(window, () => { this._update(), this._request = null, this._running && this._refresh() })) } _update (t = Date.now()) { let e = 0; this._charts.forEach((s, i) => { if (!s.running || !s.items.length) return; const o = s.items; let a = o.length - 1, r = !1, l; for (; a >= 0; --a)l = o[a], l._active ? (l._total > s.duration && (s.duration = l._total), l.tick(t), r = !0) : (o[a] = o[o.length - 1], o.pop()); r && (i.draw(), this._notify(i, s, t, "progress")), o.length || (s.running = !1, this._notify(i, s, t, "complete"), s.initial = !1), e += o.length }), this._lastDate = t, e === 0 && (this._running = !1) } _getAnims (t) { const e = this._charts; let s = e.get(t); return s || (s = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, s)), s } listen (t, e, s) { this._getAnims(t).listeners[e].push(s) } add (t, e) { !e || !e.length || this._getAnims(t).items.push(...e) } has (t) { return this._getAnims(t).items.length > 0 } start (t) { const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((s, i) => Math.max(s, i._duration), 0), this._refresh()) } running (t) { if (!this._running) return !1; const e = this._charts.get(t); return !(!e || !e.running || !e.items.length) } stop (t) { const e = this._charts.get(t); if (!e || !e.items.length) return; const s = e.items; let i = s.length - 1; for (; i >= 0; --i)s[i].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove (t) { return this._charts.delete(t) } } var be = new dm; const or = "transparent", um = { boolean (n, t, e) { return e > .5 ? t : n }, color (n, t, e) { const s = Xa(n || or), i = s.valid && Xa(t || or); return i && i.valid ? i.mix(s, e).hexString() : t }, number (n, t, e) { return n + (t - n) * e } }; class hm { constructor(t, e, s, i) { const o = e[s]; i = In([t.to, i, o, t.from]); const a = In([t.from, o, i]); this._active = !0, this._fn = t.fn || um[t.type || typeof a], this._easing = Yn[t.easing] || Yn.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = s, this._from = a, this._to = i, this._promises = void 0 } active () { return this._active } update (t, e, s) { if (this._active) { this._notify(!1); const i = this._target[this._prop], o = s - this._start, a = this._duration - o; this._start = s, this._duration = Math.floor(Math.max(a, t.duration)), this._total += o, this._loop = !!t.loop, this._to = In([t.to, e, i, t.from]), this._from = In([t.from, i, e]) } } cancel () { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick (t) { const e = t - this._start, s = this._duration, i = this._prop, o = this._from, a = this._loop, r = this._to; let l; if (this._active = o !== r && (a || e < s), !this._active) { this._target[i] = r, this._notify(!0); return } if (e < 0) { this._target[i] = o; return } l = e / s % 2, l = a && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[i] = this._fn(o, r, l) } wait () { const t = this._promises || (this._promises = []); return new Promise((e, s) => { t.push({ res: e, rej: s }) }) } _notify (t) { const e = t ? "res" : "rej", s = this._promises || []; for (let i = 0; i < s.length; i++)s[i][e]() } } class kc { constructor(t, e) { this._chart = t, this._properties = new Map, this.configure(e) } configure (t) { if (!ot(t)) return; const e = Object.keys(Pt.animation), s = this._properties; Object.getOwnPropertyNames(t).forEach(i => { const o = t[i]; if (!ot(o)) return; const a = {}; for (const r of e) a[r] = o[r]; (yt(o.properties) && o.properties || [i]).forEach(r => { (r === i || !s.has(r)) && s.set(r, a) }) }) } _animateOptions (t, e) { const s = e.options, i = pm(t, s); if (!i) return []; const o = this._createAnimations(i, s); return s.$shared && fm(t.options.$animations, s).then(() => { t.options = s }, () => { }), o } _createAnimations (t, e) { const s = this._properties, i = [], o = t.$animations || (t.$animations = {}), a = Object.keys(e), r = Date.now(); let l; for (l = a.length - 1; l >= 0; --l) { const c = a[l]; if (c.charAt(0) === "$") continue; if (c === "options") { i.push(...this._animateOptions(t, e)); continue } const d = e[c]; let u = o[c]; const h = s.get(c); if (u) if (h && u.active()) { u.update(h, d, r); continue } else u.cancel(); if (!h || !h.duration) { t[c] = d; continue } o[c] = u = new hm(h, t, c, d), i.push(u) } return i } update (t, e) { if (this._properties.size === 0) { Object.assign(t, e); return } const s = this._createAnimations(t, e); if (s.length) return be.add(this._chart, s), !0 } } function fm (n, t) { const e = [], s = Object.keys(t); for (let i = 0; i < s.length; i++) { const o = n[s[i]]; o && o.active() && e.push(o.wait()) } return Promise.all(e) } function pm (n, t) { if (!t) return; let e = n.options; if (!e) { n.options = t; return } return e.$shared && (n.options = e = Object.assign({}, e, { $shared: !1, $animations: {} })), e } function ar (n, t) { const e = n && n.options || {}, s = e.reverse, i = e.min === void 0 ? t : 0, o = e.max === void 0 ? t : 0; return { start: s ? o : i, end: s ? i : o } } function gm (n, t, e) { if (e === !1) return !1; const s = ar(n, e), i = ar(t, e); return { top: i.end, right: s.end, bottom: i.start, left: s.start } } function mm (n) { let t, e, s, i; return ot(n) ? (t = n.top, e = n.right, s = n.bottom, i = n.left) : t = e = s = i = n, { top: t, right: e, bottom: s, left: i, disabled: n === !1 } } function Sc (n, t) { const e = [], s = n._getSortedDatasetMetas(t); let i, o; for (i = 0, o = s.length; i < o; ++i)e.push(s[i].index); return e } function rr (n, t, e, s = {}) { const i = n.keys, o = s.mode === "single"; let a, r, l, c; if (t !== null) { for (a = 0, r = i.length; a < r; ++a) { if (l = +i[a], l === e) { if (s.all) continue; break } c = n.values[l], Mt(c) && (o || t === 0 || fe(t) === fe(c)) && (t += c) } return t } } function bm (n, t) { const { iScale: e, vScale: s } = t, i = e.axis === "x" ? "x" : "y", o = s.axis === "x" ? "x" : "y", a = Object.keys(n), r = new Array(a.length); let l, c, d; for (l = 0, c = a.length; l < c; ++l)d = a[l], r[l] = { [i]: d, [o]: n[d] }; return r } function lr (n, t) { const e = n && n.options.stacked; return e || e === void 0 && t.stack !== void 0 } function vm (n, t, e) { return `${n.id}.${t.id}.${e.stack || e.type}` } function _m (n) { const { min: t, max: e, minDefined: s, maxDefined: i } = n.getUserBounds(); return { min: s ? t : Number.NEGATIVE_INFINITY, max: i ? e : Number.POSITIVE_INFINITY } } function ym (n, t, e) { const s = n[t] || (n[t] = {}); return s[e] || (s[e] = {}) } function cr (n, t, e, s) { for (const i of t.getMatchingVisibleMetas(s).reverse()) { const o = n[i.index]; if (e && o > 0 || !e && o < 0) return i.index } return null } function dr (n, t) { const { chart: e, _cachedMeta: s } = n, i = e._stacks || (e._stacks = {}), { iScale: o, vScale: a, index: r } = s, l = o.axis, c = a.axis, d = vm(o, a, s), u = t.length; let h; for (let f = 0; f < u; ++f) { const g = t[f], { [l]: m, [c]: v } = g, p = g._stacks || (g._stacks = {}); h = p[c] = ym(i, d, m), h[r] = v, h._top = cr(h, a, !0, s.type), h._bottom = cr(h, a, !1, s.type); const b = h._visualValues || (h._visualValues = {}); b[r] = v } } function ji (n, t) { const e = n.scales; return Object.keys(e).filter(s => e[s].axis === t).shift() } function xm (n, t) { return We(n, { active: !1, dataset: void 0, datasetIndex: t, index: t, mode: "default", type: "dataset" }) } function wm (n, t, e) { return We(n, { active: !1, dataIndex: t, parsed: void 0, raw: void 0, element: e, index: t, mode: "default", type: "data" }) } function Tn (n, t) { const e = n.controller.index, s = n.vScale && n.vScale.axis; if (s) { t = t || n._parsed; for (const i of t) { const o = i._stacks; if (!o || o[s] === void 0 || o[s][e] === void 0) return; delete o[s][e], o[s]._visualValues !== void 0 && o[s]._visualValues[e] !== void 0 && delete o[s]._visualValues[e] } } } const Hi = n => n === "reset" || n === "none", ur = (n, t) => t ? n : Object.assign({}, n), km = (n, t, e) => n && !t.hidden && t._stacked && { keys: Sc(e, !0), values: null }; class le { constructor(t, e) { this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize() } initialize () { const t = this._cachedMeta; this.configure(), this.linkScales(), t._stacked = lr(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options") } updateIndex (t) { this.index !== t && Tn(this._cachedMeta), this.index = t } linkScales () { const t = this.chart, e = this._cachedMeta, s = this.getDataset(), i = (u, h, f, g) => u === "x" ? h : u === "r" ? g : f, o = e.xAxisID = tt(s.xAxisID, ji(t, "x")), a = e.yAxisID = tt(s.yAxisID, ji(t, "y")), r = e.rAxisID = tt(s.rAxisID, ji(t, "r")), l = e.indexAxis, c = e.iAxisID = i(l, o, a, r), d = e.vAxisID = i(l, a, o, r); e.xScale = this.getScaleForId(o), e.yScale = this.getScaleForId(a), e.rScale = this.getScaleForId(r), e.iScale = this.getScaleForId(c), e.vScale = this.getScaleForId(d) } getDataset () { return this.chart.data.datasets[this.index] } getMeta () { return this.chart.getDatasetMeta(this.index) } getScaleForId (t) { return this.chart.scales[t] } _getOtherScale (t) { const e = this._cachedMeta; return t === e.iScale ? e.vScale : e.iScale } reset () { this._update("reset") } _destroy () { const t = this._cachedMeta; this._data && Ya(this._data, this), t._stacked && Tn(t) } _dataCheck () { const t = this.getDataset(), e = t.data || (t.data = []), s = this._data; if (ot(e)) { const i = this._cachedMeta; this._data = bm(e, i) } else if (s !== e) { if (s) { Ya(s, this); const i = this._cachedMeta; Tn(i), i._parsed = [] } e && Object.isExtensible(e) && lg(e, this), this._syncList = [], this._data = e } } addElements () { const t = this._cachedMeta; this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType) } buildOrUpdateElements (t) { const e = this._cachedMeta, s = this.getDataset(); let i = !1; this._dataCheck(); const o = e._stacked; e._stacked = lr(e.vScale, e), e.stack !== s.stack && (i = !0, Tn(e), e.stack = s.stack), this._resyncElements(t), (i || o !== e._stacked) && dr(this, e._parsed) } configure () { const t = this.chart.config, e = t.datasetScopeKeys(this._type), s = t.getOptionScopes(this.getDataset(), e, !0); this.options = t.createResolver(s, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse (t, e) { const { _cachedMeta: s, _data: i } = this, { iScale: o, _stacked: a } = s, r = o.axis; let l = t === 0 && e === i.length ? !0 : s._sorted, c = t > 0 && s._parsed[t - 1], d, u, h; if (this._parsing === !1) s._parsed = i, s._sorted = !0, h = i; else { yt(i[t]) ? h = this.parseArrayData(s, i, t, e) : ot(i[t]) ? h = this.parseObjectData(s, i, t, e) : h = this.parsePrimitiveData(s, i, t, e); const f = () => u[r] === null || c && u[r] < c[r]; for (d = 0; d < e; ++d)s._parsed[d + t] = u = h[d], l && (f() && (l = !1), c = u); s._sorted = l } a && dr(this, h) } parsePrimitiveData (t, e, s, i) { const { iScale: o, vScale: a } = t, r = o.axis, l = a.axis, c = o.getLabels(), d = o === a, u = new Array(i); let h, f, g; for (h = 0, f = i; h < f; ++h)g = h + s, u[h] = { [r]: d || o.parse(c[g], g), [l]: a.parse(e[g], g) }; return u } parseArrayData (t, e, s, i) { const { xScale: o, yScale: a } = t, r = new Array(i); let l, c, d, u; for (l = 0, c = i; l < c; ++l)d = l + s, u = e[d], r[l] = { x: o.parse(u[0], d), y: a.parse(u[1], d) }; return r } parseObjectData (t, e, s, i) { const { xScale: o, yScale: a } = t, { xAxisKey: r = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(i); let d, u, h, f; for (d = 0, u = i; d < u; ++d)h = d + s, f = e[h], c[d] = { x: o.parse(je(f, r), h), y: a.parse(je(f, l), h) }; return c } getParsed (t) { return this._cachedMeta._parsed[t] } getDataElement (t) { return this._cachedMeta.data[t] } applyStack (t, e, s) { const i = this.chart, o = this._cachedMeta, a = e[t.axis], r = { keys: Sc(i, !0), values: e._stacks[t.axis]._visualValues }; return rr(r, a, o.index, { mode: s }) } updateRangeFromParsed (t, e, s, i) { const o = s[e.axis]; let a = o === null ? NaN : o; const r = i && s._stacks[e.axis]; i && r && (i.values = r, a = rr(i, o, this._cachedMeta.index)), t.min = Math.min(t.min, a), t.max = Math.max(t.max, a) } getMinMax (t, e) { const s = this._cachedMeta, i = s._parsed, o = s._sorted && t === s.iScale, a = i.length, r = this._getOtherScale(t), l = km(e, s, this.chart), c = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: d, max: u } = _m(r); let h, f; function g () { f = i[h]; const m = f[r.axis]; return !Mt(f[t.axis]) || d > m || u < m } for (h = 0; h < a && !(!g() && (this.updateRangeFromParsed(c, t, f, l), o)); ++h); if (o) { for (h = a - 1; h >= 0; --h)if (!g()) { this.updateRangeFromParsed(c, t, f, l); break } } return c } getAllParsedValues (t) { const e = this._cachedMeta._parsed, s = []; let i, o, a; for (i = 0, o = e.length; i < o; ++i)a = e[i][t.axis], Mt(a) && s.push(a); return s } getMaxOverflow () { return !1 } getLabelAndValue (t) { const e = this._cachedMeta, s = e.iScale, i = e.vScale, o = this.getParsed(t); return { label: s ? "" + s.getLabelForValue(o[s.axis]) : "", value: i ? "" + i.getLabelForValue(o[i.axis]) : "" } } _update (t) { const e = this._cachedMeta; this.update(t || "default"), e._clip = mm(tt(this.options.clip, gm(e.xScale, e.yScale, this.getMaxOverflow()))) } update (t) { } draw () { const t = this._ctx, e = this.chart, s = this._cachedMeta, i = s.data || [], o = e.chartArea, a = [], r = this._drawStart || 0, l = this._drawCount || i.length - r, c = this.options.drawActiveElementsOnTop; let d; for (s.dataset && s.dataset.draw(t, o, r, l), d = r; d < r + l; ++d) { const u = i[d]; u.hidden || (u.active && c ? a.push(u) : u.draw(t, o)) } for (d = 0; d < a.length; ++d)a[d].draw(t, o) } getStyle (t, e) { const s = e ? "active" : "default"; return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(t || 0, s) } getContext (t, e, s) { const i = this.getDataset(); let o; if (t >= 0 && t < this._cachedMeta.data.length) { const a = this._cachedMeta.data[t]; o = a.$context || (a.$context = wm(this.getContext(), t, a)), o.parsed = this.getParsed(t), o.raw = i.data[t], o.index = o.dataIndex = t } else o = this.$context || (this.$context = xm(this.chart.getContext(), this.index)), o.dataset = i, o.index = o.datasetIndex = this.index; return o.active = !!e, o.mode = s, o } resolveDatasetElementOptions (t) { return this._resolveElementOptions(this.datasetElementType.id, t) } resolveDataElementOptions (t, e) { return this._resolveElementOptions(this.dataElementType.id, e, t) } _resolveElementOptions (t, e = "default", s) { const i = e === "active", o = this._cachedDataOpts, a = t + "-" + e, r = o[a], l = this.enableOptionSharing && ts(s); if (r) return ur(r, l); const c = this.chart.config, d = c.datasetElementScopeKeys(this._type, t), u = i ? [`${t}Hover`, "hover", t, ""] : [t, ""], h = c.getOptionScopes(this.getDataset(), d), f = Object.keys(Pt.elements[t]), g = () => this.getContext(s, i, e), m = c.resolveNamedOptions(h, f, g, u); return m.$shared && (m.$shared = l, o[a] = Object.freeze(ur(m, l))), m } _resolveAnimations (t, e, s) { const i = this.chart, o = this._cachedDataOpts, a = `animation-${e}`, r = o[a]; if (r) return r; let l; if (i.options.animation !== !1) { const d = this.chart.config, u = d.datasetAnimationScopeKeys(this._type, e), h = d.getOptionScopes(this.getDataset(), u); l = d.createResolver(h, this.getContext(t, s, e)) } const c = new kc(i, l && l.animations); return l && l._cacheable && (o[a] = Object.freeze(c)), c } getSharedOptions (t) { if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t)) } includeOptions (t, e) { return !e || Hi(t) || this.chart._animationsDisabled } _getSharedOptions (t, e) { const s = this.resolveDataElementOptions(t, e), i = this._sharedOptions, o = this.getSharedOptions(s), a = this.includeOptions(e, o) || o !== i; return this.updateSharedOptions(o, e, s), { sharedOptions: o, includeOptions: a } } updateElement (t, e, s, i) { Hi(i) ? Object.assign(t, s) : this._resolveAnimations(e, i).update(t, s) } updateSharedOptions (t, e, s) { t && !Hi(e) && this._resolveAnimations(void 0, e).update(t, s) } _setStyle (t, e, s, i) { t.active = i; const o = this.getStyle(e, i); this._resolveAnimations(e, s, i).update(t, { options: !i && this.getSharedOptions(o) || o }) } removeHoverStyle (t, e, s) { this._setStyle(t, s, "active", !1) } setHoverStyle (t, e, s) { this._setStyle(t, s, "active", !0) } _removeDatasetHoverStyle () { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, "active", !1) } _setDatasetHoverStyle () { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, "active", !0) } _resyncElements (t) { const e = this._data, s = this._cachedMeta.data; for (const [r, l, c] of this._syncList) this[r](l, c); this._syncList = []; const i = s.length, o = e.length, a = Math.min(o, i); a && this.parse(0, a), o > i ? this._insertElements(i, o - i, t) : o < i && this._removeElements(o, i - o) } _insertElements (t, e, s = !0) { const i = this._cachedMeta, o = i.data, a = t + e; let r; const l = c => { for (c.length += e, r = c.length - 1; r >= a; r--)c[r] = c[r - e] }; for (l(o), r = t; r < a; ++r)o[r] = new this.dataElementType; this._parsing && l(i._parsed), this.parse(t, e), s && this.updateElements(o, t, e, "reset") } updateElements (t, e, s, i) { } _removeElements (t, e) { const s = this._cachedMeta; if (this._parsing) { const i = s._parsed.splice(t, e); s._stacked && Tn(s, i) } s.data.splice(t, e) } _sync (t) { if (this._parsing) this._syncList.push(t); else { const [e, s, i] = t; this[e](s, i) } this.chart._dataChanges.push([this.index, ...t]) } _onDataPush () { const t = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - t, t]) } _onDataPop () { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift () { this._sync(["_removeElements", 0, 1]) } _onDataSplice (t, e) { e && this._sync(["_removeElements", t, e]); const s = arguments.length - 2; s && this._sync(["_insertElements", t, s]) } _onDataUnshift () { this._sync(["_insertElements", 0, arguments.length]) } } V(le, "defaults", {}), V(le, "datasetElementType", null), V(le, "dataElementType", null); function Sm (n, t) { if (!n._cache.$bar) { const e = n.getMatchingVisibleMetas(t); let s = []; for (let i = 0, o = e.length; i < o; i++)s = s.concat(e[i].controller.getAllParsedValues(n)); n._cache.$bar = ic(s.sort((i, o) => i - o)) } return n._cache.$bar } function Mm (n) { const t = n.iScale, e = Sm(t, n.type); let s = t._length, i, o, a, r; const l = () => { a === 32767 || a === -32768 || (ts(r) && (s = Math.min(s, Math.abs(a - r) || s)), r = a) }; for (i = 0, o = e.length; i < o; ++i)a = t.getPixelForValue(e[i]), l(); for (r = void 0, i = 0, o = t.ticks.length; i < o; ++i)a = t.getPixelForTick(i), l(); return s } function Pm (n, t, e, s) { const i = e.barThickness; let o, a; return at(i) ? (o = t.min * e.categoryPercentage, a = e.barPercentage) : (o = i * s, a = 1), { chunk: o / s, ratio: a, start: t.pixels[n] - o / 2 } } function Cm (n, t, e, s) { const i = t.pixels, o = i[n]; let a = n > 0 ? i[n - 1] : null, r = n < i.length - 1 ? i[n + 1] : null; const l = e.categoryPercentage; a === null && (a = o - (r === null ? t.end - t.start : r - o)), r === null && (r = o + o - a); const c = o - (o - Math.min(a, r)) / 2 * l; return { chunk: Math.abs(r - a) / 2 * l / s, ratio: e.barPercentage, start: c } } function Tm (n, t, e, s) { const i = e.parse(n[0], s), o = e.parse(n[1], s), a = Math.min(i, o), r = Math.max(i, o); let l = a, c = r; Math.abs(a) > Math.abs(r) && (l = r, c = a), t[e.axis] = c, t._custom = { barStart: l, barEnd: c, start: i, end: o, min: a, max: r } } function Mc (n, t, e, s) { return yt(n) ? Tm(n, t, e, s) : t[e.axis] = e.parse(n, s), t } function hr (n, t, e, s) { const i = n.iScale, o = n.vScale, a = i.getLabels(), r = i === o, l = []; let c, d, u, h; for (c = e, d = e + s; c < d; ++c)h = t[c], u = {}, u[i.axis] = r || i.parse(a[c], c), l.push(Mc(h, u, o, c)); return l } function Wi (n) { return n && n.barStart !== void 0 && n.barEnd !== void 0 } function Om (n, t, e) { return n !== 0 ? fe(n) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1) } function Lm (n) { let t, e, s, i, o; return n.horizontal ? (t = n.base > n.x, e = "left", s = "right") : (t = n.base < n.y, e = "bottom", s = "top"), t ? (i = "end", o = "start") : (i = "start", o = "end"), { start: e, end: s, reverse: t, top: i, bottom: o } } function Am (n, t, e, s) { let i = t.borderSkipped; const o = {}; if (!i) { n.borderSkipped = o; return } if (i === !0) { n.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }; return } const { start: a, end: r, reverse: l, top: c, bottom: d } = Lm(n); i === "middle" && e && (n.enableBorderRadius = !0, (e._top || 0) === s ? i = c : (e._bottom || 0) === s ? i = d : (o[fr(d, a, r, l)] = !0, i = c)), o[fr(i, a, r, l)] = !0, n.borderSkipped = o } function fr (n, t, e, s) { return s ? (n = $m(n, t, e), n = pr(n, e, t)) : n = pr(n, t, e), n } function $m (n, t, e) { return n === t ? e : n === e ? t : n } function pr (n, t, e) { return n === "start" ? t : n === "end" ? e : n } function Dm (n, { inflateAmount: t }, e) { n.inflateAmount = t === "auto" ? e === 1 ? .33 : 0 : t } class Es extends le { parsePrimitiveData (t, e, s, i) { return hr(t, e, s, i) } parseArrayData (t, e, s, i) { return hr(t, e, s, i) } parseObjectData (t, e, s, i) { const { iScale: o, vScale: a } = t, { xAxisKey: r = "x", yAxisKey: l = "y" } = this._parsing, c = o.axis === "x" ? r : l, d = a.axis === "x" ? r : l, u = []; let h, f, g, m; for (h = s, f = s + i; h < f; ++h)m = e[h], g = {}, g[o.axis] = o.parse(je(m, c), h), u.push(Mc(je(m, d), g, a, h)); return u } updateRangeFromParsed (t, e, s, i) { super.updateRangeFromParsed(t, e, s, i); const o = s._custom; o && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max)) } getMaxOverflow () { return 0 } getLabelAndValue (t) { const e = this._cachedMeta, { iScale: s, vScale: i } = e, o = this.getParsed(t), a = o._custom, r = Wi(a) ? "[" + a.start + ", " + a.end + "]" : "" + i.getLabelForValue(o[i.axis]); return { label: "" + s.getLabelForValue(o[s.axis]), value: r } } initialize () { this.enableOptionSharing = !0, super.initialize(); const t = this._cachedMeta; t.stack = this.getDataset().stack } update (t) { const e = this._cachedMeta; this.updateElements(e.data, 0, e.data.length, t) } updateElements (t, e, s, i) { const o = i === "reset", { index: a, _cachedMeta: { vScale: r } } = this, l = r.getBasePixel(), c = r.isHorizontal(), d = this._getRuler(), { sharedOptions: u, includeOptions: h } = this._getSharedOptions(e, i); for (let f = e; f < e + s; f++) { const g = this.getParsed(f), m = o || at(g[r.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(f), v = this._calculateBarIndexPixels(f, d), p = (g._stacks || {})[r.axis], b = { horizontal: c, base: m.base, enableBorderRadius: !p || Wi(g._custom) || a === p._top || a === p._bottom, x: c ? m.head : v.center, y: c ? v.center : m.head, height: c ? v.size : Math.abs(m.size), width: c ? Math.abs(m.size) : v.size }; h && (b.options = u || this.resolveDataElementOptions(f, t[f].active ? "active" : i)); const y = b.options || t[f].options; Am(b, y, p, a), Dm(b, y, d.ratio), this.updateElement(t[f], f, b, i) } } _getStacks (t, e) { const { iScale: s } = this._cachedMeta, i = s.getMatchingVisibleMetas(this._type).filter(l => l.controller.options.grouped), o = s.options.stacked, a = [], r = l => { const c = l.controller.getParsed(e), d = c && c[l.vScale.axis]; if (at(d) || isNaN(d)) return !0 }; for (const l of i) if (!(e !== void 0 && r(l)) && ((o === !1 || a.indexOf(l.stack) === -1 || o === void 0 && l.stack === void 0) && a.push(l.stack), l.index === t)) break; return a.length || a.push(void 0), a } _getStackCount (t) { return this._getStacks(void 0, t).length } _getStackIndex (t, e, s) { const i = this._getStacks(t, s), o = e !== void 0 ? i.indexOf(e) : -1; return o === -1 ? i.length - 1 : o } _getRuler () { const t = this.options, e = this._cachedMeta, s = e.iScale, i = []; let o, a; for (o = 0, a = e.data.length; o < a; ++o)i.push(s.getPixelForValue(this.getParsed(o)[s.axis], o)); const r = t.barThickness; return { min: r || Mm(e), pixels: i, start: s._startPixel, end: s._endPixel, stackCount: this._getStackCount(), scale: s, grouped: t.grouped, ratio: r ? 1 : t.categoryPercentage * t.barPercentage } } _calculateBarValuePixels (t) { const { _cachedMeta: { vScale: e, _stacked: s, index: i }, options: { base: o, minBarLength: a } } = this, r = o || 0, l = this.getParsed(t), c = l._custom, d = Wi(c); let u = l[e.axis], h = 0, f = s ? this.applyStack(e, l, s) : u, g, m; f !== u && (h = f - u, f = u), d && (u = c.barStart, f = c.barEnd - c.barStart, u !== 0 && fe(u) !== fe(c.barEnd) && (h = 0), h += u); const v = !at(o) && !d ? o : h; let p = e.getPixelForValue(v); if (this.chart.getDataVisibility(t) ? g = e.getPixelForValue(h + f) : g = p, m = g - p, Math.abs(m) < a) { m = Om(m, e, r) * a, u === r && (p -= m / 2); const b = e.getPixelForDecimal(0), y = e.getPixelForDecimal(1), k = Math.min(b, y), w = Math.max(b, y); p = Math.max(Math.min(p, w), k), g = p + m, s && !d && (l._stacks[e.axis]._visualValues[i] = e.getValueForPixel(g) - e.getValueForPixel(p)) } if (p === e.getPixelForValue(r)) { const b = fe(m) * e.getLineWidthForValue(r) / 2; p += b, m -= b } return { size: m, base: p, head: g, center: g + m / 2 } } _calculateBarIndexPixels (t, e) { const s = e.scale, i = this.options, o = i.skipNull, a = tt(i.maxBarThickness, 1 / 0); let r, l; if (e.grouped) { const c = o ? this._getStackCount(t) : e.stackCount, d = i.barThickness === "flex" ? Cm(t, e, i, c) : Pm(t, e, i, c), u = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0); r = d.start + d.chunk * u + d.chunk / 2, l = Math.min(a, d.chunk * d.ratio) } else r = s.getPixelForValue(this.getParsed(t)[s.axis], t), l = Math.min(a, e.min * e.ratio); return { base: r - l / 2, head: r + l / 2, center: r, size: l } } draw () { const t = this._cachedMeta, e = t.vScale, s = t.data, i = s.length; let o = 0; for (; o < i; ++o)this.getParsed(o)[e.axis] !== null && !s[o].hidden && s[o].draw(this._ctx) } } V(Es, "id", "bar"), V(Es, "defaults", { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }), V(Es, "overrides", { scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }); class Rs extends le { initialize () { this.enableOptionSharing = !0, super.initialize() } parsePrimitiveData (t, e, s, i) { const o = super.parsePrimitiveData(t, e, s, i); for (let a = 0; a < o.length; a++)o[a]._custom = this.resolveDataElementOptions(a + s).radius; return o } parseArrayData (t, e, s, i) { const o = super.parseArrayData(t, e, s, i); for (let a = 0; a < o.length; a++) { const r = e[s + a]; o[a]._custom = tt(r[2], this.resolveDataElementOptions(a + s).radius) } return o } parseObjectData (t, e, s, i) { const o = super.parseObjectData(t, e, s, i); for (let a = 0; a < o.length; a++) { const r = e[s + a]; o[a]._custom = tt(r && r.r && +r.r, this.resolveDataElementOptions(a + s).radius) } return o } getMaxOverflow () { const t = this._cachedMeta.data; let e = 0; for (let s = t.length - 1; s >= 0; --s)e = Math.max(e, t[s].size(this.resolveDataElementOptions(s)) / 2); return e > 0 && e } getLabelAndValue (t) { const e = this._cachedMeta, s = this.chart.data.labels || [], { xScale: i, yScale: o } = e, a = this.getParsed(t), r = i.getLabelForValue(a.x), l = o.getLabelForValue(a.y), c = a._custom; return { label: s[t] || "", value: "(" + r + ", " + l + (c ? ", " + c : "") + ")" } } update (t) { const e = this._cachedMeta.data; this.updateElements(e, 0, e.length, t) } updateElements (t, e, s, i) { const o = i === "reset", { iScale: a, vScale: r } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(e, i), d = a.axis, u = r.axis; for (let h = e; h < e + s; h++) { const f = t[h], g = !o && this.getParsed(h), m = {}, v = m[d] = o ? a.getPixelForDecimal(.5) : a.getPixelForValue(g[d]), p = m[u] = o ? r.getBasePixel() : r.getPixelForValue(g[u]); m.skip = isNaN(v) || isNaN(p), c && (m.options = l || this.resolveDataElementOptions(h, f.active ? "active" : i), o && (m.options.radius = 0)), this.updateElement(f, h, m, i) } } resolveDataElementOptions (t, e) { const s = this.getParsed(t); let i = super.resolveDataElementOptions(t, e); i.$shared && (i = Object.assign({}, i, { $shared: !1 })); const o = i.radius; return e !== "active" && (i.radius = 0), i.radius += tt(s && s._custom, o), i } } V(Rs, "id", "bubble"), V(Rs, "defaults", { datasetElementType: !1, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } }), V(Rs, "overrides", { scales: { x: { type: "linear" }, y: { type: "linear" } } }); function Em (n, t, e) { let s = 1, i = 1, o = 0, a = 0; if (t < gt) { const r = n, l = r + t, c = Math.cos(r), d = Math.sin(r), u = Math.cos(l), h = Math.sin(l), f = (y, k, w) => es(y, r, l, !0) ? 1 : Math.max(k, k * e, w, w * e), g = (y, k, w) => es(y, r, l, !0) ? -1 : Math.min(k, k * e, w, w * e), m = f(0, c, u), v = f(Ct, d, h), p = g(mt, c, u), b = g(mt + Ct, d, h); s = (m - p) / 2, i = (v - b) / 2, o = -(m + p) / 2, a = -(v + b) / 2 } return { ratioX: s, ratioY: i, offsetX: o, offsetY: a } } class tn extends le { constructor(t, e) { super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0 } linkScales () { } parse (t, e) { const s = this.getDataset().data, i = this._cachedMeta; if (this._parsing === !1) i._parsed = s; else { let o = l => +s[l]; if (ot(s[t])) { const { key: l = "value" } = this._parsing; o = c => +je(s[c], l) } let a, r; for (a = t, r = t + e; a < r; ++a)i._parsed[a] = o(a) } } _getRotation () { return oe(this.options.rotation - 90) } _getCircumference () { return oe(this.options.circumference) } _getRotationExtents () { let t = gt, e = -gt; for (let s = 0; s < this.chart.data.datasets.length; ++s)if (this.chart.isDatasetVisible(s) && this.chart.getDatasetMeta(s).type === this._type) { const i = this.chart.getDatasetMeta(s).controller, o = i._getRotation(), a = i._getCircumference(); t = Math.min(t, o), e = Math.max(e, o + a) } return { rotation: t, circumference: e - t } } update (t) { const e = this.chart, { chartArea: s } = e, i = this._cachedMeta, o = i.data, a = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing, r = Math.max((Math.min(s.width, s.height) - a) / 2, 0), l = Math.min(qp(this.options.cutout, r), 1), c = this._getRingWeight(this.index), { circumference: d, rotation: u } = this._getRotationExtents(), { ratioX: h, ratioY: f, offsetX: g, offsetY: m } = Em(u, d, l), v = (s.width - a) / h, p = (s.height - a) / f, b = Math.max(Math.min(v, p) / 2, 0), y = Zl(this.options.radius, b), k = Math.max(y * l, 0), w = (y - k) / this._getVisibleDatasetWeightTotal(); this.offsetX = g * y, this.offsetY = m * y, i.total = this.calculateTotal(), this.outerRadius = y - w * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - w * c, 0), this.updateElements(o, 0, o.length, t) } _circumference (t, e) { const s = this.options, i = this._cachedMeta, o = this._getCircumference(); return e && s.animation.animateRotate || !this.chart.getDataVisibility(t) || i._parsed[t] === null || i.data[t].hidden ? 0 : this.calculateCircumference(i._parsed[t] * o / gt) } updateElements (t, e, s, i) { const o = i === "reset", a = this.chart, r = a.chartArea, c = a.options.animation, d = (r.left + r.right) / 2, u = (r.top + r.bottom) / 2, h = o && c.animateScale, f = h ? 0 : this.innerRadius, g = h ? 0 : this.outerRadius, { sharedOptions: m, includeOptions: v } = this._getSharedOptions(e, i); let p = this._getRotation(), b; for (b = 0; b < e; ++b)p += this._circumference(b, o); for (b = e; b < e + s; ++b) { const y = this._circumference(b, o), k = t[b], w = { x: d + this.offsetX, y: u + this.offsetY, startAngle: p, endAngle: p + y, circumference: y, outerRadius: g, innerRadius: f }; v && (w.options = m || this.resolveDataElementOptions(b, k.active ? "active" : i)), p += y, this.updateElement(k, b, w, i) } } calculateTotal () { const t = this._cachedMeta, e = t.data; let s = 0, i; for (i = 0; i < e.length; i++) { const o = t._parsed[i]; o !== null && !isNaN(o) && this.chart.getDataVisibility(i) && !e[i].hidden && (s += Math.abs(o)) } return s } calculateCircumference (t) { const e = this._cachedMeta.total; return e > 0 && !isNaN(t) ? gt * (Math.abs(t) / e) : 0 } getLabelAndValue (t) { const e = this._cachedMeta, s = this.chart, i = s.data.labels || [], o = us(e._parsed[t], s.options.locale); return { label: i[t] || "", value: o } } getMaxBorderWidth (t) { let e = 0; const s = this.chart; let i, o, a, r, l; if (!t) { for (i = 0, o = s.data.datasets.length; i < o; ++i)if (s.isDatasetVisible(i)) { a = s.getDatasetMeta(i), t = a.data, r = a.controller; break } } if (!t) return 0; for (i = 0, o = t.length; i < o; ++i)l = r.resolveDataElementOptions(i), l.borderAlign !== "inner" && (e = Math.max(e, l.borderWidth || 0, l.hoverBorderWidth || 0)); return e } getMaxOffset (t) { let e = 0; for (let s = 0, i = t.length; s < i; ++s) { const o = this.resolveDataElementOptions(s); e = Math.max(e, o.offset || 0, o.hoverOffset || 0) } return e } _getRingWeightOffset (t) { let e = 0; for (let s = 0; s < t; ++s)this.chart.isDatasetVisible(s) && (e += this._getRingWeight(s)); return e } _getRingWeight (t) { return Math.max(tt(this.chart.data.datasets[t].weight, 1), 0) } _getVisibleDatasetWeightTotal () { return this._getRingWeightOffset(this.chart.data.datasets.length) || 1 } } V(tn, "id", "doughnut"), V(tn, "defaults", { datasetElementType: !1, dataElementType: "arc", animation: { animateRotate: !0, animateScale: !1 }, animations: { numbers: { type: "number", properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"] } }, cutout: "50%", rotation: 0, circumference: 360, radius: "100%", spacing: 0, indexAxis: "r" }), V(tn, "descriptors", { _scriptable: t => t !== "spacing", _indexable: t => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash") }), V(tn, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels (t) { const e = t.data; if (e.labels.length && e.datasets.length) { const { labels: { pointStyle: s, color: i } } = t.legend.options; return e.labels.map((o, a) => { const l = t.getDatasetMeta(0).controller.getStyle(a); return { text: o, fillStyle: l.backgroundColor, strokeStyle: l.borderColor, fontColor: i, lineWidth: l.borderWidth, pointStyle: s, hidden: !t.getDataVisibility(a), index: a } }) } return [] } }, onClick (t, e, s) { s.chart.toggleDataVisibility(e.index), s.chart.update() } } } }); class Is extends le { initialize () { this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize() } update (t) { const e = this._cachedMeta, { dataset: s, data: i = [], _dataset: o } = e, a = this.chart._animationsDisabled; let { start: r, count: l } = rc(e, i, a); this._drawStart = r, this._drawCount = l, lc(e) && (r = 0, l = i.length), s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!o._decimated, s.points = i; const c = this.resolveDatasetElementOptions(t); this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(s, void 0, { animated: !a, options: c }, t), this.updateElements(i, r, l, t) } updateElements (t, e, s, i) { const o = i === "reset", { iScale: a, vScale: r, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, i), h = a.axis, f = r.axis, { spanGaps: g, segment: m } = this.options, v = kn(g) ? g : Number.POSITIVE_INFINITY, p = this.chart._animationsDisabled || o || i === "none", b = e + s, y = t.length; let k = e > 0 && this.getParsed(e - 1); for (let w = 0; w < y; ++w) { const L = t[w], A = p ? L : {}; if (w < e || w >= b) { A.skip = !0; continue } const x = this.getParsed(w), S = at(x[f]), C = A[h] = a.getPixelForValue(x[h], w), T = A[f] = o || S ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, x, l) : x[f], w); A.skip = isNaN(C) || isNaN(T) || S, A.stop = w > 0 && Math.abs(x[h] - k[h]) > v, m && (A.parsed = x, A.raw = c.data[w]), u && (A.options = d || this.resolveDataElementOptions(w, L.active ? "active" : i)), p || this.updateElement(L, w, A, i), k = x } } getMaxOverflow () { const t = this._cachedMeta, e = t.dataset, s = e.options && e.options.borderWidth || 0, i = t.data || []; if (!i.length) return s; const o = i[0].size(this.resolveDataElementOptions(0)), a = i[i.length - 1].size(this.resolveDataElementOptions(i.length - 1)); return Math.max(s, o, a) / 2 } draw () { const t = this._cachedMeta; t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw() } } V(Is, "id", "line"), V(Is, "defaults", { datasetElementType: "line", dataElementType: "point", showLine: !0, spanGaps: !1 }), V(Is, "overrides", { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } }); class qn extends le { constructor(t, e) { super(t, e), this.innerRadius = void 0, this.outerRadius = void 0 } getLabelAndValue (t) { const e = this._cachedMeta, s = this.chart, i = s.data.labels || [], o = us(e._parsed[t].r, s.options.locale); return { label: i[t] || "", value: o } } parseObjectData (t, e, s, i) { return mc.bind(this)(t, e, s, i) } update (t) { const e = this._cachedMeta.data; this._updateRadius(), this.updateElements(e, 0, e.length, t) } getMinMax () { const t = this._cachedMeta, e = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }; return t.data.forEach((s, i) => { const o = this.getParsed(i).r; !isNaN(o) && this.chart.getDataVisibility(i) && (o < e.min && (e.min = o), o > e.max && (e.max = o)) }), e } _updateRadius () { const t = this.chart, e = t.chartArea, s = t.options, i = Math.min(e.right - e.left, e.bottom - e.top), o = Math.max(i / 2, 0), a = Math.max(s.cutoutPercentage ? o / 100 * s.cutoutPercentage : 1, 0), r = (o - a) / t.getVisibleDatasetCount(); this.outerRadius = o - r * this.index, this.innerRadius = this.outerRadius - r } updateElements (t, e, s, i) { const o = i === "reset", a = this.chart, l = a.options.animation, c = this._cachedMeta.rScale, d = c.xCenter, u = c.yCenter, h = c.getIndexAngle(0) - .5 * mt; let f = h, g; const m = 360 / this.countVisibleElements(); for (g = 0; g < e; ++g)f += this._computeAngle(g, i, m); for (g = e; g < e + s; g++) { const v = t[g]; let p = f, b = f + this._computeAngle(g, i, m), y = a.getDataVisibility(g) ? c.getDistanceFromCenterForValue(this.getParsed(g).r) : 0; f = b, o && (l.animateScale && (y = 0), l.animateRotate && (p = b = h)); const k = { x: d, y: u, innerRadius: 0, outerRadius: y, startAngle: p, endAngle: b, options: this.resolveDataElementOptions(g, v.active ? "active" : i) }; this.updateElement(v, g, k, i) } } countVisibleElements () { const t = this._cachedMeta; let e = 0; return t.data.forEach((s, i) => { !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && e++ }), e } _computeAngle (t, e, s) { return this.chart.getDataVisibility(t) ? oe(this.resolveDataElementOptions(t, e).angle || s) : 0 } } V(qn, "id", "polarArea"), V(qn, "defaults", { dataElementType: "arc", animation: { animateRotate: !0, animateScale: !0 }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 }), V(qn, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels (t) { const e = t.data; if (e.labels.length && e.datasets.length) { const { labels: { pointStyle: s, color: i } } = t.legend.options; return e.labels.map((o, a) => { const l = t.getDatasetMeta(0).controller.getStyle(a); return { text: o, fillStyle: l.backgroundColor, strokeStyle: l.borderColor, fontColor: i, lineWidth: l.borderWidth, pointStyle: s, hidden: !t.getDataVisibility(a), index: a } }) } return [] } }, onClick (t, e, s) { s.chart.toggleDataVisibility(e.index), s.chart.update() } } }, scales: { r: { type: "radialLinear", angleLines: { display: !1 }, beginAtZero: !0, grid: { circular: !0 }, pointLabels: { display: !1 }, startAngle: 0 } } }); class bo extends tn { } V(bo, "id", "pie"), V(bo, "defaults", { cutout: 0, rotation: 0, circumference: 360, radius: "100%" }); class Ns extends le { getLabelAndValue (t) { const e = this._cachedMeta.vScale, s = this.getParsed(t); return { label: e.getLabels()[t], value: "" + e.getLabelForValue(s[e.axis]) } } parseObjectData (t, e, s, i) { return mc.bind(this)(t, e, s, i) } update (t) { const e = this._cachedMeta, s = e.dataset, i = e.data || [], o = e.iScale.getLabels(); if (s.points = i, t !== "resize") { const a = this.resolveDatasetElementOptions(t); this.options.showLine || (a.borderWidth = 0); const r = { _loop: !0, _fullLoop: o.length === i.length, options: a }; this.updateElement(s, void 0, r, t) } this.updateElements(i, 0, i.length, t) } updateElements (t, e, s, i) { const o = this._cachedMeta.rScale, a = i === "reset"; for (let r = e; r < e + s; r++) { const l = t[r], c = this.resolveDataElementOptions(r, l.active ? "active" : i), d = o.getPointPositionForValue(r, this.getParsed(r).r), u = a ? o.xCenter : d.x, h = a ? o.yCenter : d.y, f = { x: u, y: h, angle: d.angle, skip: isNaN(u) || isNaN(h), options: c }; this.updateElement(l, r, f, i) } } } V(Ns, "id", "radar"), V(Ns, "defaults", { datasetElementType: "line", dataElementType: "point", indexAxis: "r", showLine: !0, elements: { line: { fill: "start" } } }), V(Ns, "overrides", { aspectRatio: 1, scales: { r: { type: "radialLinear" } } }); class Fs extends le { getLabelAndValue (t) { const e = this._cachedMeta, s = this.chart.data.labels || [], { xScale: i, yScale: o } = e, a = this.getParsed(t), r = i.getLabelForValue(a.x), l = o.getLabelForValue(a.y); return { label: s[t] || "", value: "(" + r + ", " + l + ")" } } update (t) { const e = this._cachedMeta, { data: s = [] } = e, i = this.chart._animationsDisabled; let { start: o, count: a } = rc(e, s, i); if (this._drawStart = o, this._drawCount = a, lc(e) && (o = 0, a = s.length), this.options.showLine) { this.datasetElementType || this.addElements(); const { dataset: r, _dataset: l } = e; r._chart = this.chart, r._datasetIndex = this.index, r._decimated = !!l._decimated, r.points = s; const c = this.resolveDatasetElementOptions(t); c.segment = this.options.segment, this.updateElement(r, void 0, { animated: !i, options: c }, t) } else this.datasetElementType && (delete e.dataset, this.datasetElementType = !1); this.updateElements(s, o, a, t) } addElements () { const { showLine: t } = this.options; !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements() } updateElements (t, e, s, i) { const o = i === "reset", { iScale: a, vScale: r, _stacked: l, _dataset: c } = this._cachedMeta, d = this.resolveDataElementOptions(e, i), u = this.getSharedOptions(d), h = this.includeOptions(i, u), f = a.axis, g = r.axis, { spanGaps: m, segment: v } = this.options, p = kn(m) ? m : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || o || i === "none"; let y = e > 0 && this.getParsed(e - 1); for (let k = e; k < e + s; ++k) { const w = t[k], L = this.getParsed(k), A = b ? w : {}, x = at(L[g]), S = A[f] = a.getPixelForValue(L[f], k), C = A[g] = o || x ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, L, l) : L[g], k); A.skip = isNaN(S) || isNaN(C) || x, A.stop = k > 0 && Math.abs(L[f] - y[f]) > p, v && (A.parsed = L, A.raw = c.data[k]), h && (A.options = u || this.resolveDataElementOptions(k, w.active ? "active" : i)), b || this.updateElement(w, k, A, i), y = L } this.updateSharedOptions(u, i, d) } getMaxOverflow () { const t = this._cachedMeta, e = t.data || []; if (!this.options.showLine) { let r = 0; for (let l = e.length - 1; l >= 0; --l)r = Math.max(r, e[l].size(this.resolveDataElementOptions(l)) / 2); return r > 0 && r } const s = t.dataset, i = s.options && s.options.borderWidth || 0; if (!e.length) return i; const o = e[0].size(this.resolveDataElementOptions(0)), a = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1)); return Math.max(i, o, a) / 2 } } V(Fs, "id", "scatter"), V(Fs, "defaults", { datasetElementType: !1, dataElementType: "point", showLine: !1, fill: !1 }), V(Fs, "overrides", { interaction: { mode: "point" }, scales: { x: { type: "linear" }, y: { type: "linear" } } }); var Rm = Object.freeze({ __proto__: null, BarController: Es, BubbleController: Rs, DoughnutController: tn, LineController: Is, PieController: bo, PolarAreaController: qn, RadarController: Ns, ScatterController: Fs }); function Ke () { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } class ea { constructor(t) { V(this, "options"); this.options = t || {} } static override (t) { Object.assign(ea.prototype, t) } init () { } formats () { return Ke() } parse () { return Ke() } format () { return Ke() } add () { return Ke() } diff () { return Ke() } startOf () { return Ke() } endOf () { return Ke() } } var Im = { _date: ea }; function Nm (n, t, e, s) { const { controller: i, data: o, _sorted: a } = n, r = i._cachedMeta.iScale; if (r && t === r.axis && t !== "r" && a && o.length) { const l = r._reversePixels ? ag : we; if (s) { if (i._sharedOptions) { const c = o[0], d = typeof c.getRange == "function" && c.getRange(t); if (d) { const u = l(o, t, e - d), h = l(o, t, e + d); return { lo: u.lo, hi: h.hi } } } } else return l(o, t, e) } return { lo: 0, hi: o.length - 1 } } function hs (n, t, e, s, i) { const o = n.getSortedVisibleDatasetMetas(), a = e[t]; for (let r = 0, l = o.length; r < l; ++r) { const { index: c, data: d } = o[r], { lo: u, hi: h } = Nm(o[r], t, a, i); for (let f = u; f <= h; ++f) { const g = d[f]; g.skip || s(g, c, f) } } } function Fm (n) { const t = n.indexOf("x") !== -1, e = n.indexOf("y") !== -1; return function (s, i) { const o = t ? Math.abs(s.x - i.x) : 0, a = e ? Math.abs(s.y - i.y) : 0; return Math.sqrt(Math.pow(o, 2) + Math.pow(a, 2)) } } function Ui (n, t, e, s, i) { const o = []; return !i && !n.isPointInArea(t) || hs(n, e, t, function (r, l, c) { !i && !ke(r, n.chartArea, 0) || r.inRange(t.x, t.y, s) && o.push({ element: r, datasetIndex: l, index: c }) }, !0), o } function Vm (n, t, e, s) { let i = []; function o (a, r, l) { const { startAngle: c, endAngle: d } = a.getProps(["startAngle", "endAngle"], s), { angle: u } = nc(a, { x: t.x, y: t.y }); es(u, c, d) && i.push({ element: a, datasetIndex: r, index: l }) } return hs(n, e, t, o), i } function Bm (n, t, e, s, i, o) { let a = []; const r = Fm(e); let l = Number.POSITIVE_INFINITY; function c (d, u, h) { const f = d.inRange(t.x, t.y, i); if (s && !f) return; const g = d.getCenterPoint(i); if (!(!!o || n.isPointInArea(g)) && !f) return; const v = r(t, g); v < l ? (a = [{ element: d, datasetIndex: u, index: h }], l = v) : v === l && a.push({ element: d, datasetIndex: u, index: h }) } return hs(n, e, t, c), a } function Yi (n, t, e, s, i, o) { return !o && !n.isPointInArea(t) ? [] : e === "r" && !s ? Vm(n, t, e, i) : Bm(n, t, e, s, i, o) } function gr (n, t, e, s, i) { const o = [], a = e === "x" ? "inXRange" : "inYRange"; let r = !1; return hs(n, e, t, (l, c, d) => { l[a](t[e], i) && (o.push({ element: l, datasetIndex: c, index: d }), r = r || l.inRange(t.x, t.y, i)) }), s && !r ? [] : o } var zm = { evaluateInteractionItems: hs, modes: { index (n, t, e, s) { const i = Je(t, n), o = e.axis || "x", a = e.includeInvisible || !1, r = e.intersect ? Ui(n, i, o, s, a) : Yi(n, i, o, !1, s, a), l = []; return r.length ? (n.getSortedVisibleDatasetMetas().forEach(c => { const d = r[0].index, u = c.data[d]; u && !u.skip && l.push({ element: u, datasetIndex: c.index, index: d }) }), l) : [] }, dataset (n, t, e, s) { const i = Je(t, n), o = e.axis || "xy", a = e.includeInvisible || !1; let r = e.intersect ? Ui(n, i, o, s, a) : Yi(n, i, o, !1, s, a); if (r.length > 0) { const l = r[0].datasetIndex, c = n.getDatasetMeta(l).data; r = []; for (let d = 0; d < c.length; ++d)r.push({ element: c[d], datasetIndex: l, index: d }) } return r }, point (n, t, e, s) { const i = Je(t, n), o = e.axis || "xy", a = e.includeInvisible || !1; return Ui(n, i, o, s, a) }, nearest (n, t, e, s) { const i = Je(t, n), o = e.axis || "xy", a = e.includeInvisible || !1; return Yi(n, i, o, e.intersect, s, a) }, x (n, t, e, s) { const i = Je(t, n); return gr(n, i, "x", e.intersect, s) }, y (n, t, e, s) { const i = Je(t, n); return gr(n, i, "y", e.intersect, s) } } }; const Pc = ["left", "top", "right", "bottom"]; function On (n, t) { return n.filter(e => e.pos === t) } function mr (n, t) { return n.filter(e => Pc.indexOf(e.pos) === -1 && e.box.axis === t) } function Ln (n, t) { return n.sort((e, s) => { const i = t ? s : e, o = t ? e : s; return i.weight === o.weight ? i.index - o.index : i.weight - o.weight }) } function jm (n) { const t = []; let e, s, i, o, a, r; for (e = 0, s = (n || []).length; e < s; ++e)i = n[e], { position: o, options: { stack: a, stackWeight: r = 1 } } = i, t.push({ index: e, box: i, pos: o, horizontal: i.isHorizontal(), weight: i.weight, stack: a && o + a, stackWeight: r }); return t } function Hm (n) { const t = {}; for (const e of n) { const { stack: s, pos: i, stackWeight: o } = e; if (!s || !Pc.includes(i)) continue; const a = t[s] || (t[s] = { count: 0, placed: 0, weight: 0, size: 0 }); a.count++, a.weight += o } return t } function Wm (n, t) { const e = Hm(n), { vBoxMaxWidth: s, hBoxMaxHeight: i } = t; let o, a, r; for (o = 0, a = n.length; o < a; ++o) { r = n[o]; const { fullSize: l } = r.box, c = e[r.stack], d = c && r.stackWeight / c.weight; r.horizontal ? (r.width = d ? d * s : l && t.availableWidth, r.height = i) : (r.width = s, r.height = d ? d * i : l && t.availableHeight) } return e } function Um (n) { const t = jm(n), e = Ln(t.filter(c => c.box.fullSize), !0), s = Ln(On(t, "left"), !0), i = Ln(On(t, "right")), o = Ln(On(t, "top"), !0), a = Ln(On(t, "bottom")), r = mr(t, "x"), l = mr(t, "y"); return { fullSize: e, leftAndTop: s.concat(o), rightAndBottom: i.concat(l).concat(a).concat(r), chartArea: On(t, "chartArea"), vertical: s.concat(i).concat(l), horizontal: o.concat(a).concat(r) } } function br (n, t, e, s) { return Math.max(n[e], t[e]) + Math.max(n[s], t[s]) } function Cc (n, t) { n.top = Math.max(n.top, t.top), n.left = Math.max(n.left, t.left), n.bottom = Math.max(n.bottom, t.bottom), n.right = Math.max(n.right, t.right) } function Ym (n, t, e, s) { const { pos: i, box: o } = e, a = n.maxPadding; if (!ot(i)) { e.size && (n[i] -= e.size); const u = s[e.stack] || { size: 0, count: 1 }; u.size = Math.max(u.size, e.horizontal ? o.height : o.width), e.size = u.size / u.count, n[i] += e.size } o.getPadding && Cc(a, o.getPadding()); const r = Math.max(0, t.outerWidth - br(a, n, "left", "right")), l = Math.max(0, t.outerHeight - br(a, n, "top", "bottom")), c = r !== n.w, d = l !== n.h; return n.w = r, n.h = l, e.horizontal ? { same: c, other: d } : { same: d, other: c } } function Km (n) { const t = n.maxPadding; function e (s) { const i = Math.max(t[s] - n[s], 0); return n[s] += i, i } n.y += e("top"), n.x += e("left"), e("right"), e("bottom") } function qm (n, t) { const e = t.maxPadding; function s (i) { const o = { left: 0, top: 0, right: 0, bottom: 0 }; return i.forEach(a => { o[a] = Math.max(t[a], e[a]) }), o } return s(n ? ["left", "right"] : ["top", "bottom"]) } function Nn (n, t, e, s) { const i = []; let o, a, r, l, c, d; for (o = 0, a = n.length, c = 0; o < a; ++o) { r = n[o], l = r.box, l.update(r.width || t.w, r.height || t.h, qm(r.horizontal, t)); const { same: u, other: h } = Ym(t, e, r, s); c |= u && i.length, d = d || h, l.fullSize || i.push(r) } return c && Nn(i, t, e, s) || d } function ks (n, t, e, s, i) { n.top = e, n.left = t, n.right = t + s, n.bottom = e + i, n.width = s, n.height = i } function vr (n, t, e, s) { const i = e.padding; let { x: o, y: a } = t; for (const r of n) { const l = r.box, c = s[r.stack] || { count: 1, placed: 0, weight: 1 }, d = r.stackWeight / c.weight || 1; if (r.horizontal) { const u = t.w * d, h = c.size || l.height; ts(c.start) && (a = c.start), l.fullSize ? ks(l, i.left, a, e.outerWidth - i.right - i.left, h) : ks(l, t.left + c.placed, a, u, h), c.start = a, c.placed += u, a = l.bottom } else { const u = t.h * d, h = c.size || l.width; ts(c.start) && (o = c.start), l.fullSize ? ks(l, o, i.top, h, e.outerHeight - i.bottom - i.top) : ks(l, o, t.top + c.placed, h, u), c.start = o, c.placed += u, o = l.right } } t.x = o, t.y = a } var jt = { addBox (n, t) { n.boxes || (n.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function () { return [{ z: 0, draw (e) { t.draw(e) } }] }, n.boxes.push(t) }, removeBox (n, t) { const e = n.boxes ? n.boxes.indexOf(t) : -1; e !== -1 && n.boxes.splice(e, 1) }, configure (n, t, e) { t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight }, update (n, t, e, s) { if (!n) return; const i = Ht(n.options.layout.padding), o = Math.max(t - i.width, 0), a = Math.max(e - i.height, 0), r = Um(n.boxes), l = r.vertical, c = r.horizontal; ut(n.boxes, m => { typeof m.beforeLayout == "function" && m.beforeLayout() }); const d = l.reduce((m, v) => v.box.options && v.box.options.display === !1 ? m : m + 1, 0) || 1, u = Object.freeze({ outerWidth: t, outerHeight: e, padding: i, availableWidth: o, availableHeight: a, vBoxMaxWidth: o / 2 / d, hBoxMaxHeight: a / 2 }), h = Object.assign({}, i); Cc(h, Ht(s)); const f = Object.assign({ maxPadding: h, w: o, h: a, x: i.left, y: i.top }, i), g = Wm(l.concat(c), u); Nn(r.fullSize, f, u, g), Nn(l, f, u, g), Nn(c, f, u, g) && Nn(l, f, u, g), Km(f), vr(r.leftAndTop, f, u, g), f.x += f.w, f.y += f.h, vr(r.rightAndBottom, f, u, g), n.chartArea = { left: f.left, top: f.top, right: f.left + f.w, bottom: f.top + f.h, height: f.h, width: f.w }, ut(r.chartArea, m => { const v = m.box; Object.assign(v, n.chartArea), v.update(f.w, f.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } }; class Tc { acquireContext (t, e) { } releaseContext (t) { return !1 } addEventListener (t, e, s) { } removeEventListener (t, e, s) { } getDevicePixelRatio () { return 1 } getMaximumSize (t, e, s, i) { return e = Math.max(0, e || t.width), s = s || t.height, { width: e, height: Math.max(0, i ? Math.floor(e / i) : s) } } isAttached (t) { return !0 } updateConfig (t) { } } class Xm extends Tc { acquireContext (t) { return t && t.getContext && t.getContext("2d") || null } updateConfig (t) { t.options.animation = !1 } } const Vs = "$chartjs", Gm = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, _r = n => n === null || n === ""; function Jm (n, t) { const e = n.style, s = n.getAttribute("height"), i = n.getAttribute("width"); if (n[Vs] = { initial: { height: s, width: i, style: { display: e.display, height: e.height, width: e.width } } }, e.display = e.display || "block", e.boxSizing = e.boxSizing || "border-box", _r(i)) { const o = er(n, "width"); o !== void 0 && (n.width = o) } if (_r(s)) if (n.style.height === "") n.height = n.width / (t || 2); else { const o = er(n, "height"); o !== void 0 && (n.height = o) } return n } const Oc = Zg ? { passive: !0 } : !1; function Qm (n, t, e) { n && n.addEventListener(t, e, Oc) } function Zm (n, t, e) { n && n.canvas && n.canvas.removeEventListener(t, e, Oc) } function t0 (n, t) { const e = Gm[n.type] || n.type, { x: s, y: i } = Je(n, t); return { type: e, chart: t, native: n, x: s !== void 0 ? s : null, y: i !== void 0 ? i : null } } function ii (n, t) { for (const e of n) if (e === t || e.contains(t)) return !0 } function e0 (n, t, e) { const s = n.canvas, i = new MutationObserver(o => { let a = !1; for (const r of o) a = a || ii(r.addedNodes, s), a = a && !ii(r.removedNodes, s); a && e() }); return i.observe(document, { childList: !0, subtree: !0 }), i } function n0 (n, t, e) { const s = n.canvas, i = new MutationObserver(o => { let a = !1; for (const r of o) a = a || ii(r.removedNodes, s), a = a && !ii(r.addedNodes, s); a && e() }); return i.observe(document, { childList: !0, subtree: !0 }), i } const ss = new Map; let yr = 0; function Lc () { const n = window.devicePixelRatio; n !== yr && (yr = n, ss.forEach((t, e) => { e.currentDevicePixelRatio !== n && t() })) } function s0 (n, t) { ss.size || window.addEventListener("resize", Lc), ss.set(n, t) } function i0 (n) { ss.delete(n), ss.size || window.removeEventListener("resize", Lc) } function o0 (n, t, e) { const s = n.canvas, i = s && ta(s); if (!i) return; const o = ac((r, l) => { const c = i.clientWidth; e(r, l), c < i.clientWidth && e() }, window), a = new ResizeObserver(r => { const l = r[0], c = l.contentRect.width, d = l.contentRect.height; c === 0 && d === 0 || o(c, d) }); return a.observe(i), s0(n, o), a } function Ki (n, t, e) { e && e.disconnect(), t === "resize" && i0(n) } function a0 (n, t, e) { const s = n.canvas, i = ac(o => { n.ctx !== null && e(t0(o, n)) }, n); return Qm(s, t, i), i } class r0 extends Tc { acquireContext (t, e) { const s = t && t.getContext && t.getContext("2d"); return s && s.canvas === t ? (Jm(t, e), s) : null } releaseContext (t) { const e = t.canvas; if (!e[Vs]) return !1; const s = e[Vs].initial;["height", "width"].forEach(o => { const a = s[o]; at(a) ? e.removeAttribute(o) : e.setAttribute(o, a) }); const i = s.style || {}; return Object.keys(i).forEach(o => { e.style[o] = i[o] }), e.width = e.width, delete e[Vs], !0 } addEventListener (t, e, s) { this.removeEventListener(t, e); const i = t.$proxies || (t.$proxies = {}), a = { attach: e0, detach: n0, resize: o0 }[e] || a0; i[e] = a(t, e, s) } removeEventListener (t, e) { const s = t.$proxies || (t.$proxies = {}), i = s[e]; if (!i) return; ({ attach: Ki, detach: Ki, resize: Ki }[e] || Zm)(t, e, i), s[e] = void 0 } getDevicePixelRatio () { return window.devicePixelRatio } getMaximumSize (t, e, s, i) { return Qg(t, e, s, i) } isAttached (t) { const e = t && ta(t); return !!(e && e.isConnected) } } function l0 (n) { return !Zo() || typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas ? Xm : r0 } var As; let Pe = (As = class { constructor() { V(this, "x"); V(this, "y"); V(this, "active", !1); V(this, "options"); V(this, "$animations") } tooltipPosition (t) { const { x: e, y: s } = this.getProps(["x", "y"], t); return { x: e, y: s } } hasValue () { return kn(this.x) && kn(this.y) } getProps (t, e) { const s = this.$animations; if (!e || !s) return this; const i = {}; return t.forEach(o => { i[o] = s[o] && s[o].active() ? s[o]._to : this[o] }), i } }, V(As, "defaults", {}), V(As, "defaultRoutes"), As); function c0 (n, t) { const e = n.options.ticks, s = d0(n), i = Math.min(e.maxTicksLimit || s, s), o = e.major.enabled ? h0(t) : [], a = o.length, r = o[0], l = o[a - 1], c = []; if (a > i) return f0(t, c, o, a / i), c; const d = u0(o, t, i); if (a > 0) { let u, h; const f = a > 1 ? Math.round((l - r) / (a - 1)) : null; for (Ss(t, c, d, at(f) ? 0 : r - f, r), u = 0, h = a - 1; u < h; u++)Ss(t, c, d, o[u], o[u + 1]); return Ss(t, c, d, l, at(f) ? t.length : l + f), c } return Ss(t, c, d), c } function d0 (n) { const t = n.options.offset, e = n._tickSize(), s = n._length / e + (t ? 0 : 1), i = n._maxLength / e; return Math.floor(Math.min(s, i)) } function u0 (n, t, e) { const s = p0(n), i = t.length / e; if (!s) return Math.max(i, 1); const o = ng(s); for (let a = 0, r = o.length - 1; a < r; a++) { const l = o[a]; if (l > i) return l } return Math.max(i, 1) } function h0 (n) { const t = []; let e, s; for (e = 0, s = n.length; e < s; e++)n[e].major && t.push(e); return t } function f0 (n, t, e, s) { let i = 0, o = e[0], a; for (s = Math.ceil(s), a = 0; a < n.length; a++)a === o && (t.push(n[a]), i++, o = e[i * s]) } function Ss (n, t, e, s, i) { const o = tt(s, 0), a = Math.min(tt(i, n.length), n.length); let r = 0, l, c, d; for (e = Math.ceil(e), i && (l = i - s, e = l / Math.floor(l / e)), d = o; d < 0;)r++, d = Math.round(o + r * e); for (c = Math.max(o, 0); c < a; c++)c === d && (t.push(n[c]), r++, d = Math.round(o + r * e)) } function p0 (n) { const t = n.length; let e, s; if (t < 2) return !1; for (s = n[0], e = 1; e < t; ++e)if (n[e] - n[e - 1] !== s) return !1; return s } const g0 = n => n === "left" ? "right" : n === "right" ? "left" : n, xr = (n, t, e) => t === "top" || t === "left" ? n[t] + e : n[t] - e, wr = (n, t) => Math.min(t || n, n); function kr (n, t) { const e = [], s = n.length / t, i = n.length; let o = 0; for (; o < i; o += s)e.push(n[Math.floor(o)]); return e } function m0 (n, t, e) { const s = n.ticks.length, i = Math.min(t, s - 1), o = n._startPixel, a = n._endPixel, r = 1e-6; let l = n.getPixelForTick(i), c; if (!(e && (s === 1 ? c = Math.max(l - o, a - l) : t === 0 ? c = (n.getPixelForTick(1) - l) / 2 : c = (l - n.getPixelForTick(i - 1)) / 2, l += i < t ? c : -c, l < o - r || l > a + r))) return l } function b0 (n, t) { ut(n, e => { const s = e.gc, i = s.length / 2; let o; if (i > t) { for (o = 0; o < i; ++o)delete e.data[s[o]]; s.splice(0, i) } }) } function An (n) { return n.drawTicks ? n.tickLength : 0 } function Sr (n, t) { if (!n.display) return 0; const e = At(n.font, t), s = Ht(n.padding); return (yt(n.text) ? n.text.length : 1) * e.lineHeight + s.height } function v0 (n, t) { return We(n, { scale: t, type: "scale" }) } function _0 (n, t, e) { return We(n, { tick: e, index: t, type: "tick" }) } function y0 (n, t, e) { let s = Ko(n); return (e && t !== "right" || !e && t === "right") && (s = g0(s)), s } function x0 (n, t, e, s) { const { top: i, left: o, bottom: a, right: r, chart: l } = n, { chartArea: c, scales: d } = l; let u = 0, h, f, g; const m = a - i, v = r - o; if (n.isHorizontal()) { if (f = zt(s, o, r), ot(e)) { const p = Object.keys(e)[0], b = e[p]; g = d[p].getPixelForValue(b) + m - t } else e === "center" ? g = (c.bottom + c.top) / 2 + m - t : g = xr(n, e, t); h = r - o } else { if (ot(e)) { const p = Object.keys(e)[0], b = e[p]; f = d[p].getPixelForValue(b) - v + t } else e === "center" ? f = (c.left + c.right) / 2 - v + t : f = xr(n, e, t); g = zt(s, a, i), u = e === "left" ? -Ct : Ct } return { titleX: f, titleY: g, maxWidth: h, rotation: u } } class un extends Pe { constructor(t) { super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init (t) { this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax) } parse (t, e) { return t } getUserBounds () { let { _userMin: t, _userMax: e, _suggestedMin: s, _suggestedMax: i } = this; return t = Xt(t, Number.POSITIVE_INFINITY), e = Xt(e, Number.NEGATIVE_INFINITY), s = Xt(s, Number.POSITIVE_INFINITY), i = Xt(i, Number.NEGATIVE_INFINITY), { min: Xt(t, s), max: Xt(e, i), minDefined: Mt(t), maxDefined: Mt(e) } } getMinMax (t) { let { min: e, max: s, minDefined: i, maxDefined: o } = this.getUserBounds(), a; if (i && o) return { min: e, max: s }; const r = this.getMatchingVisibleMetas(); for (let l = 0, c = r.length; l < c; ++l)a = r[l].controller.getMinMax(this, t), i || (e = Math.min(e, a.min)), o || (s = Math.max(s, a.max)); return e = o && e > s ? s : e, s = i && e > s ? e : s, { min: Xt(e, Xt(s, e)), max: Xt(s, Xt(e, s)) } } getPadding () { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks () { return this.ticks } getLabels () { const t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [] } getLabelItems (t = this.chart.chartArea) { return this._labelItems || (this._labelItems = this._computeLabelItems(t)) } beforeLayout () { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate () { pt(this.options.beforeUpdate, [this]) } update (t, e, s) { const { beginAtZero: i, grace: o, ticks: a } = this.options, r = a.sampleSize; this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = s = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, s), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Lg(this, o, i), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const l = r < this.ticks.length; this._convertTicksToLabels(l ? kr(this.ticks, r) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), a.display && (a.autoSkip || a.source === "auto") && (this.ticks = c0(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure () { let t = this.options.reverse, e, s; this.isHorizontal() ? (e = this.left, s = this.right) : (e = this.top, s = this.bottom, t = !t), this._startPixel = e, this._endPixel = s, this._reversePixels = t, this._length = s - e, this._alignToPixels = this.options.alignToPixels } afterUpdate () { pt(this.options.afterUpdate, [this]) } beforeSetDimensions () { pt(this.options.beforeSetDimensions, [this]) } setDimensions () { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions () { pt(this.options.afterSetDimensions, [this]) } _callHooks (t) { this.chart.notifyPlugins(t, this.getContext()), pt(this.options[t], [this]) } beforeDataLimits () { this._callHooks("beforeDataLimits") } determineDataLimits () { } afterDataLimits () { this._callHooks("afterDataLimits") } beforeBuildTicks () { this._callHooks("beforeBuildTicks") } buildTicks () { return [] } afterBuildTicks () { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion () { pt(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels (t) { const e = this.options.ticks; let s, i, o; for (s = 0, i = t.length; s < i; s++)o = t[s], o.label = pt(e.callback, [o.value, s, t], this) } afterTickToLabelConversion () { pt(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation () { pt(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation () { const t = this.options, e = t.ticks, s = wr(this.ticks.length, t.ticks.maxTicksLimit), i = e.minRotation || 0, o = e.maxRotation; let a = i, r, l, c; if (!this._isVisible() || !e.display || i >= o || s <= 1 || !this.isHorizontal()) { this.labelRotation = i; return } const d = this._getLabelSizes(), u = d.widest.width, h = d.highest.height, f = Dt(this.chart.width - u, 0, this.maxWidth); r = t.offset ? this.maxWidth / s : f / (s - 1), u + 6 > r && (r = f / (s - (t.offset ? .5 : 1)), l = this.maxHeight - An(t.grid) - e.padding - Sr(t.title, this.chart.options.font), c = Math.sqrt(u * u + h * h), a = Uo(Math.min(Math.asin(Dt((d.highest.height + 6) / r, -1, 1)), Math.asin(Dt(l / c, -1, 1)) - Math.asin(Dt(h / c, -1, 1)))), a = Math.max(i, Math.min(o, a))), this.labelRotation = a } afterCalculateLabelRotation () { pt(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip () { } beforeFit () { pt(this.options.beforeFit, [this]) } fit () { const t = { width: 0, height: 0 }, { chart: e, options: { ticks: s, title: i, grid: o } } = this, a = this._isVisible(), r = this.isHorizontal(); if (a) { const l = Sr(i, e.options.font); if (r ? (t.width = this.maxWidth, t.height = An(o) + l) : (t.height = this.maxHeight, t.width = An(o) + l), s.display && this.ticks.length) { const { first: c, last: d, widest: u, highest: h } = this._getLabelSizes(), f = s.padding * 2, g = oe(this.labelRotation), m = Math.cos(g), v = Math.sin(g); if (r) { const p = s.mirror ? 0 : v * u.width + m * h.height; t.height = Math.min(this.maxHeight, t.height + p + f) } else { const p = s.mirror ? 0 : m * u.width + v * h.height; t.width = Math.min(this.maxWidth, t.width + p + f) } this._calculatePadding(c, d, v, m) } } this._handleMargins(), r ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom) } _calculatePadding (t, e, s, i) { const { ticks: { align: o, padding: a }, position: r } = this.options, l = this.labelRotation !== 0, c = r !== "top" && this.axis === "x"; if (this.isHorizontal()) { const d = this.getPixelForTick(0) - this.left, u = this.right - this.getPixelForTick(this.ticks.length - 1); let h = 0, f = 0; l ? c ? (h = i * t.width, f = s * e.height) : (h = s * t.height, f = i * e.width) : o === "start" ? f = e.width : o === "end" ? h = t.width : o !== "inner" && (h = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((h - d + a) * this.width / (this.width - d), 0), this.paddingRight = Math.max((f - u + a) * this.width / (this.width - u), 0) } else { let d = e.height / 2, u = t.height / 2; o === "start" ? (d = 0, u = t.height) : o === "end" && (d = e.height, u = 0), this.paddingTop = d + a, this.paddingBottom = u + a } } _handleMargins () { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit () { pt(this.options.afterFit, [this]) } isHorizontal () { const { axis: t, position: e } = this.options; return e === "top" || e === "bottom" || t === "x" } isFullSize () { return this.options.fullSize } _convertTicksToLabels (t) { this.beforeTickToLabelConversion(), this.generateTickLabels(t); let e, s; for (e = 0, s = t.length; e < s; e++)at(t[e].label) && (t.splice(e, 1), s--, e--); this.afterTickToLabelConversion() } _getLabelSizes () { let t = this._labelSizes; if (!t) { const e = this.options.ticks.sampleSize; let s = this.ticks; e < s.length && (s = kr(s, e)), this._labelSizes = t = this._computeLabelSizes(s, s.length, this.options.ticks.maxTicksLimit) } return t } _computeLabelSizes (t, e, s) { const { ctx: i, _longestTextCache: o } = this, a = [], r = [], l = Math.floor(e / wr(e, s)); let c = 0, d = 0, u, h, f, g, m, v, p, b, y, k, w; for (u = 0; u < e; u += l) { if (g = t[u].label, m = this._resolveTickFontOptions(u), i.font = v = m.string, p = o[v] = o[v] || { data: {}, gc: [] }, b = m.lineHeight, y = k = 0, !at(g) && !yt(g)) y = ni(i, p.data, p.gc, y, g), k = b; else if (yt(g)) for (h = 0, f = g.length; h < f; ++h)w = g[h], !at(w) && !yt(w) && (y = ni(i, p.data, p.gc, y, w), k += b); a.push(y), r.push(k), c = Math.max(y, c), d = Math.max(k, d) } b0(o, e); const L = a.indexOf(c), A = r.indexOf(d), x = S => ({ width: a[S] || 0, height: r[S] || 0 }); return { first: x(0), last: x(e - 1), widest: x(L), highest: x(A), widths: a, heights: r } } getLabelForValue (t) { return t } getPixelForValue (t, e) { return NaN } getValueForPixel (t) { } getPixelForTick (t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } getPixelForDecimal (t) { this._reversePixels && (t = 1 - t); const e = this._startPixel + t * this._length; return og(this._alignToPixels ? Ye(this.chart, e, 0) : e) } getDecimalForPixel (t) { const e = (t - this._startPixel) / this._length; return this._reversePixels ? 1 - e : e } getBasePixel () { return this.getPixelForValue(this.getBaseValue()) } getBaseValue () { const { min: t, max: e } = this; return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0 } getContext (t) { const e = this.ticks || []; if (t >= 0 && t < e.length) { const s = e[t]; return s.$context || (s.$context = _0(this.getContext(), t, s)) } return this.$context || (this.$context = v0(this.chart.getContext(), this)) } _tickSize () { const t = this.options.ticks, e = oe(this.labelRotation), s = Math.abs(Math.cos(e)), i = Math.abs(Math.sin(e)), o = this._getLabelSizes(), a = t.autoSkipPadding || 0, r = o ? o.widest.width + a : 0, l = o ? o.highest.height + a : 0; return this.isHorizontal() ? l * s > r * i ? r / s : l / i : l * i < r * s ? l / s : r / i } _isVisible () { const t = this.options.display; return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems (t) { const e = this.axis, s = this.chart, i = this.options, { grid: o, position: a, border: r } = i, l = o.offset, c = this.isHorizontal(), u = this.ticks.length + (l ? 1 : 0), h = An(o), f = [], g = r.setContext(this.getContext()), m = g.display ? g.width : 0, v = m / 2, p = function (B) { return Ye(s, B, m) }; let b, y, k, w, L, A, x, S, C, T, R, I; if (a === "top") b = p(this.bottom), A = this.bottom - h, S = b - v, T = p(t.top) + v, I = t.bottom; else if (a === "bottom") b = p(this.top), T = t.top, I = p(t.bottom) - v, A = b + v, S = this.top + h; else if (a === "left") b = p(this.right), L = this.right - h, x = b - v, C = p(t.left) + v, R = t.right; else if (a === "right") b = p(this.left), C = t.left, R = p(t.right) - v, L = b + v, x = this.left + h; else if (e === "x") { if (a === "center") b = p((t.top + t.bottom) / 2 + .5); else if (ot(a)) { const B = Object.keys(a)[0], F = a[B]; b = p(this.chart.scales[B].getPixelForValue(F)) } T = t.top, I = t.bottom, A = b + v, S = A + h } else if (e === "y") { if (a === "center") b = p((t.left + t.right) / 2); else if (ot(a)) { const B = Object.keys(a)[0], F = a[B]; b = p(this.chart.scales[B].getPixelForValue(F)) } L = b - v, x = L - h, C = t.left, R = t.right } const H = tt(i.ticks.maxTicksLimit, u), E = Math.max(1, Math.ceil(u / H)); for (y = 0; y < u; y += E) { const B = this.getContext(y), F = o.setContext(B), G = r.setContext(B), nt = F.lineWidth, kt = F.color, lt = G.dash || [], bt = G.dashOffset, St = F.tickWidth, ft = F.tickColor, Rt = F.tickBorderDash || [], $t = F.tickBorderDashOffset; k = m0(this, y, l), k !== void 0 && (w = Ye(s, k, nt), c ? L = x = C = R = w : A = S = T = I = w, f.push({ tx1: L, ty1: A, tx2: x, ty2: S, x1: C, y1: T, x2: R, y2: I, width: nt, color: kt, borderDash: lt, borderDashOffset: bt, tickWidth: St, tickColor: ft, tickBorderDash: Rt, tickBorderDashOffset: $t })) } return this._ticksLength = u, this._borderValue = b, f } _computeLabelItems (t) { const e = this.axis, s = this.options, { position: i, ticks: o } = s, a = this.isHorizontal(), r = this.ticks, { align: l, crossAlign: c, padding: d, mirror: u } = o, h = An(s.grid), f = h + d, g = u ? -d : f, m = -oe(this.labelRotation), v = []; let p, b, y, k, w, L, A, x, S, C, T, R, I = "middle"; if (i === "top") L = this.bottom - g, A = this._getXAxisLabelAlignment(); else if (i === "bottom") L = this.top + g, A = this._getXAxisLabelAlignment(); else if (i === "left") { const E = this._getYAxisLabelAlignment(h); A = E.textAlign, w = E.x } else if (i === "right") { const E = this._getYAxisLabelAlignment(h); A = E.textAlign, w = E.x } else if (e === "x") { if (i === "center") L = (t.top + t.bottom) / 2 + f; else if (ot(i)) { const E = Object.keys(i)[0], B = i[E]; L = this.chart.scales[E].getPixelForValue(B) + f } A = this._getXAxisLabelAlignment() } else if (e === "y") { if (i === "center") w = (t.left + t.right) / 2 - f; else if (ot(i)) { const E = Object.keys(i)[0], B = i[E]; w = this.chart.scales[E].getPixelForValue(B) } A = this._getYAxisLabelAlignment(h).textAlign } e === "y" && (l === "start" ? I = "top" : l === "end" && (I = "bottom")); const H = this._getLabelSizes(); for (p = 0, b = r.length; p < b; ++p) { y = r[p], k = y.label; const E = o.setContext(this.getContext(p)); x = this.getPixelForTick(p) + o.labelOffset, S = this._resolveTickFontOptions(p), C = S.lineHeight, T = yt(k) ? k.length : 1; const B = T / 2, F = E.color, G = E.textStrokeColor, nt = E.textStrokeWidth; let kt = A; a ? (w = x, A === "inner" && (p === b - 1 ? kt = this.options.reverse ? "left" : "right" : p === 0 ? kt = this.options.reverse ? "right" : "left" : kt = "center"), i === "top" ? c === "near" || m !== 0 ? R = -T * C + C / 2 : c === "center" ? R = -H.highest.height / 2 - B * C + C : R = -H.highest.height + C / 2 : c === "near" || m !== 0 ? R = C / 2 : c === "center" ? R = H.highest.height / 2 - B * C : R = H.highest.height - T * C, u && (R *= -1), m !== 0 && !E.showLabelBackdrop && (w += C / 2 * Math.sin(m))) : (L = x, R = (1 - T) * C / 2); let lt; if (E.showLabelBackdrop) { const bt = Ht(E.backdropPadding), St = H.heights[p], ft = H.widths[p]; let Rt = R - bt.top, $t = 0 - bt.left; switch (I) { case "middle": Rt -= St / 2; break; case "bottom": Rt -= St; break }switch (A) { case "center": $t -= ft / 2; break; case "right": $t -= ft; break; case "inner": p === b - 1 ? $t -= ft : p > 0 && ($t -= ft / 2); break }lt = { left: $t, top: Rt, width: ft + bt.width, height: St + bt.height, color: E.backdropColor } } v.push({ label: k, font: S, textOffset: R, options: { rotation: m, color: F, strokeColor: G, strokeWidth: nt, textAlign: kt, textBaseline: I, translation: [w, L], backdrop: lt } }) } return v } _getXAxisLabelAlignment () { const { position: t, ticks: e } = this.options; if (-oe(this.labelRotation)) return t === "top" ? "left" : "right"; let i = "center"; return e.align === "start" ? i = "left" : e.align === "end" ? i = "right" : e.align === "inner" && (i = "inner"), i } _getYAxisLabelAlignment (t) { const { position: e, ticks: { crossAlign: s, mirror: i, padding: o } } = this.options, a = this._getLabelSizes(), r = t + o, l = a.widest.width; let c, d; return e === "left" ? i ? (d = this.right + o, s === "near" ? c = "left" : s === "center" ? (c = "center", d += l / 2) : (c = "right", d += l)) : (d = this.right - r, s === "near" ? c = "right" : s === "center" ? (c = "center", d -= l / 2) : (c = "left", d = this.left)) : e === "right" ? i ? (d = this.left + o, s === "near" ? c = "right" : s === "center" ? (c = "center", d -= l / 2) : (c = "left", d -= l)) : (d = this.left + r, s === "near" ? c = "left" : s === "center" ? (c = "center", d += l / 2) : (c = "right", d = this.right)) : c = "right", { textAlign: c, x: d } } _computeLabelArea () { if (this.options.ticks.mirror) return; const t = this.chart, e = this.options.position; if (e === "left" || e === "right") return { top: 0, left: this.left, bottom: t.height, right: this.right }; if (e === "top" || e === "bottom") return { top: this.top, left: 0, bottom: this.bottom, right: t.width } } drawBackground () { const { ctx: t, options: { backgroundColor: e }, left: s, top: i, width: o, height: a } = this; e && (t.save(), t.fillStyle = e, t.fillRect(s, i, o, a), t.restore()) } getLineWidthForValue (t) { const e = this.options.grid; if (!this._isVisible() || !e.display) return 0; const i = this.ticks.findIndex(o => o.value === t); return i >= 0 ? e.setContext(this.getContext(i)).lineWidth : 0 } drawGrid (t) { const e = this.options.grid, s = this.ctx, i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t)); let o, a; const r = (l, c, d) => { !d.width || !d.color || (s.save(), s.lineWidth = d.width, s.strokeStyle = d.color, s.setLineDash(d.borderDash || []), s.lineDashOffset = d.borderDashOffset, s.beginPath(), s.moveTo(l.x, l.y), s.lineTo(c.x, c.y), s.stroke(), s.restore()) }; if (e.display) for (o = 0, a = i.length; o < a; ++o) { const l = i[o]; e.drawOnChartArea && r({ x: l.x1, y: l.y1 }, { x: l.x2, y: l.y2 }, l), e.drawTicks && r({ x: l.tx1, y: l.ty1 }, { x: l.tx2, y: l.ty2 }, { color: l.tickColor, width: l.tickWidth, borderDash: l.tickBorderDash, borderDashOffset: l.tickBorderDashOffset }) } } drawBorder () { const { chart: t, ctx: e, options: { border: s, grid: i } } = this, o = s.setContext(this.getContext()), a = s.display ? o.width : 0; if (!a) return; const r = i.setContext(this.getContext(0)).lineWidth, l = this._borderValue; let c, d, u, h; this.isHorizontal() ? (c = Ye(t, this.left, a) - a / 2, d = Ye(t, this.right, r) + r / 2, u = h = l) : (u = Ye(t, this.top, a) - a / 2, h = Ye(t, this.bottom, r) + r / 2, c = d = l), e.save(), e.lineWidth = o.width, e.strokeStyle = o.color, e.beginPath(), e.moveTo(c, u), e.lineTo(d, h), e.stroke(), e.restore() } drawLabels (t) { if (!this.options.ticks.display) return; const s = this.ctx, i = this._computeLabelArea(); i && xi(s, i); const o = this.getLabelItems(t); for (const a of o) { const r = a.options, l = a.font, c = a.label, d = a.textOffset; dn(s, c, 0, d, l, r) } i && wi(s) } drawTitle () { const { ctx: t, options: { position: e, title: s, reverse: i } } = this; if (!s.display) return; const o = At(s.font), a = Ht(s.padding), r = s.align; let l = o.lineHeight / 2; e === "bottom" || e === "center" || ot(e) ? (l += a.bottom, yt(s.text) && (l += o.lineHeight * (s.text.length - 1))) : l += a.top; const { titleX: c, titleY: d, maxWidth: u, rotation: h } = x0(this, l, e, r); dn(t, s.text, 0, 0, o, { color: s.color, maxWidth: u, rotation: h, textAlign: y0(r, e, i), textBaseline: "middle", translation: [c, d] }) } draw (t) { this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t)) } _layers () { const t = this.options, e = t.ticks && t.ticks.z || 0, s = tt(t.grid && t.grid.z, -1), i = tt(t.border && t.border.z, 0); return !this._isVisible() || this.draw !== un.prototype.draw ? [{ z: e, draw: o => { this.draw(o) } }] : [{ z: s, draw: o => { this.drawBackground(), this.drawGrid(o), this.drawTitle() } }, { z: i, draw: () => { this.drawBorder() } }, { z: e, draw: o => { this.drawLabels(o) } }] } getMatchingVisibleMetas (t) { const e = this.chart.getSortedVisibleDatasetMetas(), s = this.axis + "AxisID", i = []; let o, a; for (o = 0, a = e.length; o < a; ++o) { const r = e[o]; r[s] === this.id && (!t || r.type === t) && i.push(r) } return i } _resolveTickFontOptions (t) { const e = this.options.ticks.setContext(this.getContext(t)); return At(e.font) } _maxDigits () { const t = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / t } } class Ms { constructor(t, e, s) { this.type = t, this.scope = e, this.override = s, this.items = Object.create(null) } isForType (t) { return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype) } register (t) { const e = Object.getPrototypeOf(t); let s; S0(e) && (s = this.register(e)); const i = this.items, o = t.id, a = this.scope + "." + o; if (!o) throw new Error("class does not have id: " + t); return o in i || (i[o] = t, w0(t, a, s), this.override && Pt.override(t.id, t.overrides)), a } get (t) { return this.items[t] } unregister (t) { const e = this.items, s = t.id, i = this.scope; s in e && delete e[s], i && s in Pt[i] && (delete Pt[i][s], this.override && delete cn[s]) } } function w0 (n, t, e) { const s = Zn(Object.create(null), [e ? Pt.get(e) : {}, Pt.get(t), n.defaults]); Pt.set(t, s), n.defaultRoutes && k0(t, n.defaultRoutes), n.descriptors && Pt.describe(t, n.descriptors) } function k0 (n, t) { Object.keys(t).forEach(e => { const s = e.split("."), i = s.pop(), o = [n].concat(s).join("."), a = t[e].split("."), r = a.pop(), l = a.join("."); Pt.route(o, i, l, r) }) } function S0 (n) { return "id" in n && "defaults" in n } class M0 { constructor() { this.controllers = new Ms(le, "datasets", !0), this.elements = new Ms(Pe, "elements"), this.plugins = new Ms(Object, "plugins"), this.scales = new Ms(un, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add (...t) { this._each("register", t) } remove (...t) { this._each("unregister", t) } addControllers (...t) { this._each("register", t, this.controllers) } addElements (...t) { this._each("register", t, this.elements) } addPlugins (...t) { this._each("register", t, this.plugins) } addScales (...t) { this._each("register", t, this.scales) } getController (t) { return this._get(t, this.controllers, "controller") } getElement (t) { return this._get(t, this.elements, "element") } getPlugin (t) { return this._get(t, this.plugins, "plugin") } getScale (t) { return this._get(t, this.scales, "scale") } removeControllers (...t) { this._each("unregister", t, this.controllers) } removeElements (...t) { this._each("unregister", t, this.elements) } removePlugins (...t) { this._each("unregister", t, this.plugins) } removeScales (...t) { this._each("unregister", t, this.scales) } _each (t, e, s) { [...e].forEach(i => { const o = s || this._getRegistryForType(i); s || o.isForType(i) || o === this.plugins && i.id ? this._exec(t, o, i) : ut(i, a => { const r = s || this._getRegistryForType(a); this._exec(t, r, a) }) }) } _exec (t, e, s) { const i = Wo(t); pt(s["before" + i], [], s), e[t](s), pt(s["after" + i], [], s) } _getRegistryForType (t) { for (let e = 0; e < this._typedRegistries.length; e++) { const s = this._typedRegistries[e]; if (s.isForType(t)) return s } return this.plugins } _get (t, e, s) { const i = e.get(t); if (i === void 0) throw new Error('"' + t + '" is not a registered ' + s + "."); return i } } var de = new M0; class P0 { constructor() { this._init = [] } notify (t, e, s, i) { e === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install")); const o = i ? this._descriptors(t).filter(i) : this._descriptors(t), a = this._notify(o, t, e, s); return e === "afterDestroy" && (this._notify(o, t, "stop"), this._notify(this._init, t, "uninstall")), a } _notify (t, e, s, i) { i = i || {}; for (const o of t) { const a = o.plugin, r = a[s], l = [e, i, o.options]; if (pt(r, l, a) === !1 && i.cancelable) return !1 } return !0 } invalidate () { at(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors (t) { if (this._cache) return this._cache; const e = this._cache = this._createDescriptors(t); return this._notifyStateChanges(t), e } _createDescriptors (t, e) { const s = t && t.config, i = tt(s.options && s.options.plugins, {}), o = C0(s); return i === !1 && !e ? [] : O0(t, o, i, e) } _notifyStateChanges (t) { const e = this._oldCache || [], s = this._cache, i = (o, a) => o.filter(r => !a.some(l => r.plugin.id === l.plugin.id)); this._notify(i(e, s), t, "stop"), this._notify(i(s, e), t, "start") } } function C0 (n) { const t = {}, e = [], s = Object.keys(de.plugins.items); for (let o = 0; o < s.length; o++)e.push(de.getPlugin(s[o])); const i = n.plugins || []; for (let o = 0; o < i.length; o++) { const a = i[o]; e.indexOf(a) === -1 && (e.push(a), t[a.id] = !0) } return { plugins: e, localIds: t } } function T0 (n, t) { return !t && n === !1 ? null : n === !0 ? {} : n } function O0 (n, { plugins: t, localIds: e }, s, i) { const o = [], a = n.getContext(); for (const r of t) { const l = r.id, c = T0(s[l], i); c !== null && o.push({ plugin: r, options: L0(n.config, { plugin: r, local: e[l] }, c, a) }) } return o } function L0 (n, { plugin: t, local: e }, s, i) { const o = n.pluginScopeKeys(t), a = n.getOptionScopes(s, o); return e && t.defaults && a.push(t.defaults), n.createResolver(a, i, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function vo (n, t) { const e = Pt.datasets[n] || {}; return ((t.datasets || {})[n] || {}).indexAxis || t.indexAxis || e.indexAxis || "x" } function A0 (n, t) { let e = n; return n === "_index_" ? e = t : n === "_value_" && (e = t === "x" ? "y" : "x"), e } function $0 (n, t) { return n === t ? "_index_" : "_value_" } function Mr (n) { if (n === "x" || n === "y" || n === "r") return n } function D0 (n) { if (n === "top" || n === "bottom") return "x"; if (n === "left" || n === "right") return "y" } function _o (n, ...t) { if (Mr(n)) return n; for (const e of t) { const s = e.axis || D0(e.position) || n.length > 1 && Mr(n[0].toLowerCase()); if (s) return s } throw new Error(`Cannot determine type of '${n}' axis. Please provide 'axis' or 'position' option.`) } function Pr (n, t, e) { if (e[t + "AxisID"] === n) return { axis: t } } function E0 (n, t) { if (t.data && t.data.datasets) { const e = t.data.datasets.filter(s => s.xAxisID === n || s.yAxisID === n); if (e.length) return Pr(n, "x", e[0]) || Pr(n, "y", e[0]) } return {} } function R0 (n, t) { const e = cn[n.type] || { scales: {} }, s = t.scales || {}, i = vo(n.type, t), o = Object.create(null); return Object.keys(s).forEach(a => { const r = s[a]; if (!ot(r)) return console.error(`Invalid scale configuration for scale: ${a}`); if (r._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${a}`); const l = _o(a, r, E0(a, n), Pt.scales[r.type]), c = $0(l, i), d = e.scales || {}; o[a] = Wn(Object.create(null), [{ axis: l }, r, d[l], d[c]]) }), n.data.datasets.forEach(a => { const r = a.type || n.type, l = a.indexAxis || vo(r, t), d = (cn[r] || {}).scales || {}; Object.keys(d).forEach(u => { const h = A0(u, l), f = a[h + "AxisID"] || h; o[f] = o[f] || Object.create(null), Wn(o[f], [{ axis: h }, s[f], d[u]]) }) }), Object.keys(o).forEach(a => { const r = o[a]; Wn(r, [Pt.scales[r.type], Pt.scale]) }), o } function Ac (n) { const t = n.options || (n.options = {}); t.plugins = tt(t.plugins, {}), t.scales = R0(n, t) } function $c (n) { return n = n || {}, n.datasets = n.datasets || [], n.labels = n.labels || [], n } function I0 (n) { return n = n || {}, n.data = $c(n.data), Ac(n), n } const Cr = new Map, Dc = new Set; function Ps (n, t) { let e = Cr.get(n); return e || (e = t(), Cr.set(n, e), Dc.add(e)), e } const $n = (n, t, e) => { const s = je(t, e); s !== void 0 && n.add(s) }; class N0 { constructor(t) { this._config = I0(t), this._scopeCache = new Map, this._resolverCache = new Map } get platform () { return this._config.platform } get type () { return this._config.type } set type (t) { this._config.type = t } get data () { return this._config.data } set data (t) { this._config.data = $c(t) } get options () { return this._config.options } set options (t) { this._config.options = t } get plugins () { return this._config.plugins } update () { const t = this._config; this.clearCache(), Ac(t) } clearCache () { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys (t) { return Ps(t, () => [[`datasets.${t}`, ""]]) } datasetAnimationScopeKeys (t, e) { return Ps(`${t}.transition.${e}`, () => [[`datasets.${t}.transitions.${e}`, `transitions.${e}`], [`datasets.${t}`, ""]]) } datasetElementScopeKeys (t, e) { return Ps(`${t}-${e}`, () => [[`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]]) } pluginScopeKeys (t) { const e = t.id, s = this.type; return Ps(`${s}-plugin-${e}`, () => [[`plugins.${e}`, ...t.additionalOptionScopes || []]]) } _cachedScopes (t, e) { const s = this._scopeCache; let i = s.get(t); return (!i || e) && (i = new Map, s.set(t, i)), i } getOptionScopes (t, e, s) { const { options: i, type: o } = this, a = this._cachedScopes(t, s), r = a.get(e); if (r) return r; const l = new Set; e.forEach(d => { t && (l.add(t), d.forEach(u => $n(l, t, u))), d.forEach(u => $n(l, i, u)), d.forEach(u => $n(l, cn[o] || {}, u)), d.forEach(u => $n(l, Pt, u)), d.forEach(u => $n(l, go, u)) }); const c = Array.from(l); return c.length === 0 && c.push(Object.create(null)), Dc.has(e) && a.set(e, c), c } chartOptionScopes () { const { options: t, type: e } = this; return [t, cn[e] || {}, Pt.datasets[e] || {}, { type: e }, Pt, go] } resolveNamedOptions (t, e, s, i = [""]) { const o = { $shared: !0 }, { resolver: a, subPrefixes: r } = Tr(this._resolverCache, t, i); let l = a; if (V0(a, e)) { o.$shared = !1, s = He(s) ? s() : s; const c = this.createResolver(t, s, r); l = Sn(a, s, c) } for (const c of e) o[c] = l[c]; return o } createResolver (t, e, s = [""], i) { const { resolver: o } = Tr(this._resolverCache, t, s); return ot(e) ? Sn(o, e, void 0, i) : o } } function Tr (n, t, e) { let s = n.get(t); s || (s = new Map, n.set(t, s)); const i = e.join(); let o = s.get(i); return o || (o = { resolver: Go(t, e), subPrefixes: e.filter(r => !r.toLowerCase().includes("hover")) }, s.set(i, o)), o } const F0 = n => ot(n) && Object.getOwnPropertyNames(n).some(t => He(n[t])); function V0 (n, t) { const { isScriptable: e, isIndexable: s } = hc(n); for (const i of t) { const o = e(i), a = s(i), r = (a || o) && n[i]; if (o && (He(r) || F0(r)) || a && yt(r)) return !0 } return !1 } var B0 = "4.4.3"; const z0 = ["top", "bottom", "left", "right", "chartArea"]; function Or (n, t) { return n === "top" || n === "bottom" || z0.indexOf(n) === -1 && t === "x" } function Lr (n, t) { return function (e, s) { return e[n] === s[n] ? e[t] - s[t] : e[n] - s[n] } } function Ar (n) { const t = n.chart, e = t.options.animation; t.notifyPlugins("afterRender"), pt(e && e.onComplete, [n], t) } function j0 (n) { const t = n.chart, e = t.options.animation; pt(e && e.onProgress, [n], t) } function Ec (n) { return Zo() && typeof n == "string" ? n = document.getElementById(n) : n && n.length && (n = n[0]), n && n.canvas && (n = n.canvas), n } const Bs = {}, $r = n => { const t = Ec(n); return Object.values(Bs).filter(e => e.canvas === t).pop() }; function H0 (n, t, e) { const s = Object.keys(n); for (const i of s) { const o = +i; if (o >= t) { const a = n[i]; delete n[i], (e > 0 || o > t) && (n[o + e] = a) } } } function W0 (n, t, e, s) { return !e || n.type === "mouseout" ? null : s ? t : n } function Cs (n, t, e) { return n.options.clip ? n[e] : t[e] } function U0 (n, t) { const { xScale: e, yScale: s } = n; return e && s ? { left: Cs(e, t, "left"), right: Cs(e, t, "right"), top: Cs(s, t, "top"), bottom: Cs(s, t, "bottom") } : t } class ye { static register (...t) { de.add(...t), Dr() } static unregister (...t) { de.remove(...t), Dr() } constructor(t, e) { const s = this.config = new N0(e), i = Ec(t), o = $r(i); if (o) throw new Error("Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused."); const a = s.createResolver(s.chartOptionScopes(), this.getContext()); this.platform = new (s.platform || l0(i)), this.platform.updateConfig(s); const r = this.platform.acquireContext(i, a.aspectRatio), l = r && r.canvas, c = l && l.height, d = l && l.width; if (this.id = Kp(), this.ctx = r, this.canvas = l, this.width = d, this.height = c, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new P0, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = cg(u => this.update(u), a.resizeDelay || 0), this._dataChanges = [], Bs[this.id] = this, !r || !l) { console.error("Failed to create chart: can't acquire context from the given item"); return } be.listen(this, "complete", Ar), be.listen(this, "progress", j0), this._initialize(), this.attached && this.update() } get aspectRatio () { const { options: { aspectRatio: t, maintainAspectRatio: e }, width: s, height: i, _aspectRatio: o } = this; return at(t) ? e && o ? o : i ? s / i : null : t } get data () { return this.config.data } set data (t) { this.config.data = t } get options () { return this._options } set options (t) { this.config.options = t } get registry () { return de } _initialize () { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : tr(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear () { return Ja(this.canvas, this.ctx), this } stop () { return be.stop(this), this } resize (t, e) { be.running(this) ? this._resizeBeforeDraw = { width: t, height: e } : this._resize(t, e) } _resize (t, e) { const s = this.options, i = this.canvas, o = s.maintainAspectRatio && this.aspectRatio, a = this.platform.getMaximumSize(i, t, e, o), r = s.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach"; this.width = a.width, this.height = a.height, this._aspectRatio = this.aspectRatio, tr(this, r, !0) && (this.notifyPlugins("resize", { size: a }), pt(s.onResize, [this, a], this), this.attached && this._doResize(l) && this.render()) } ensureScalesHaveIDs () { const e = this.options.scales || {}; ut(e, (s, i) => { s.id = i }) } buildOrUpdateScales () { const t = this.options, e = t.scales, s = this.scales, i = Object.keys(s).reduce((a, r) => (a[r] = !1, a), {}); let o = []; e && (o = o.concat(Object.keys(e).map(a => { const r = e[a], l = _o(a, r), c = l === "r", d = l === "x"; return { options: r, dposition: c ? "chartArea" : d ? "bottom" : "left", dtype: c ? "radialLinear" : d ? "category" : "linear" } }))), ut(o, a => { const r = a.options, l = r.id, c = _o(l, r), d = tt(r.type, a.dtype); (r.position === void 0 || Or(r.position, c) !== Or(a.dposition)) && (r.position = a.dposition), i[l] = !0; let u = null; if (l in s && s[l].type === d) u = s[l]; else { const h = de.getScale(d); u = new h({ id: l, type: d, ctx: this.ctx, chart: this }), s[u.id] = u } u.init(r, t) }), ut(i, (a, r) => { a || delete s[r] }), ut(s, a => { jt.configure(this, a, a.options), jt.addBox(this, a) }) } _updateMetasets () { const t = this._metasets, e = this.data.datasets.length, s = t.length; if (t.sort((i, o) => i.index - o.index), s > e) { for (let i = e; i < s; ++i)this._destroyDatasetMeta(i); t.splice(e, s - e) } this._sortedMetasets = t.slice(0).sort(Lr("order", "index")) } _removeUnreferencedMetasets () { const { _metasets: t, data: { datasets: e } } = this; t.length > e.length && delete this._stacks, t.forEach((s, i) => { e.filter(o => o === s._dataset).length === 0 && this._destroyDatasetMeta(i) }) } buildOrUpdateControllers () { const t = [], e = this.data.datasets; let s, i; for (this._removeUnreferencedMetasets(), s = 0, i = e.length; s < i; s++) { const o = e[s]; let a = this.getDatasetMeta(s); const r = o.type || this.config.type; if (a.type && a.type !== r && (this._destroyDatasetMeta(s), a = this.getDatasetMeta(s)), a.type = r, a.indexAxis = o.indexAxis || vo(r, this.options), a.order = o.order || 0, a.index = s, a.label = "" + o.label, a.visible = this.isDatasetVisible(s), a.controller) a.controller.updateIndex(s), a.controller.linkScales(); else { const l = de.getController(r), { datasetElementType: c, dataElementType: d } = Pt.datasets[r]; Object.assign(l, { dataElementType: de.getElement(d), datasetElementType: c && de.getElement(c) }), a.controller = new l(this, s), t.push(a.controller) } } return this._updateMetasets(), t } _resetElements () { ut(this.data.datasets, (t, e) => { this.getDatasetMeta(e).controller.reset() }, this) } reset () { this._resetElements(), this.notifyPlugins("reset") } update (t) { const e = this.config; e.update(); const s = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), i = this._animationsDisabled = !s.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", { mode: t, cancelable: !0 }) === !1) return; const o = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let a = 0; for (let c = 0, d = this.data.datasets.length; c < d; c++) { const { controller: u } = this.getDatasetMeta(c), h = !i && o.indexOf(u) === -1; u.buildOrUpdateElements(h), a = Math.max(+u.getMaxOverflow(), a) } a = this._minPadding = s.layout.autoPadding ? a : 0, this._updateLayout(a), i || ut(o, c => { c.reset() }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", { mode: t }), this._layers.sort(Lr("z", "_idx")); const { _active: r, _lastEvent: l } = this; l ? this._eventHandler(l, !0) : r.length && this._updateHoverStyles(r, r, !0), this.render() } _updateScales () { ut(this.scales, t => { jt.removeBox(this, t) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings () { const t = this.options, e = new Set(Object.keys(this._listeners)), s = new Set(t.events); (!ja(e, s) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices () { const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || []; for (const { method: s, start: i, count: o } of e) { const a = s === "_removeElements" ? -o : o; H0(t, i, a) } } _getUniformDataChanges () { const t = this._dataChanges; if (!t || !t.length) return; this._dataChanges = []; const e = this.data.datasets.length, s = o => new Set(t.filter(a => a[0] === o).map((a, r) => r + "," + a.splice(1).join(","))), i = s(0); for (let o = 1; o < e; o++)if (!ja(i, s(o))) return; return Array.from(i).map(o => o.split(",")).map(o => ({ method: o[1], start: +o[2], count: +o[3] })) } _updateLayout (t) { if (this.notifyPlugins("beforeLayout", { cancelable: !0 }) === !1) return; jt.update(this, this.width, this.height, t); const e = this.chartArea, s = e.width <= 0 || e.height <= 0; this._layers = [], ut(this.boxes, i => { s && i.position === "chartArea" || (i.configure && i.configure(), this._layers.push(...i._layers())) }, this), this._layers.forEach((i, o) => { i._idx = o }), this.notifyPlugins("afterLayout") } _updateDatasets (t) { if (this.notifyPlugins("beforeDatasetsUpdate", { mode: t, cancelable: !0 }) !== !1) { for (let e = 0, s = this.data.datasets.length; e < s; ++e)this.getDatasetMeta(e).controller.configure(); for (let e = 0, s = this.data.datasets.length; e < s; ++e)this._updateDataset(e, He(t) ? t({ datasetIndex: e }) : t); this.notifyPlugins("afterDatasetsUpdate", { mode: t }) } } _updateDataset (t, e) { const s = this.getDatasetMeta(t), i = { meta: s, index: t, mode: e, cancelable: !0 }; this.notifyPlugins("beforeDatasetUpdate", i) !== !1 && (s.controller._update(e), i.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", i)) } render () { this.notifyPlugins("beforeRender", { cancelable: !0 }) !== !1 && (be.has(this) ? this.attached && !be.running(this) && be.start(this) : (this.draw(), Ar({ chart: this }))) } draw () { let t; if (this._resizeBeforeDraw) { const { width: s, height: i } = this._resizeBeforeDraw; this._resize(s, i), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", { cancelable: !0 }) === !1) return; const e = this._layers; for (t = 0; t < e.length && e[t].z <= 0; ++t)e[t].draw(this.chartArea); for (this._drawDatasets(); t < e.length; ++t)e[t].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas (t) { const e = this._sortedMetasets, s = []; let i, o; for (i = 0, o = e.length; i < o; ++i) { const a = e[i]; (!t || a.visible) && s.push(a) } return s } getSortedVisibleDatasetMetas () { return this._getSortedDatasetMetas(!0) } _drawDatasets () { if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 }) === !1) return; const t = this.getSortedVisibleDatasetMetas(); for (let e = t.length - 1; e >= 0; --e)this._drawDataset(t[e]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset (t) { const e = this.ctx, s = t._clip, i = !s.disabled, o = U0(t, this.chartArea), a = { meta: t, index: t.index, cancelable: !0 }; this.notifyPlugins("beforeDatasetDraw", a) !== !1 && (i && xi(e, { left: s.left === !1 ? 0 : o.left - s.left, right: s.right === !1 ? this.width : o.right + s.right, top: s.top === !1 ? 0 : o.top - s.top, bottom: s.bottom === !1 ? this.height : o.bottom + s.bottom }), t.controller.draw(), i && wi(e), a.cancelable = !1, this.notifyPlugins("afterDatasetDraw", a)) } isPointInArea (t) { return ke(t, this.chartArea, this._minPadding) } getElementsAtEventForMode (t, e, s, i) { const o = zm.modes[e]; return typeof o == "function" ? o(this, t, s, i) : [] } getDatasetMeta (t) { const e = this.data.datasets[t], s = this._metasets; let i = s.filter(o => o && o._dataset === e).pop(); return i || (i = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e && e.order || 0, index: t, _dataset: e, _parsed: [], _sorted: !1 }, s.push(i)), i } getContext () { return this.$context || (this.$context = We(null, { chart: this, type: "chart" })) } getVisibleDatasetCount () { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible (t) { const e = this.data.datasets[t]; if (!e) return !1; const s = this.getDatasetMeta(t); return typeof s.hidden == "boolean" ? !s.hidden : !e.hidden } setDatasetVisibility (t, e) { const s = this.getDatasetMeta(t); s.hidden = !e } toggleDataVisibility (t) { this._hiddenIndices[t] = !this._hiddenIndices[t] } getDataVisibility (t) { return !this._hiddenIndices[t] } _updateVisibility (t, e, s) { const i = s ? "show" : "hide", o = this.getDatasetMeta(t), a = o.controller._resolveAnimations(void 0, i); ts(e) ? (o.data[e].hidden = !s, this.update()) : (this.setDatasetVisibility(t, s), a.update(o, { visible: s }), this.update(r => r.datasetIndex === t ? i : void 0)) } hide (t, e) { this._updateVisibility(t, e, !1) } show (t, e) { this._updateVisibility(t, e, !0) } _destroyDatasetMeta (t) { const e = this._metasets[t]; e && e.controller && e.controller._destroy(), delete this._metasets[t] } _stop () { let t, e; for (this.stop(), be.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)this._destroyDatasetMeta(t) } destroy () { this.notifyPlugins("beforeDestroy"); const { canvas: t, ctx: e } = this; this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Ja(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Bs[this.id], this.notifyPlugins("afterDestroy") } toBase64Image (...t) { return this.canvas.toDataURL(...t) } bindEvents () { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents () { const t = this._listeners, e = this.platform, s = (o, a) => { e.addEventListener(this, o, a), t[o] = a }, i = (o, a, r) => { o.offsetX = a, o.offsetY = r, this._eventHandler(o) }; ut(this.options.events, o => s(o, i)) } bindResponsiveEvents () { this._responsiveListeners || (this._responsiveListeners = {}); const t = this._responsiveListeners, e = this.platform, s = (l, c) => { e.addEventListener(this, l, c), t[l] = c }, i = (l, c) => { t[l] && (e.removeEventListener(this, l, c), delete t[l]) }, o = (l, c) => { this.canvas && this.resize(l, c) }; let a; const r = () => { i("attach", r), this.attached = !0, this.resize(), s("resize", o), s("detach", a) }; a = () => { this.attached = !1, i("resize", o), this._stop(), this._resize(0, 0), s("attach", r) }, e.isAttached(this.canvas) ? r() : a() } unbindEvents () { ut(this._listeners, (t, e) => { this.platform.removeEventListener(this, e, t) }), this._listeners = {}, ut(this._responsiveListeners, (t, e) => { this.platform.removeEventListener(this, e, t) }), this._responsiveListeners = void 0 } updateHoverStyle (t, e, s) { const i = s ? "set" : "remove"; let o, a, r, l; for (e === "dataset" && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller["_" + i + "DatasetHoverStyle"]()), r = 0, l = t.length; r < l; ++r) { a = t[r]; const c = a && this.getDatasetMeta(a.datasetIndex).controller; c && c[i + "HoverStyle"](a.element, a.datasetIndex, a.index) } } getActiveElements () { return this._active || [] } setActiveElements (t) { const e = this._active || [], s = t.map(({ datasetIndex: o, index: a }) => { const r = this.getDatasetMeta(o); if (!r) throw new Error("No dataset found at index " + o); return { datasetIndex: o, element: r.data[a], index: a } }); !Zs(s, e) && (this._active = s, this._lastEvent = null, this._updateHoverStyles(s, e)) } notifyPlugins (t, e, s) { return this._plugins.notify(this, t, e, s) } isPluginEnabled (t) { return this._plugins._cache.filter(e => e.plugin.id === t).length === 1 } _updateHoverStyles (t, e, s) { const i = this.options.hover, o = (l, c) => l.filter(d => !c.some(u => d.datasetIndex === u.datasetIndex && d.index === u.index)), a = o(e, t), r = s ? t : o(t, e); a.length && this.updateHoverStyle(a, i.mode, !1), r.length && i.mode && this.updateHoverStyle(r, i.mode, !0) } _eventHandler (t, e) { const s = { event: t, replay: e, cancelable: !0, inChartArea: this.isPointInArea(t) }, i = a => (a.options.events || this.options.events).includes(t.native.type); if (this.notifyPlugins("beforeEvent", s, i) === !1) return; const o = this._handleEvent(t, e, s.inChartArea); return s.cancelable = !1, this.notifyPlugins("afterEvent", s, i), (o || s.changed) && this.render(), this } _handleEvent (t, e, s) { const { _active: i = [], options: o } = this, a = e, r = this._getActiveElements(t, i, s, a), l = Zp(t), c = W0(t, this._lastEvent, s, l); s && (this._lastEvent = null, pt(o.onHover, [t, r, this], this), l && pt(o.onClick, [t, r, this], this)); const d = !Zs(r, i); return (d || e) && (this._active = r, this._updateHoverStyles(r, i, e)), this._lastEvent = c, d } _getActiveElements (t, e, s, i) { if (t.type === "mouseout") return []; if (!s) return e; const o = this.options.hover; return this.getElementsAtEventForMode(t, o.mode, o, i) } } V(ye, "defaults", Pt), V(ye, "instances", Bs), V(ye, "overrides", cn), V(ye, "registry", de), V(ye, "version", B0), V(ye, "getChart", $r); function Dr () { return ut(ye.instances, n => n._plugins.invalidate()) } function Y0 (n, t, e) { const { startAngle: s, pixelMargin: i, x: o, y: a, outerRadius: r, innerRadius: l } = t; let c = i / r; n.beginPath(), n.arc(o, a, r, s - c, e + c), l > i ? (c = i / l, n.arc(o, a, l, e + c, s - c, !0)) : n.arc(o, a, i, e + Ct, s - Ct), n.closePath(), n.clip() } function K0 (n) { return Xo(n, ["outerStart", "outerEnd", "innerStart", "innerEnd"]) } function q0 (n, t, e, s) { const i = K0(n.options.borderRadius), o = (e - t) / 2, a = Math.min(o, s * t / 2), r = l => { const c = (e - Math.min(o, l)) * s / 2; return Dt(l, 0, Math.min(o, c)) }; return { outerStart: r(i.outerStart), outerEnd: r(i.outerEnd), innerStart: Dt(i.innerStart, 0, a), innerEnd: Dt(i.innerEnd, 0, a) } } function mn (n, t, e, s) { return { x: e + n * Math.cos(t), y: s + n * Math.sin(t) } } function oi (n, t, e, s, i, o) { const { x: a, y: r, startAngle: l, pixelMargin: c, innerRadius: d } = t, u = Math.max(t.outerRadius + s + e - c, 0), h = d > 0 ? d + s + e + c : 0; let f = 0; const g = i - l; if (s) { const E = d > 0 ? d - s : 0, B = u > 0 ? u - s : 0, F = (E + B) / 2, G = F !== 0 ? g * F / (F + s) : g; f = (g - G) / 2 } const m = Math.max(.001, g * u - e / mt) / u, v = (g - m) / 2, p = l + v + f, b = i - v - f, { outerStart: y, outerEnd: k, innerStart: w, innerEnd: L } = q0(t, h, u, b - p), A = u - y, x = u - k, S = p + y / A, C = b - k / x, T = h + w, R = h + L, I = p + w / T, H = b - L / R; if (n.beginPath(), o) { const E = (S + C) / 2; if (n.arc(a, r, u, S, E), n.arc(a, r, u, E, C), k > 0) { const nt = mn(x, C, a, r); n.arc(nt.x, nt.y, k, C, b + Ct) } const B = mn(R, b, a, r); if (n.lineTo(B.x, B.y), L > 0) { const nt = mn(R, H, a, r); n.arc(nt.x, nt.y, L, b + Ct, H + Math.PI) } const F = (b - L / h + (p + w / h)) / 2; if (n.arc(a, r, h, b - L / h, F, !0), n.arc(a, r, h, F, p + w / h, !0), w > 0) { const nt = mn(T, I, a, r); n.arc(nt.x, nt.y, w, I + Math.PI, p - Ct) } const G = mn(A, p, a, r); if (n.lineTo(G.x, G.y), y > 0) { const nt = mn(A, S, a, r); n.arc(nt.x, nt.y, y, p - Ct, S) } } else { n.moveTo(a, r); const E = Math.cos(S) * u + a, B = Math.sin(S) * u + r; n.lineTo(E, B); const F = Math.cos(C) * u + a, G = Math.sin(C) * u + r; n.lineTo(F, G) } n.closePath() } function X0 (n, t, e, s, i) { const { fullCircles: o, startAngle: a, circumference: r } = t; let l = t.endAngle; if (o) { oi(n, t, e, s, l, i); for (let c = 0; c < o; ++c)n.fill(); isNaN(r) || (l = a + (r % gt || gt)) } return oi(n, t, e, s, l, i), n.fill(), l } function G0 (n, t, e, s, i) { const { fullCircles: o, startAngle: a, circumference: r, options: l } = t, { borderWidth: c, borderJoinStyle: d, borderDash: u, borderDashOffset: h } = l, f = l.borderAlign === "inner"; if (!c) return; n.setLineDash(u || []), n.lineDashOffset = h, f ? (n.lineWidth = c * 2, n.lineJoin = d || "round") : (n.lineWidth = c, n.lineJoin = d || "bevel"); let g = t.endAngle; if (o) { oi(n, t, e, s, g, i); for (let m = 0; m < o; ++m)n.stroke(); isNaN(r) || (g = a + (r % gt || gt)) } f && Y0(n, t, g), o || (oi(n, t, e, s, g, i), n.stroke()) } class Fn extends Pe { constructor(e) { super(); V(this, "circumference"); V(this, "endAngle"); V(this, "fullCircles"); V(this, "innerRadius"); V(this, "outerRadius"); V(this, "pixelMargin"); V(this, "startAngle"); this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, e && Object.assign(this, e) } inRange (e, s, i) { const o = this.getProps(["x", "y"], i), { angle: a, distance: r } = nc(o, { x: e, y: s }), { startAngle: l, endAngle: c, innerRadius: d, outerRadius: u, circumference: h } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i), f = (this.options.spacing + this.options.borderWidth) / 2, m = tt(h, c - l) >= gt || es(a, l, c), v = xe(r, d + f, u + f); return m && v } getCenterPoint (e) { const { x: s, y: i, startAngle: o, endAngle: a, innerRadius: r, outerRadius: l } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], e), { offset: c, spacing: d } = this.options, u = (o + a) / 2, h = (r + l + d + c) / 2; return { x: s + Math.cos(u) * h, y: i + Math.sin(u) * h } } tooltipPosition (e) { return this.getCenterPoint(e) } draw (e) { const { options: s, circumference: i } = this, o = (s.offset || 0) / 4, a = (s.spacing || 0) / 2, r = s.circular; if (this.pixelMargin = s.borderAlign === "inner" ? .33 : 0, this.fullCircles = i > gt ? Math.floor(i / gt) : 0, i === 0 || this.innerRadius < 0 || this.outerRadius < 0) return; e.save(); const l = (this.startAngle + this.endAngle) / 2; e.translate(Math.cos(l) * o, Math.sin(l) * o); const c = 1 - Math.sin(Math.min(mt, i || 0)), d = o * c; e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, X0(e, this, d, a, r), G0(e, this, d, a, r), e.restore() } } V(Fn, "id", "arc"), V(Fn, "defaults", { borderAlign: "center", borderColor: "#fff", borderDash: [], borderDashOffset: 0, borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0, circular: !0 }), V(Fn, "defaultRoutes", { backgroundColor: "backgroundColor" }), V(Fn, "descriptors", { _scriptable: !0, _indexable: e => e !== "borderDash" }); function Rc (n, t, e = t) { n.lineCap = tt(e.borderCapStyle, t.borderCapStyle), n.setLineDash(tt(e.borderDash, t.borderDash)), n.lineDashOffset = tt(e.borderDashOffset, t.borderDashOffset), n.lineJoin = tt(e.borderJoinStyle, t.borderJoinStyle), n.lineWidth = tt(e.borderWidth, t.borderWidth), n.strokeStyle = tt(e.borderColor, t.borderColor) } function J0 (n, t, e) { n.lineTo(e.x, e.y) } function Q0 (n) { return n.stepped ? xg : n.tension || n.cubicInterpolationMode === "monotone" ? wg : J0 } function Ic (n, t, e = {}) { const s = n.length, { start: i = 0, end: o = s - 1 } = e, { start: a, end: r } = t, l = Math.max(i, a), c = Math.min(o, r), d = i < a && o < a || i > r && o > r; return { count: s, start: l, loop: t.loop, ilen: c < l && !d ? s + c - l : c - l } } function Z0 (n, t, e, s) { const { points: i, options: o } = t, { count: a, start: r, loop: l, ilen: c } = Ic(i, e, s), d = Q0(o); let { move: u = !0, reverse: h } = s || {}, f, g, m; for (f = 0; f <= c; ++f)g = i[(r + (h ? c - f : f)) % a], !g.skip && (u ? (n.moveTo(g.x, g.y), u = !1) : d(n, m, g, h, o.stepped), m = g); return l && (g = i[(r + (h ? c : 0)) % a], d(n, m, g, h, o.stepped)), !!l } function tb (n, t, e, s) { const i = t.points, { count: o, start: a, ilen: r } = Ic(i, e, s), { move: l = !0, reverse: c } = s || {}; let d = 0, u = 0, h, f, g, m, v, p; const b = k => (a + (c ? r - k : k)) % o, y = () => { m !== v && (n.lineTo(d, v), n.lineTo(d, m), n.lineTo(d, p)) }; for (l && (f = i[b(0)], n.moveTo(f.x, f.y)), h = 0; h <= r; ++h) { if (f = i[b(h)], f.skip) continue; const k = f.x, w = f.y, L = k | 0; L === g ? (w < m ? m = w : w > v && (v = w), d = (u * d + k) / ++u) : (y(), n.lineTo(k, w), g = L, u = 0, m = v = w), p = w } y() } function yo (n) { const t = n.options, e = t.borderDash && t.borderDash.length; return !n._decimated && !n._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !e ? tb : Z0 } function eb (n) { return n.stepped ? tm : n.tension || n.cubicInterpolationMode === "monotone" ? em : Qe } function nb (n, t, e, s) { let i = t._path; i || (i = t._path = new Path2D, t.path(i, e, s) && i.closePath()), Rc(n, t.options), n.stroke(i) } function sb (n, t, e, s) { const { segments: i, options: o } = t, a = yo(t); for (const r of i) Rc(n, o, r.style), n.beginPath(), a(n, t, r, { start: e, end: e + s - 1 }) && n.closePath(), n.stroke() } const ib = typeof Path2D == "function"; function ob (n, t, e, s) { ib && !t.options.segment ? nb(n, t, e, s) : sb(n, t, e, s) } class Ee extends Pe { constructor(t) { super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t) } updateControlPoints (t, e) { const s = this.options; if ((s.tension || s.cubicInterpolationMode === "monotone") && !s.stepped && !this._pointsUpdated) { const i = s.spanGaps ? this._loop : this._fullLoop; Yg(this._points, s, t, i, e), this._pointsUpdated = !0 } } set points (t) { this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1 } get points () { return this._points } get segments () { return this._segments || (this._segments = rm(this, this.options.segment)) } first () { const t = this.segments, e = this.points; return t.length && e[t[0].start] } last () { const t = this.segments, e = this.points, s = t.length; return s && e[t[s - 1].end] } interpolate (t, e) { const s = this.options, i = t[e], o = this.points, a = wc(this, { property: e, start: i, end: i }); if (!a.length) return; const r = [], l = eb(s); let c, d; for (c = 0, d = a.length; c < d; ++c) { const { start: u, end: h } = a[c], f = o[u], g = o[h]; if (f === g) { r.push(f); continue } const m = Math.abs((i - f[e]) / (g[e] - f[e])), v = l(f, g, m, s.stepped); v[e] = t[e], r.push(v) } return r.length === 1 ? r[0] : r } pathSegment (t, e, s) { return yo(this)(t, this, e, s) } path (t, e, s) { const i = this.segments, o = yo(this); let a = this._loop; e = e || 0, s = s || this.points.length - e; for (const r of i) a &= o(t, this, r, { start: e, end: e + s - 1 }); return !!a } draw (t, e, s, i) { const o = this.options || {}; (this.points || []).length && o.borderWidth && (t.save(), ob(t, this, s, i), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0) } } V(Ee, "id", "line"), V(Ee, "defaults", { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: "default", fill: !1, spanGaps: !1, stepped: !1, tension: 0 }), V(Ee, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }), V(Ee, "descriptors", { _scriptable: !0, _indexable: t => t !== "borderDash" && t !== "fill" }); function Er (n, t, e, s) { const i = n.options, { [e]: o } = n.getProps([e], s); return Math.abs(t - o) < i.radius + i.hitRadius } class zs extends Pe { constructor(e) { super(); V(this, "parsed"); V(this, "skip"); V(this, "stop"); this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, e && Object.assign(this, e) } inRange (e, s, i) { const o = this.options, { x: a, y: r } = this.getProps(["x", "y"], i); return Math.pow(e - a, 2) + Math.pow(s - r, 2) < Math.pow(o.hitRadius + o.radius, 2) } inXRange (e, s) { return Er(this, e, "x", s) } inYRange (e, s) { return Er(this, e, "y", s) } getCenterPoint (e) { const { x: s, y: i } = this.getProps(["x", "y"], e); return { x: s, y: i } } size (e) { e = e || this.options || {}; let s = e.radius || 0; s = Math.max(s, s && e.hoverRadius || 0); const i = s && e.borderWidth || 0; return (s + i) * 2 } draw (e, s) { const i = this.options; this.skip || i.radius < .1 || !ke(this, s, this.size(i) / 2) || (e.strokeStyle = i.borderColor, e.lineWidth = i.borderWidth, e.fillStyle = i.backgroundColor, mo(e, i, this.x, this.y)) } getRange () { const e = this.options || {}; return e.radius + e.hitRadius } } V(zs, "id", "point"), V(zs, "defaults", { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 }), V(zs, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); function Nc (n, t) { const { x: e, y: s, base: i, width: o, height: a } = n.getProps(["x", "y", "base", "width", "height"], t); let r, l, c, d, u; return n.horizontal ? (u = a / 2, r = Math.min(e, i), l = Math.max(e, i), c = s - u, d = s + u) : (u = o / 2, r = e - u, l = e + u, c = Math.min(s, i), d = Math.max(s, i)), { left: r, top: c, right: l, bottom: d } } function Re (n, t, e, s) { return n ? 0 : Dt(t, e, s) } function ab (n, t, e) { const s = n.options.borderWidth, i = n.borderSkipped, o = uc(s); return { t: Re(i.top, o.top, 0, e), r: Re(i.right, o.right, 0, t), b: Re(i.bottom, o.bottom, 0, e), l: Re(i.left, o.left, 0, t) } } function rb (n, t, e) { const { enableBorderRadius: s } = n.getProps(["enableBorderRadius"]), i = n.options.borderRadius, o = en(i), a = Math.min(t, e), r = n.borderSkipped, l = s || ot(i); return { topLeft: Re(!l || r.top || r.left, o.topLeft, 0, a), topRight: Re(!l || r.top || r.right, o.topRight, 0, a), bottomLeft: Re(!l || r.bottom || r.left, o.bottomLeft, 0, a), bottomRight: Re(!l || r.bottom || r.right, o.bottomRight, 0, a) } } function lb (n) { const t = Nc(n), e = t.right - t.left, s = t.bottom - t.top, i = ab(n, e / 2, s / 2), o = rb(n, e / 2, s / 2); return { outer: { x: t.left, y: t.top, w: e, h: s, radius: o }, inner: { x: t.left + i.l, y: t.top + i.t, w: e - i.l - i.r, h: s - i.t - i.b, radius: { topLeft: Math.max(0, o.topLeft - Math.max(i.t, i.l)), topRight: Math.max(0, o.topRight - Math.max(i.t, i.r)), bottomLeft: Math.max(0, o.bottomLeft - Math.max(i.b, i.l)), bottomRight: Math.max(0, o.bottomRight - Math.max(i.b, i.r)) } } } } function qi (n, t, e, s) { const i = t === null, o = e === null, r = n && !(i && o) && Nc(n, s); return r && (i || xe(t, r.left, r.right)) && (o || xe(e, r.top, r.bottom)) } function cb (n) { return n.topLeft || n.topRight || n.bottomLeft || n.bottomRight } function db (n, t) { n.rect(t.x, t.y, t.w, t.h) } function Xi (n, t, e = {}) { const s = n.x !== e.x ? -t : 0, i = n.y !== e.y ? -t : 0, o = (n.x + n.w !== e.x + e.w ? t : 0) - s, a = (n.y + n.h !== e.y + e.h ? t : 0) - i; return { x: n.x + s, y: n.y + i, w: n.w + o, h: n.h + a, radius: n.radius } } class js extends Pe { constructor(t) { super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t) } draw (t) { const { inflateAmount: e, options: { borderColor: s, backgroundColor: i } } = this, { inner: o, outer: a } = lb(this), r = cb(a.radius) ? ns : db; t.save(), (a.w !== o.w || a.h !== o.h) && (t.beginPath(), r(t, Xi(a, e, o)), t.clip(), r(t, Xi(o, -e, a)), t.fillStyle = s, t.fill("evenodd")), t.beginPath(), r(t, Xi(o, e)), t.fillStyle = i, t.fill(), t.restore() } inRange (t, e, s) { return qi(this, t, e, s) } inXRange (t, e) { return qi(this, t, null, e) } inYRange (t, e) { return qi(this, null, t, e) } getCenterPoint (t) { const { x: e, y: s, base: i, horizontal: o } = this.getProps(["x", "y", "base", "horizontal"], t); return { x: o ? (e + i) / 2 : e, y: o ? s : (s + i) / 2 } } getRange (t) { return t === "x" ? this.width / 2 : this.height / 2 } } V(js, "id", "bar"), V(js, "defaults", { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 }), V(js, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); var ub = Object.freeze({ __proto__: null, ArcElement: Fn, BarElement: js, LineElement: Ee, PointElement: zs }); const xo = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"], Rr = xo.map(n => n.replace("rgb(", "rgba(").replace(")", ", 0.5)")); function Fc (n) { return xo[n % xo.length] } function Vc (n) { return Rr[n % Rr.length] } function hb (n, t) { return n.borderColor = Fc(t), n.backgroundColor = Vc(t), ++t } function fb (n, t) { return n.backgroundColor = n.data.map(() => Fc(t++)), t } function pb (n, t) { return n.backgroundColor = n.data.map(() => Vc(t++)), t } function gb (n) { let t = 0; return (e, s) => { const i = n.getDatasetMeta(s).controller; i instanceof tn ? t = fb(e, t) : i instanceof qn ? t = pb(e, t) : i && (t = hb(e, t)) } } function Ir (n) { let t; for (t in n) if (n[t].borderColor || n[t].backgroundColor) return !0; return !1 } function mb (n) { return n && (n.borderColor || n.backgroundColor) } var bb = { id: "colors", defaults: { enabled: !0, forceOverride: !1 }, beforeLayout (n, t, e) { if (!e.enabled) return; const { data: { datasets: s }, options: i } = n.config, { elements: o } = i; if (!e.forceOverride && (Ir(s) || mb(i) || o && Ir(o))) return; const a = gb(n); s.forEach(a) } }; function vb (n, t, e, s, i) { const o = i.samples || s; if (o >= e) return n.slice(t, t + e); const a = [], r = (e - 2) / (o - 2); let l = 0; const c = t + e - 1; let d = t, u, h, f, g, m; for (a[l++] = n[d], u = 0; u < o - 2; u++) { let v = 0, p = 0, b; const y = Math.floor((u + 1) * r) + 1 + t, k = Math.min(Math.floor((u + 2) * r) + 1, e) + t, w = k - y; for (b = y; b < k; b++)v += n[b].x, p += n[b].y; v /= w, p /= w; const L = Math.floor(u * r) + 1 + t, A = Math.min(Math.floor((u + 1) * r) + 1, e) + t, { x, y: S } = n[d]; for (f = g = -1, b = L; b < A; b++)g = .5 * Math.abs((x - v) * (n[b].y - S) - (x - n[b].x) * (p - S)), g > f && (f = g, h = n[b], m = b); a[l++] = h, d = m } return a[l++] = n[c], a } function _b (n, t, e, s) { let i = 0, o = 0, a, r, l, c, d, u, h, f, g, m; const v = [], p = t + e - 1, b = n[t].x, k = n[p].x - b; for (a = t; a < t + e; ++a) { r = n[a], l = (r.x - b) / k * s, c = r.y; const w = l | 0; if (w === d) c < g ? (g = c, u = a) : c > m && (m = c, h = a), i = (o * i + r.x) / ++o; else { const L = a - 1; if (!at(u) && !at(h)) { const A = Math.min(u, h), x = Math.max(u, h); A !== f && A !== L && v.push({ ...n[A], x: i }), x !== f && x !== L && v.push({ ...n[x], x: i }) } a > 0 && L !== f && v.push(n[L]), v.push(r), d = w, o = 0, g = m = c, u = h = f = a } } return v } function Bc (n) { if (n._decimated) { const t = n._data; delete n._decimated, delete n._data, Object.defineProperty(n, "data", { configurable: !0, enumerable: !0, writable: !0, value: t }) } } function Nr (n) { n.data.datasets.forEach(t => { Bc(t) }) } function yb (n, t) { const e = t.length; let s = 0, i; const { iScale: o } = n, { min: a, max: r, minDefined: l, maxDefined: c } = o.getUserBounds(); return l && (s = Dt(we(t, o.axis, a).lo, 0, e - 1)), c ? i = Dt(we(t, o.axis, r).hi + 1, s, e) - s : i = e - s, { start: s, count: i } } var xb = { id: "decimation", defaults: { algorithm: "min-max", enabled: !1 }, beforeElementsUpdate: (n, t, e) => { if (!e.enabled) { Nr(n); return } const s = n.width; n.data.datasets.forEach((i, o) => { const { _data: a, indexAxis: r } = i, l = n.getDatasetMeta(o), c = a || i.data; if (In([r, n.options.indexAxis]) === "y" || !l.controller.supportsDecimation) return; const d = n.scales[l.xAxisID]; if (d.type !== "linear" && d.type !== "time" || n.options.parsing) return; let { start: u, count: h } = yb(l, c); const f = e.threshold || 4 * s; if (h <= f) { Bc(i); return } at(a) && (i._data = c, delete i.data, Object.defineProperty(i, "data", { configurable: !0, enumerable: !0, get: function () { return this._decimated }, set: function (m) { this._data = m } })); let g; switch (e.algorithm) { case "lttb": g = vb(c, u, h, s, e); break; case "min-max": g = _b(c, u, h, s); break; default: throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`) }i._decimated = g }) }, destroy (n) { Nr(n) } }; function wb (n, t, e) { const s = n.segments, i = n.points, o = t.points, a = []; for (const r of s) { let { start: l, end: c } = r; c = na(l, c, i); const d = wo(e, i[l], i[c], r.loop); if (!t.segments) { a.push({ source: r, target: d, start: i[l], end: i[c] }); continue } const u = wc(t, d); for (const h of u) { const f = wo(e, o[h.start], o[h.end], h.loop), g = xc(r, i, f); for (const m of g) a.push({ source: m, target: h, start: { [e]: Fr(d, f, "start", Math.max) }, end: { [e]: Fr(d, f, "end", Math.min) } }) } } return a } function wo (n, t, e, s) { if (s) return; let i = t[n], o = e[n]; return n === "angle" && (i = Gt(i), o = Gt(o)), { property: n, start: i, end: o } } function kb (n, t) { const { x: e = null, y: s = null } = n || {}, i = t.points, o = []; return t.segments.forEach(({ start: a, end: r }) => { r = na(a, r, i); const l = i[a], c = i[r]; s !== null ? (o.push({ x: l.x, y: s }), o.push({ x: c.x, y: s })) : e !== null && (o.push({ x: e, y: l.y }), o.push({ x: e, y: c.y })) }), o } function na (n, t, e) { for (; t > n; t--) { const s = e[t]; if (!isNaN(s.x) && !isNaN(s.y)) break } return t } function Fr (n, t, e, s) { return n && t ? s(n[e], t[e]) : n ? n[e] : t ? t[e] : 0 } function zc (n, t) { let e = [], s = !1; return yt(n) ? (s = !0, e = n) : e = kb(n, t), e.length ? new Ee({ points: e, options: { tension: 0 }, _loop: s, _fullLoop: s }) : null } function Vr (n) { return n && n.fill !== !1 } function Sb (n, t, e) { let i = n[t].fill; const o = [t]; let a; if (!e) return i; for (; i !== !1 && o.indexOf(i) === -1;) { if (!Mt(i)) return i; if (a = n[i], !a) return !1; if (a.visible) return i; o.push(i), i = a.fill } return !1 } function Mb (n, t, e) { const s = Ob(n); if (ot(s)) return isNaN(s.value) ? !1 : s; let i = parseFloat(s); return Mt(i) && Math.floor(i) === i ? Pb(s[0], t, i, e) : ["origin", "start", "end", "stack", "shape"].indexOf(s) >= 0 && s } function Pb (n, t, e, s) { return (n === "-" || n === "+") && (e = t + e), e === t || e < 0 || e >= s ? !1 : e } function Cb (n, t) { let e = null; return n === "start" ? e = t.bottom : n === "end" ? e = t.top : ot(n) ? e = t.getPixelForValue(n.value) : t.getBasePixel && (e = t.getBasePixel()), e } function Tb (n, t, e) { let s; return n === "start" ? s = e : n === "end" ? s = t.options.reverse ? t.min : t.max : ot(n) ? s = n.value : s = t.getBaseValue(), s } function Ob (n) { const t = n.options, e = t.fill; let s = tt(e && e.target, e); return s === void 0 && (s = !!t.backgroundColor), s === !1 || s === null ? !1 : s === !0 ? "origin" : s } function Lb (n) { const { scale: t, index: e, line: s } = n, i = [], o = s.segments, a = s.points, r = Ab(t, e); r.push(zc({ x: null, y: t.bottom }, s)); for (let l = 0; l < o.length; l++) { const c = o[l]; for (let d = c.start; d <= c.end; d++)$b(i, a[d], r) } return new Ee({ points: i, options: {} }) } function Ab (n, t) { const e = [], s = n.getMatchingVisibleMetas("line"); for (let i = 0; i < s.length; i++) { const o = s[i]; if (o.index === t) break; o.hidden || e.unshift(o.dataset) } return e } function $b (n, t, e) { const s = []; for (let i = 0; i < e.length; i++) { const o = e[i], { first: a, last: r, point: l } = Db(o, t, "x"); if (!(!l || a && r)) { if (a) s.unshift(l); else if (n.push(l), !r) break } } n.push(...s) } function Db (n, t, e) { const s = n.interpolate(t, e); if (!s) return {}; const i = s[e], o = n.segments, a = n.points; let r = !1, l = !1; for (let c = 0; c < o.length; c++) { const d = o[c], u = a[d.start][e], h = a[d.end][e]; if (xe(i, u, h)) { r = i === u, l = i === h; break } } return { first: r, last: l, point: s } } class jc { constructor(t) { this.x = t.x, this.y = t.y, this.radius = t.radius } pathSegment (t, e, s) { const { x: i, y: o, radius: a } = this; return e = e || { start: 0, end: gt }, t.arc(i, o, a, e.end, e.start, !0), !s.bounds } interpolate (t) { const { x: e, y: s, radius: i } = this, o = t.angle; return { x: e + Math.cos(o) * i, y: s + Math.sin(o) * i, angle: o } } } function Eb (n) { const { chart: t, fill: e, line: s } = n; if (Mt(e)) return Rb(t, e); if (e === "stack") return Lb(n); if (e === "shape") return !0; const i = Ib(n); return i instanceof jc ? i : zc(i, s) } function Rb (n, t) { const e = n.getDatasetMeta(t); return e && n.isDatasetVisible(t) ? e.dataset : null } function Ib (n) { return (n.scale || {}).getPointPositionForValue ? Fb(n) : Nb(n) } function Nb (n) { const { scale: t = {}, fill: e } = n, s = Cb(e, t); if (Mt(s)) { const i = t.isHorizontal(); return { x: i ? s : null, y: i ? null : s } } return null } function Fb (n) { const { scale: t, fill: e } = n, s = t.options, i = t.getLabels().length, o = s.reverse ? t.max : t.min, a = Tb(e, t, o), r = []; if (s.grid.circular) { const l = t.getPointPositionForValue(0, o); return new jc({ x: l.x, y: l.y, radius: t.getDistanceFromCenterForValue(a) }) } for (let l = 0; l < i; ++l)r.push(t.getPointPositionForValue(l, a)); return r } function Gi (n, t, e) { const s = Eb(t), { line: i, scale: o, axis: a } = t, r = i.options, l = r.fill, c = r.backgroundColor, { above: d = c, below: u = c } = l || {}; s && i.points.length && (xi(n, e), Vb(n, { line: i, target: s, above: d, below: u, area: e, scale: o, axis: a }), wi(n)) } function Vb (n, t) { const { line: e, target: s, above: i, below: o, area: a, scale: r } = t, l = e._loop ? "angle" : t.axis; n.save(), l === "x" && o !== i && (Br(n, s, a.top), zr(n, { line: e, target: s, color: i, scale: r, property: l }), n.restore(), n.save(), Br(n, s, a.bottom)), zr(n, { line: e, target: s, color: o, scale: r, property: l }), n.restore() } function Br (n, t, e) { const { segments: s, points: i } = t; let o = !0, a = !1; n.beginPath(); for (const r of s) { const { start: l, end: c } = r, d = i[l], u = i[na(l, c, i)]; o ? (n.moveTo(d.x, d.y), o = !1) : (n.lineTo(d.x, e), n.lineTo(d.x, d.y)), a = !!t.pathSegment(n, r, { move: a }), a ? n.closePath() : n.lineTo(u.x, e) } n.lineTo(t.first().x, e), n.closePath(), n.clip() } function zr (n, t) { const { line: e, target: s, property: i, color: o, scale: a } = t, r = wb(e, s, i); for (const { source: l, target: c, start: d, end: u } of r) { const { style: { backgroundColor: h = o } = {} } = l, f = s !== !0; n.save(), n.fillStyle = h, Bb(n, a, f && wo(i, d, u)), n.beginPath(); const g = !!e.pathSegment(n, l); let m; if (f) { g ? n.closePath() : jr(n, s, u, i); const v = !!s.pathSegment(n, c, { move: g, reverse: !0 }); m = g && v, m || jr(n, s, d, i) } n.closePath(), n.fill(m ? "evenodd" : "nonzero"), n.restore() } } function Bb (n, t, e) { const { top: s, bottom: i } = t.chart.chartArea, { property: o, start: a, end: r } = e || {}; o === "x" && (n.beginPath(), n.rect(a, s, r - a, i - s), n.clip()) } function jr (n, t, e, s) { const i = t.interpolate(e, s); i && n.lineTo(i.x, i.y) } var zb = { id: "filler", afterDatasetsUpdate (n, t, e) { const s = (n.data.datasets || []).length, i = []; let o, a, r, l; for (a = 0; a < s; ++a)o = n.getDatasetMeta(a), r = o.dataset, l = null, r && r.options && r instanceof Ee && (l = { visible: n.isDatasetVisible(a), index: a, fill: Mb(r, a, s), chart: n, axis: o.controller.options.indexAxis, scale: o.vScale, line: r }), o.$filler = l, i.push(l); for (a = 0; a < s; ++a)l = i[a], !(!l || l.fill === !1) && (l.fill = Sb(i, a, e.propagate)) }, beforeDraw (n, t, e) { const s = e.drawTime === "beforeDraw", i = n.getSortedVisibleDatasetMetas(), o = n.chartArea; for (let a = i.length - 1; a >= 0; --a) { const r = i[a].$filler; r && (r.line.updateControlPoints(o, r.axis), s && r.fill && Gi(n.ctx, r, o)) } }, beforeDatasetsDraw (n, t, e) { if (e.drawTime !== "beforeDatasetsDraw") return; const s = n.getSortedVisibleDatasetMetas(); for (let i = s.length - 1; i >= 0; --i) { const o = s[i].$filler; Vr(o) && Gi(n.ctx, o, n.chartArea) } }, beforeDatasetDraw (n, t, e) { const s = t.meta.$filler; !Vr(s) || e.drawTime !== "beforeDatasetDraw" || Gi(n.ctx, s, n.chartArea) }, defaults: { propagate: !0, drawTime: "beforeDatasetDraw" } }; const Hr = (n, t) => { let { boxHeight: e = t, boxWidth: s = t } = n; return n.usePointStyle && (e = Math.min(e, t), s = n.pointStyleWidth || Math.min(s, t)), { boxWidth: s, boxHeight: e, itemHeight: Math.max(t, e) } }, jb = (n, t) => n !== null && t !== null && n.datasetIndex === t.datasetIndex && n.index === t.index; class Wr extends Pe { constructor(t) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update (t, e, s) { this.maxWidth = t, this.maxHeight = e, this._margins = s, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions () { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels () { const t = this.options.labels || {}; let e = pt(t.generateLabels, [this.chart], this) || []; t.filter && (e = e.filter(s => t.filter(s, this.chart.data))), t.sort && (e = e.sort((s, i) => t.sort(s, i, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e } fit () { const { options: t, ctx: e } = this; if (!t.display) { this.width = this.height = 0; return } const s = t.labels, i = At(s.font), o = i.size, a = this._computeTitleHeight(), { boxWidth: r, itemHeight: l } = Hr(s, o); let c, d; e.font = i.string, this.isHorizontal() ? (c = this.maxWidth, d = this._fitRows(a, o, r, l) + 10) : (d = this.maxHeight, c = this._fitCols(a, i, r, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(d, t.maxHeight || this.maxHeight) } _fitRows (t, e, s, i) { const { ctx: o, maxWidth: a, options: { labels: { padding: r } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [0], d = i + r; let u = t; o.textAlign = "left", o.textBaseline = "middle"; let h = -1, f = -d; return this.legendItems.forEach((g, m) => { const v = s + e / 2 + o.measureText(g.text).width; (m === 0 || c[c.length - 1] + v + 2 * r > a) && (u += d, c[c.length - (m > 0 ? 0 : 1)] = 0, f += d, h++), l[m] = { left: 0, top: f, row: h, width: v, height: i }, c[c.length - 1] += v + r }), u } _fitCols (t, e, s, i) { const { ctx: o, maxHeight: a, options: { labels: { padding: r } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], d = a - t; let u = r, h = 0, f = 0, g = 0, m = 0; return this.legendItems.forEach((v, p) => { const { itemWidth: b, itemHeight: y } = Hb(s, e, o, v, i); p > 0 && f + y + 2 * r > d && (u += h + r, c.push({ width: h, height: f }), g += h + r, m++, h = f = 0), l[p] = { left: g, top: f, col: m, width: b, height: y }, h = Math.max(h, b), f += y + r }), u += h, c.push({ width: h, height: f }), u } adjustHitBoxes () { if (!this.options.display) return; const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: s, labels: { padding: i }, rtl: o } } = this, a = yn(o, this.left, this.width); if (this.isHorizontal()) { let r = 0, l = zt(s, this.left + i, this.right - this.lineWidths[r]); for (const c of e) r !== c.row && (r = c.row, l = zt(s, this.left + i, this.right - this.lineWidths[r])), c.top += this.top + t + i, c.left = a.leftForLtr(a.x(l), c.width), l += c.width + i } else { let r = 0, l = zt(s, this.top + t + i, this.bottom - this.columnSizes[r].height); for (const c of e) c.col !== r && (r = c.col, l = zt(s, this.top + t + i, this.bottom - this.columnSizes[r].height)), c.top = l, c.left += this.left + i, c.left = a.leftForLtr(a.x(c.left), c.width), l += c.height + i } } isHorizontal () { return this.options.position === "top" || this.options.position === "bottom" } draw () { if (this.options.display) { const t = this.ctx; xi(t, this), this._draw(), wi(t) } } _draw () { const { options: t, columnSizes: e, lineWidths: s, ctx: i } = this, { align: o, labels: a } = t, r = Pt.color, l = yn(t.rtl, this.left, this.width), c = At(a.font), { padding: d } = a, u = c.size, h = u / 2; let f; this.drawTitle(), i.textAlign = l.textAlign("left"), i.textBaseline = "middle", i.lineWidth = .5, i.font = c.string; const { boxWidth: g, boxHeight: m, itemHeight: v } = Hr(a, u), p = function (L, A, x) { if (isNaN(g) || g <= 0 || isNaN(m) || m < 0) return; i.save(); const S = tt(x.lineWidth, 1); if (i.fillStyle = tt(x.fillStyle, r), i.lineCap = tt(x.lineCap, "butt"), i.lineDashOffset = tt(x.lineDashOffset, 0), i.lineJoin = tt(x.lineJoin, "miter"), i.lineWidth = S, i.strokeStyle = tt(x.strokeStyle, r), i.setLineDash(tt(x.lineDash, [])), a.usePointStyle) { const C = { radius: m * Math.SQRT2 / 2, pointStyle: x.pointStyle, rotation: x.rotation, borderWidth: S }, T = l.xPlus(L, g / 2), R = A + h; dc(i, C, T, R, a.pointStyleWidth && g) } else { const C = A + Math.max((u - m) / 2, 0), T = l.leftForLtr(L, g), R = en(x.borderRadius); i.beginPath(), Object.values(R).some(I => I !== 0) ? ns(i, { x: T, y: C, w: g, h: m, radius: R }) : i.rect(T, C, g, m), i.fill(), S !== 0 && i.stroke() } i.restore() }, b = function (L, A, x) { dn(i, x.text, L, A + v / 2, c, { strikethrough: x.hidden, textAlign: l.textAlign(x.textAlign) }) }, y = this.isHorizontal(), k = this._computeTitleHeight(); y ? f = { x: zt(o, this.left + d, this.right - s[0]), y: this.top + d + k, line: 0 } : f = { x: this.left + d, y: zt(o, this.top + k + d, this.bottom - e[0].height), line: 0 }, vc(this.ctx, t.textDirection); const w = v + d; this.legendItems.forEach((L, A) => { i.strokeStyle = L.fontColor, i.fillStyle = L.fontColor; const x = i.measureText(L.text).width, S = l.textAlign(L.textAlign || (L.textAlign = a.textAlign)), C = g + h + x; let T = f.x, R = f.y; l.setWidth(this.width), y ? A > 0 && T + C + d > this.right && (R = f.y += w, f.line++, T = f.x = zt(o, this.left + d, this.right - s[f.line])) : A > 0 && R + w > this.bottom && (T = f.x = T + e[f.line].width + d, f.line++, R = f.y = zt(o, this.top + k + d, this.bottom - e[f.line].height)); const I = l.x(T); if (p(I, R, L), T = dg(S, T + g + h, y ? T + C : this.right, t.rtl), b(l.x(T), R, L), y) f.x += C + d; else if (typeof L.text != "string") { const H = c.lineHeight; f.y += Hc(L, H) + d } else f.y += w }), _c(this.ctx, t.textDirection) } drawTitle () { const t = this.options, e = t.title, s = At(e.font), i = Ht(e.padding); if (!e.display) return; const o = yn(t.rtl, this.left, this.width), a = this.ctx, r = e.position, l = s.size / 2, c = i.top + l; let d, u = this.left, h = this.width; if (this.isHorizontal()) h = Math.max(...this.lineWidths), d = this.top + c, u = zt(t.align, u, this.right - h); else { const g = this.columnSizes.reduce((m, v) => Math.max(m, v.height), 0); d = c + zt(t.align, this.top, this.bottom - g - t.labels.padding - this._computeTitleHeight()) } const f = zt(r, u, u + h); a.textAlign = o.textAlign(Ko(r)), a.textBaseline = "middle", a.strokeStyle = e.color, a.fillStyle = e.color, a.font = s.string, dn(a, e.text, f, d, s) } _computeTitleHeight () { const t = this.options.title, e = At(t.font), s = Ht(t.padding); return t.display ? e.lineHeight + s.height : 0 } _getLegendItemAt (t, e) { let s, i, o; if (xe(t, this.left, this.right) && xe(e, this.top, this.bottom)) { for (o = this.legendHitBoxes, s = 0; s < o.length; ++s)if (i = o[s], xe(t, i.left, i.left + i.width) && xe(e, i.top, i.top + i.height)) return this.legendItems[s] } return null } handleEvent (t) { const e = this.options; if (!Yb(t.type, e)) return; const s = this._getLegendItemAt(t.x, t.y); if (t.type === "mousemove" || t.type === "mouseout") { const i = this._hoveredItem, o = jb(i, s); i && !o && pt(e.onLeave, [t, i, this], this), this._hoveredItem = s, s && !o && pt(e.onHover, [t, s, this], this) } else s && pt(e.onClick, [t, s, this], this) } } function Hb (n, t, e, s, i) { const o = Wb(s, n, t, e), a = Ub(i, s, t.lineHeight); return { itemWidth: o, itemHeight: a } } function Wb (n, t, e, s) { let i = n.text; return i && typeof i != "string" && (i = i.reduce((o, a) => o.length > a.length ? o : a)), t + e.size / 2 + s.measureText(i).width } function Ub (n, t, e) { let s = n; return typeof t.text != "string" && (s = Hc(t, e)), s } function Hc (n, t) { const e = n.text ? n.text.length : 0; return t * e } function Yb (n, t) { return !!((n === "mousemove" || n === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (n === "click" || n === "mouseup")) } var Kb = { id: "legend", _element: Wr, start (n, t, e) { const s = n.legend = new Wr({ ctx: n.ctx, options: e, chart: n }); jt.configure(n, s, e), jt.addBox(n, s) }, stop (n) { jt.removeBox(n, n.legend), delete n.legend }, beforeUpdate (n, t, e) { const s = n.legend; jt.configure(n, s, e), s.options = e }, afterUpdate (n) { const t = n.legend; t.buildLabels(), t.adjustHitBoxes() }, afterEvent (n, t) { t.replay || n.legend.handleEvent(t.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick (n, t, e) { const s = t.datasetIndex, i = e.chart; i.isDatasetVisible(s) ? (i.hide(s), t.hidden = !0) : (i.show(s), t.hidden = !1) }, onHover: null, onLeave: null, labels: { color: n => n.chart.options.color, boxWidth: 40, padding: 10, generateLabels (n) { const t = n.data.datasets, { labels: { usePointStyle: e, pointStyle: s, textAlign: i, color: o, useBorderRadius: a, borderRadius: r } } = n.legend.options; return n._getSortedDatasetMetas().map(l => { const c = l.controller.getStyle(e ? 0 : void 0), d = Ht(c.borderWidth); return { text: t[l.index].label, fillStyle: c.backgroundColor, fontColor: o, hidden: !l.visible, lineCap: c.borderCapStyle, lineDash: c.borderDash, lineDashOffset: c.borderDashOffset, lineJoin: c.borderJoinStyle, lineWidth: (d.width + d.height) / 4, strokeStyle: c.borderColor, pointStyle: s || c.pointStyle, rotation: c.rotation, textAlign: i || c.textAlign, borderRadius: a && (r || c.borderRadius), datasetIndex: l.index } }, this) } }, title: { color: n => n.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: n => !n.startsWith("on"), labels: { _scriptable: n => !["generateLabels", "filter", "sort"].includes(n) } } }; class sa extends Pe { constructor(t) { super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update (t, e) { const s = this.options; if (this.left = 0, this.top = 0, !s.display) { this.width = this.height = this.right = this.bottom = 0; return } this.width = this.right = t, this.height = this.bottom = e; const i = yt(s.text) ? s.text.length : 1; this._padding = Ht(s.padding); const o = i * At(s.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = o : this.width = o } isHorizontal () { const t = this.options.position; return t === "top" || t === "bottom" } _drawArgs (t) { const { top: e, left: s, bottom: i, right: o, options: a } = this, r = a.align; let l = 0, c, d, u; return this.isHorizontal() ? (d = zt(r, s, o), u = e + t, c = o - s) : (a.position === "left" ? (d = s + t, u = zt(r, i, e), l = mt * -.5) : (d = o - t, u = zt(r, e, i), l = mt * .5), c = i - e), { titleX: d, titleY: u, maxWidth: c, rotation: l } } draw () { const t = this.ctx, e = this.options; if (!e.display) return; const s = At(e.font), o = s.lineHeight / 2 + this._padding.top, { titleX: a, titleY: r, maxWidth: l, rotation: c } = this._drawArgs(o); dn(t, e.text, 0, 0, s, { color: e.color, maxWidth: l, rotation: c, textAlign: Ko(e.align), textBaseline: "middle", translation: [a, r] }) } } function qb (n, t) { const e = new sa({ ctx: n.ctx, options: t, chart: n }); jt.configure(n, e, t), jt.addBox(n, e), n.titleBlock = e } var Xb = { id: "title", _element: sa, start (n, t, e) { qb(n, e) }, stop (n) { const t = n.titleBlock; jt.removeBox(n, t), delete n.titleBlock }, beforeUpdate (n, t, e) { const s = n.titleBlock; jt.configure(n, s, e), s.options = e }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const Ts = new WeakMap; var Gb = { id: "subtitle", start (n, t, e) { const s = new sa({ ctx: n.ctx, options: e, chart: n }); jt.configure(n, s, e), jt.addBox(n, s), Ts.set(n, s) }, stop (n) { jt.removeBox(n, Ts.get(n)), Ts.delete(n) }, beforeUpdate (n, t, e) { const s = Ts.get(n); jt.configure(n, s, e), s.options = e }, defaults: { align: "center", display: !1, font: { weight: "normal" }, fullSize: !0, padding: 0, position: "top", text: "", weight: 1500 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const Vn = { average (n) { if (!n.length) return !1; let t, e, s = new Set, i = 0, o = 0; for (t = 0, e = n.length; t < e; ++t) { const r = n[t].element; if (r && r.hasValue()) { const l = r.tooltipPosition(); s.add(l.x), i += l.y, ++o } } return { x: [...s].reduce((r, l) => r + l) / s.size, y: i / o } }, nearest (n, t) { if (!n.length) return !1; let e = t.x, s = t.y, i = Number.POSITIVE_INFINITY, o, a, r; for (o = 0, a = n.length; o < a; ++o) { const l = n[o].element; if (l && l.hasValue()) { const c = l.getCenterPoint(), d = po(t, c); d < i && (i = d, r = l) } } if (r) { const l = r.tooltipPosition(); e = l.x, s = l.y } return { x: e, y: s } } }; function ce (n, t) { return t && (yt(t) ? Array.prototype.push.apply(n, t) : n.push(t)), n } function ve (n) {
  return (typeof n == "string" || n instanceof String) && n.indexOf(`
`) > -1 ? n.split(`
`) : n
} function Jb (n, t) { const { element: e, datasetIndex: s, index: i } = t, o = n.getDatasetMeta(s).controller, { label: a, value: r } = o.getLabelAndValue(i); return { chart: n, label: a, parsed: o.getParsed(i), raw: n.data.datasets[s].data[i], formattedValue: r, dataset: o.getDataset(), dataIndex: i, datasetIndex: s, element: e } } function Ur (n, t) { const e = n.chart.ctx, { body: s, footer: i, title: o } = n, { boxWidth: a, boxHeight: r } = t, l = At(t.bodyFont), c = At(t.titleFont), d = At(t.footerFont), u = o.length, h = i.length, f = s.length, g = Ht(t.padding); let m = g.height, v = 0, p = s.reduce((k, w) => k + w.before.length + w.lines.length + w.after.length, 0); if (p += n.beforeBody.length + n.afterBody.length, u && (m += u * c.lineHeight + (u - 1) * t.titleSpacing + t.titleMarginBottom), p) { const k = t.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight; m += f * k + (p - f) * l.lineHeight + (p - 1) * t.bodySpacing } h && (m += t.footerMarginTop + h * d.lineHeight + (h - 1) * t.footerSpacing); let b = 0; const y = function (k) { v = Math.max(v, e.measureText(k).width + b) }; return e.save(), e.font = c.string, ut(n.title, y), e.font = l.string, ut(n.beforeBody.concat(n.afterBody), y), b = t.displayColors ? a + 2 + t.boxPadding : 0, ut(s, k => { ut(k.before, y), ut(k.lines, y), ut(k.after, y) }), b = 0, e.font = d.string, ut(n.footer, y), e.restore(), v += g.width, { width: v, height: m } } function Qb (n, t) { const { y: e, height: s } = t; return e < s / 2 ? "top" : e > n.height - s / 2 ? "bottom" : "center" } function Zb (n, t, e, s) { const { x: i, width: o } = s, a = e.caretSize + e.caretPadding; if (n === "left" && i + o + a > t.width || n === "right" && i - o - a < 0) return !0 } function tv (n, t, e, s) { const { x: i, width: o } = e, { width: a, chartArea: { left: r, right: l } } = n; let c = "center"; return s === "center" ? c = i <= (r + l) / 2 ? "left" : "right" : i <= o / 2 ? c = "left" : i >= a - o / 2 && (c = "right"), Zb(c, n, t, e) && (c = "center"), c } function Yr (n, t, e) { const s = e.yAlign || t.yAlign || Qb(n, e); return { xAlign: e.xAlign || t.xAlign || tv(n, t, e, s), yAlign: s } } function ev (n, t) { let { x: e, width: s } = n; return t === "right" ? e -= s : t === "center" && (e -= s / 2), e } function nv (n, t, e) { let { y: s, height: i } = n; return t === "top" ? s += e : t === "bottom" ? s -= i + e : s -= i / 2, s } function Kr (n, t, e, s) { const { caretSize: i, caretPadding: o, cornerRadius: a } = n, { xAlign: r, yAlign: l } = e, c = i + o, { topLeft: d, topRight: u, bottomLeft: h, bottomRight: f } = en(a); let g = ev(t, r); const m = nv(t, l, c); return l === "center" ? r === "left" ? g += c : r === "right" && (g -= c) : r === "left" ? g -= Math.max(d, h) + i : r === "right" && (g += Math.max(u, f) + i), { x: Dt(g, 0, s.width - t.width), y: Dt(m, 0, s.height - t.height) } } function Os (n, t, e) { const s = Ht(e.padding); return t === "center" ? n.x + n.width / 2 : t === "right" ? n.x + n.width - s.right : n.x + s.left } function qr (n) { return ce([], ve(n)) } function sv (n, t, e) { return We(n, { tooltip: t, tooltipItems: e, type: "tooltip" }) } function Xr (n, t) { const e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks; return e ? n.override(e) : n } const Wc = { beforeTitle: me, title (n) { if (n.length > 0) { const t = n[0], e = t.chart.data.labels, s = e ? e.length : 0; if (this && this.options && this.options.mode === "dataset") return t.dataset.label || ""; if (t.label) return t.label; if (s > 0 && t.dataIndex < s) return e[t.dataIndex] } return "" }, afterTitle: me, beforeBody: me, beforeLabel: me, label (n) { if (this && this.options && this.options.mode === "dataset") return n.label + ": " + n.formattedValue || n.formattedValue; let t = n.dataset.label || ""; t && (t += ": "); const e = n.formattedValue; return at(e) || (t += e), t }, labelColor (n) { const e = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex); return { borderColor: e.borderColor, backgroundColor: e.backgroundColor, borderWidth: e.borderWidth, borderDash: e.borderDash, borderDashOffset: e.borderDashOffset, borderRadius: 0 } }, labelTextColor () { return this.options.bodyColor }, labelPointStyle (n) { const e = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex); return { pointStyle: e.pointStyle, rotation: e.rotation } }, afterLabel: me, afterBody: me, beforeFooter: me, footer: me, afterFooter: me }; function Yt (n, t, e, s) { const i = n[t].call(e, s); return typeof i > "u" ? Wc[t].call(e, s) : i } class ko extends Pe { constructor(t) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize (t) { this.options = t, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations () { const t = this._cachedAnimations; if (t) return t; const e = this.chart, s = this.options.setContext(this.getContext()), i = s.enabled && e.options.animation && s.animations, o = new kc(this.chart, i); return i._cacheable && (this._cachedAnimations = Object.freeze(o)), o } getContext () { return this.$context || (this.$context = sv(this.chart.getContext(), this, this._tooltipItems)) } getTitle (t, e) { const { callbacks: s } = e, i = Yt(s, "beforeTitle", this, t), o = Yt(s, "title", this, t), a = Yt(s, "afterTitle", this, t); let r = []; return r = ce(r, ve(i)), r = ce(r, ve(o)), r = ce(r, ve(a)), r } getBeforeBody (t, e) { return qr(Yt(e.callbacks, "beforeBody", this, t)) } getBody (t, e) { const { callbacks: s } = e, i = []; return ut(t, o => { const a = { before: [], lines: [], after: [] }, r = Xr(s, o); ce(a.before, ve(Yt(r, "beforeLabel", this, o))), ce(a.lines, Yt(r, "label", this, o)), ce(a.after, ve(Yt(r, "afterLabel", this, o))), i.push(a) }), i } getAfterBody (t, e) { return qr(Yt(e.callbacks, "afterBody", this, t)) } getFooter (t, e) { const { callbacks: s } = e, i = Yt(s, "beforeFooter", this, t), o = Yt(s, "footer", this, t), a = Yt(s, "afterFooter", this, t); let r = []; return r = ce(r, ve(i)), r = ce(r, ve(o)), r = ce(r, ve(a)), r } _createItems (t) { const e = this._active, s = this.chart.data, i = [], o = [], a = []; let r = [], l, c; for (l = 0, c = e.length; l < c; ++l)r.push(Jb(this.chart, e[l])); return t.filter && (r = r.filter((d, u, h) => t.filter(d, u, h, s))), t.itemSort && (r = r.sort((d, u) => t.itemSort(d, u, s))), ut(r, d => { const u = Xr(t.callbacks, d); i.push(Yt(u, "labelColor", this, d)), o.push(Yt(u, "labelPointStyle", this, d)), a.push(Yt(u, "labelTextColor", this, d)) }), this.labelColors = i, this.labelPointStyles = o, this.labelTextColors = a, this.dataPoints = r, r } update (t, e) { const s = this.options.setContext(this.getContext()), i = this._active; let o, a = []; if (!i.length) this.opacity !== 0 && (o = { opacity: 0 }); else { const r = Vn[s.position].call(this, i, this._eventPosition); a = this._createItems(s), this.title = this.getTitle(a, s), this.beforeBody = this.getBeforeBody(a, s), this.body = this.getBody(a, s), this.afterBody = this.getAfterBody(a, s), this.footer = this.getFooter(a, s); const l = this._size = Ur(this, s), c = Object.assign({}, r, l), d = Yr(this.chart, s, c), u = Kr(s, c, d, this.chart); this.xAlign = d.xAlign, this.yAlign = d.yAlign, o = { opacity: 1, x: u.x, y: u.y, width: l.width, height: l.height, caretX: r.x, caretY: r.y } } this._tooltipItems = a, this.$context = void 0, o && this._resolveAnimations().update(this, o), t && s.external && s.external.call(this, { chart: this.chart, tooltip: this, replay: e }) } drawCaret (t, e, s, i) { const o = this.getCaretPosition(t, s, i); e.lineTo(o.x1, o.y1), e.lineTo(o.x2, o.y2), e.lineTo(o.x3, o.y3) } getCaretPosition (t, e, s) { const { xAlign: i, yAlign: o } = this, { caretSize: a, cornerRadius: r } = s, { topLeft: l, topRight: c, bottomLeft: d, bottomRight: u } = en(r), { x: h, y: f } = t, { width: g, height: m } = e; let v, p, b, y, k, w; return o === "center" ? (k = f + m / 2, i === "left" ? (v = h, p = v - a, y = k + a, w = k - a) : (v = h + g, p = v + a, y = k - a, w = k + a), b = v) : (i === "left" ? p = h + Math.max(l, d) + a : i === "right" ? p = h + g - Math.max(c, u) - a : p = this.caretX, o === "top" ? (y = f, k = y - a, v = p - a, b = p + a) : (y = f + m, k = y + a, v = p + a, b = p - a), w = y), { x1: v, x2: p, x3: b, y1: y, y2: k, y3: w } } drawTitle (t, e, s) { const i = this.title, o = i.length; let a, r, l; if (o) { const c = yn(s.rtl, this.x, this.width); for (t.x = Os(this, s.titleAlign, s), e.textAlign = c.textAlign(s.titleAlign), e.textBaseline = "middle", a = At(s.titleFont), r = s.titleSpacing, e.fillStyle = s.titleColor, e.font = a.string, l = 0; l < o; ++l)e.fillText(i[l], c.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + r, l + 1 === o && (t.y += s.titleMarginBottom - r) } } _drawColorBox (t, e, s, i, o) { const a = this.labelColors[s], r = this.labelPointStyles[s], { boxHeight: l, boxWidth: c } = o, d = At(o.bodyFont), u = Os(this, "left", o), h = i.x(u), f = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0, g = e.y + f; if (o.usePointStyle) { const m = { radius: Math.min(c, l) / 2, pointStyle: r.pointStyle, rotation: r.rotation, borderWidth: 1 }, v = i.leftForLtr(h, c) + c / 2, p = g + l / 2; t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, mo(t, m, v, p), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, mo(t, m, v, p) } else { t.lineWidth = ot(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0; const m = i.leftForLtr(h, c), v = i.leftForLtr(i.xPlus(h, 1), c - 2), p = en(a.borderRadius); Object.values(p).some(b => b !== 0) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, ns(t, { x: m, y: g, w: c, h: l, radius: p }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), ns(t, { x: v, y: g + 1, w: c - 2, h: l - 2, radius: p }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(m, g, c, l), t.strokeRect(m, g, c, l), t.fillStyle = a.backgroundColor, t.fillRect(v, g + 1, c - 2, l - 2)) } t.fillStyle = this.labelTextColors[s] } drawBody (t, e, s) { const { body: i } = this, { bodySpacing: o, bodyAlign: a, displayColors: r, boxHeight: l, boxWidth: c, boxPadding: d } = s, u = At(s.bodyFont); let h = u.lineHeight, f = 0; const g = yn(s.rtl, this.x, this.width), m = function (x) { e.fillText(x, g.x(t.x + f), t.y + h / 2), t.y += h + o }, v = g.textAlign(a); let p, b, y, k, w, L, A; for (e.textAlign = a, e.textBaseline = "middle", e.font = u.string, t.x = Os(this, v, s), e.fillStyle = s.bodyColor, ut(this.beforeBody, m), f = r && v !== "right" ? a === "center" ? c / 2 + d : c + 2 + d : 0, k = 0, L = i.length; k < L; ++k) { for (p = i[k], b = this.labelTextColors[k], e.fillStyle = b, ut(p.before, m), y = p.lines, r && y.length && (this._drawColorBox(e, t, k, g, s), h = Math.max(u.lineHeight, l)), w = 0, A = y.length; w < A; ++w)m(y[w]), h = u.lineHeight; ut(p.after, m) } f = 0, h = u.lineHeight, ut(this.afterBody, m), t.y -= o } drawFooter (t, e, s) { const i = this.footer, o = i.length; let a, r; if (o) { const l = yn(s.rtl, this.x, this.width); for (t.x = Os(this, s.footerAlign, s), t.y += s.footerMarginTop, e.textAlign = l.textAlign(s.footerAlign), e.textBaseline = "middle", a = At(s.footerFont), e.fillStyle = s.footerColor, e.font = a.string, r = 0; r < o; ++r)e.fillText(i[r], l.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + s.footerSpacing } } drawBackground (t, e, s, i) { const { xAlign: o, yAlign: a } = this, { x: r, y: l } = t, { width: c, height: d } = s, { topLeft: u, topRight: h, bottomLeft: f, bottomRight: g } = en(i.cornerRadius); e.fillStyle = i.backgroundColor, e.strokeStyle = i.borderColor, e.lineWidth = i.borderWidth, e.beginPath(), e.moveTo(r + u, l), a === "top" && this.drawCaret(t, e, s, i), e.lineTo(r + c - h, l), e.quadraticCurveTo(r + c, l, r + c, l + h), a === "center" && o === "right" && this.drawCaret(t, e, s, i), e.lineTo(r + c, l + d - g), e.quadraticCurveTo(r + c, l + d, r + c - g, l + d), a === "bottom" && this.drawCaret(t, e, s, i), e.lineTo(r + f, l + d), e.quadraticCurveTo(r, l + d, r, l + d - f), a === "center" && o === "left" && this.drawCaret(t, e, s, i), e.lineTo(r, l + u), e.quadraticCurveTo(r, l, r + u, l), e.closePath(), e.fill(), i.borderWidth > 0 && e.stroke() } _updateAnimationTarget (t) { const e = this.chart, s = this.$animations, i = s && s.x, o = s && s.y; if (i || o) { const a = Vn[t.position].call(this, this._active, this._eventPosition); if (!a) return; const r = this._size = Ur(this, t), l = Object.assign({}, a, this._size), c = Yr(e, t, l), d = Kr(t, l, c, e); (i._to !== d.x || o._to !== d.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = r.width, this.height = r.height, this.caretX = a.x, this.caretY = a.y, this._resolveAnimations().update(this, d)) } } _willRender () { return !!this.opacity } draw (t) { const e = this.options.setContext(this.getContext()); let s = this.opacity; if (!s) return; this._updateAnimationTarget(e); const i = { width: this.width, height: this.height }, o = { x: this.x, y: this.y }; s = Math.abs(s) < .001 ? 0 : s; const a = Ht(e.padding), r = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length; e.enabled && r && (t.save(), t.globalAlpha = s, this.drawBackground(o, t, i, e), vc(t, e.textDirection), o.y += a.top, this.drawTitle(o, t, e), this.drawBody(o, t, e), this.drawFooter(o, t, e), _c(t, e.textDirection), t.restore()) } getActiveElements () { return this._active || [] } setActiveElements (t, e) { const s = this._active, i = t.map(({ datasetIndex: r, index: l }) => { const c = this.chart.getDatasetMeta(r); if (!c) throw new Error("Cannot find a dataset at index " + r); return { datasetIndex: r, element: c.data[l], index: l } }), o = !Zs(s, i), a = this._positionChanged(i, e); (o || a) && (this._active = i, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent (t, e, s = !0) { if (e && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const i = this.options, o = this._active || [], a = this._getActiveElements(t, o, e, s), r = this._positionChanged(a, t), l = e || !Zs(a, o) || r; return l && (this._active = a, (i.enabled || i.external) && (this._eventPosition = { x: t.x, y: t.y }, this.update(!0, e))), l } _getActiveElements (t, e, s, i) { const o = this.options; if (t.type === "mouseout") return []; if (!i) return e.filter(r => this.chart.data.datasets[r.datasetIndex] && this.chart.getDatasetMeta(r.datasetIndex).controller.getParsed(r.index) !== void 0); const a = this.chart.getElementsAtEventForMode(t, o.mode, o, s); return o.reverse && a.reverse(), a } _positionChanged (t, e) { const { caretX: s, caretY: i, options: o } = this, a = Vn[o.position].call(this, t, e); return a !== !1 && (s !== a.x || i !== a.y) } } V(ko, "positioners", Vn); var iv = { id: "tooltip", _element: ko, positioners: Vn, afterInit (n, t, e) { e && (n.tooltip = new ko({ chart: n, options: e })) }, beforeUpdate (n, t, e) { n.tooltip && n.tooltip.initialize(e) }, reset (n, t, e) { n.tooltip && n.tooltip.initialize(e) }, afterDraw (n) { const t = n.tooltip; if (t && t._willRender()) { const e = { tooltip: t }; if (n.notifyPlugins("beforeTooltipDraw", { ...e, cancelable: !0 }) === !1) return; t.draw(n.ctx), n.notifyPlugins("afterTooltipDraw", e) } }, afterEvent (n, t) { if (n.tooltip) { const e = t.replay; n.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = !0) } }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (n, t) => t.bodyFont.size, boxWidth: (n, t) => t.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: Wc }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: n => n !== "filter" && n !== "itemSort" && n !== "external", _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }, ov = Object.freeze({ __proto__: null, Colors: bb, Decimation: xb, Filler: zb, Legend: Kb, SubTitle: Gb, Title: Xb, Tooltip: iv }); const av = (n, t, e, s) => (typeof t == "string" ? (e = n.push(t) - 1, s.unshift({ index: e, label: t })) : isNaN(t) && (e = null), e); function rv (n, t, e, s) { const i = n.indexOf(t); if (i === -1) return av(n, t, e, s); const o = n.lastIndexOf(t); return i !== o ? e : i } const lv = (n, t) => n === null ? null : Dt(Math.round(n), 0, t); function Gr (n) { const t = this.getLabels(); return n >= 0 && n < t.length ? t[n] : n } class So extends un { constructor(t) { super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init (t) { const e = this._addedLabels; if (e.length) { const s = this.getLabels(); for (const { index: i, label: o } of e) s[i] === o && s.splice(i, 1); this._addedLabels = [] } super.init(t) } parse (t, e) { if (at(t)) return null; const s = this.getLabels(); return e = isFinite(e) && s[e] === t ? e : rv(s, t, tt(e, t), this._addedLabels), lv(e, s.length - 1) } determineDataLimits () { const { minDefined: t, maxDefined: e } = this.getUserBounds(); let { min: s, max: i } = this.getMinMax(!0); this.options.bounds === "ticks" && (t || (s = 0), e || (i = this.getLabels().length - 1)), this.min = s, this.max = i } buildTicks () { const t = this.min, e = this.max, s = this.options.offset, i = []; let o = this.getLabels(); o = t === 0 && e === o.length - 1 ? o : o.slice(t, e + 1), this._valueRange = Math.max(o.length - (s ? 0 : 1), 1), this._startValue = this.min - (s ? .5 : 0); for (let a = t; a <= e; a++)i.push({ value: a }); return i } getLabelForValue (t) { return Gr.call(this, t) } configure () { super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue (t) { return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getPixelForTick (t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } getValueForPixel (t) { return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange) } getBasePixel () { return this.bottom } } V(So, "id", "category"), V(So, "defaults", { ticks: { callback: Gr } }); function cv (n, t) { const e = [], { bounds: i, step: o, min: a, max: r, precision: l, count: c, maxTicks: d, maxDigits: u, includeBounds: h } = n, f = o || 1, g = d - 1, { min: m, max: v } = t, p = !at(a), b = !at(r), y = !at(c), k = (v - m) / (u + 1); let w = Wa((v - m) / g / f) * f, L, A, x, S; if (w < 1e-14 && !p && !b) return [{ value: m }, { value: v }]; S = Math.ceil(v / w) - Math.floor(m / w), S > g && (w = Wa(S * w / g / f) * f), at(l) || (L = Math.pow(10, l), w = Math.ceil(w * L) / L), i === "ticks" ? (A = Math.floor(m / w) * w, x = Math.ceil(v / w) * w) : (A = m, x = v), p && b && o && sg((r - a) / o, w / 1e3) ? (S = Math.round(Math.min((r - a) / w, d)), w = (r - a) / S, A = a, x = r) : y ? (A = p ? a : A, x = b ? r : x, S = c - 1, w = (x - A) / S) : (S = (x - A) / w, Un(S, Math.round(S), w / 1e3) ? S = Math.round(S) : S = Math.ceil(S)); const C = Math.max(Ua(w), Ua(A)); L = Math.pow(10, at(l) ? C : l), A = Math.round(A * L) / L, x = Math.round(x * L) / L; let T = 0; for (p && (h && A !== a ? (e.push({ value: a }), A < a && T++, Un(Math.round((A + T * w) * L) / L, a, Jr(a, k, n)) && T++) : A < a && T++); T < S; ++T) { const R = Math.round((A + T * w) * L) / L; if (b && R > r) break; e.push({ value: R }) } return b && h && x !== r ? e.length && Un(e[e.length - 1].value, r, Jr(r, k, n)) ? e[e.length - 1].value = r : e.push({ value: r }) : (!b || x === r) && e.push({ value: x }), e } function Jr (n, t, { horizontal: e, minRotation: s }) { const i = oe(s), o = (e ? Math.sin(i) : Math.cos(i)) || .001, a = .75 * t * ("" + n).length; return Math.min(t / o, a) } class ai extends un { constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse (t, e) { return at(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t } handleTickRangeOptions () { const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: s } = this.getUserBounds(); let { min: i, max: o } = this; const a = l => i = e ? i : l, r = l => o = s ? o : l; if (t) { const l = fe(i), c = fe(o); l < 0 && c < 0 ? r(0) : l > 0 && c > 0 && a(0) } if (i === o) { let l = o === 0 ? 1 : Math.abs(o * .05); r(o + l), t || a(i - l) } this.min = i, this.max = o } getTickLimit () { const t = this.options.ticks; let { maxTicksLimit: e, stepSize: s } = t, i; return s ? (i = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, i > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${i} ticks. Limiting to 1000.`), i = 1e3)) : (i = this.computeTickLimit(), e = e || 11), e && (i = Math.min(e, i)), i } computeTickLimit () { return Number.POSITIVE_INFINITY } buildTicks () { const t = this.options, e = t.ticks; let s = this.getTickLimit(); s = Math.max(2, s); const i = { maxTicks: s, bounds: t.bounds, min: t.min, max: t.max, precision: e.precision, step: e.stepSize, count: e.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: e.minRotation || 0, includeBounds: e.includeBounds !== !1 }, o = this._range || this, a = cv(i, o); return t.bounds === "ticks" && ec(a, this, "value"), t.reverse ? (a.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), a } configure () { const t = this.ticks; let e = this.min, s = this.max; if (super.configure(), this.options.offset && t.length) { const i = (s - e) / Math.max(t.length - 1, 1) / 2; e -= i, s += i } this._startValue = e, this._endValue = s, this._valueRange = s - e } getLabelForValue (t) { return us(t, this.chart.options.locale, this.options.ticks.format) } } class Mo extends ai { determineDataLimits () { const { min: t, max: e } = this.getMinMax(!0); this.min = Mt(t) ? t : 0, this.max = Mt(e) ? e : 1, this.handleTickRangeOptions() } computeTickLimit () { const t = this.isHorizontal(), e = t ? this.width : this.height, s = oe(this.options.ticks.minRotation), i = (t ? Math.sin(s) : Math.cos(s)) || .001, o = this._resolveTickFontOptions(0); return Math.ceil(e / Math.min(40, o.lineHeight / i)) } getPixelForValue (t) { return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getValueForPixel (t) { return this._startValue + this.getDecimalForPixel(t) * this._valueRange } } V(Mo, "id", "linear"), V(Mo, "defaults", { ticks: { callback: yi.formatters.numeric } }); const is = n => Math.floor(De(n)), qe = (n, t) => Math.pow(10, is(n) + t); function Qr (n) { return n / Math.pow(10, is(n)) === 1 } function Zr (n, t, e) { const s = Math.pow(10, e), i = Math.floor(n / s); return Math.ceil(t / s) - i } function dv (n, t) { const e = t - n; let s = is(e); for (; Zr(n, t, s) > 10;)s++; for (; Zr(n, t, s) < 10;)s--; return Math.min(s, is(n)) } function uv (n, { min: t, max: e }) { t = Xt(n.min, t); const s = [], i = is(t); let o = dv(t, e), a = o < 0 ? Math.pow(10, Math.abs(o)) : 1; const r = Math.pow(10, o), l = i > o ? Math.pow(10, i) : 0, c = Math.round((t - l) * a) / a, d = Math.floor((t - l) / r / 10) * r * 10; let u = Math.floor((c - d) / Math.pow(10, o)), h = Xt(n.min, Math.round((l + d + u * Math.pow(10, o)) * a) / a); for (; h < e;)s.push({ value: h, major: Qr(h), significand: u }), u >= 10 ? u = u < 15 ? 15 : 20 : u++, u >= 20 && (o++, u = 2, a = o >= 0 ? 1 : a), h = Math.round((l + d + u * Math.pow(10, o)) * a) / a; const f = Xt(n.max, h); return s.push({ value: f, major: Qr(f), significand: u }), s } class Po extends un { constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse (t, e) { const s = ai.prototype.parse.apply(this, [t, e]); if (s === 0) { this._zero = !0; return } return Mt(s) && s > 0 ? s : null } determineDataLimits () { const { min: t, max: e } = this.getMinMax(!0); this.min = Mt(t) ? Math.max(0, t) : null, this.max = Mt(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Mt(this._userMin) && (this.min = t === qe(this.min, 0) ? qe(this.min, -1) : qe(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions () { const { minDefined: t, maxDefined: e } = this.getUserBounds(); let s = this.min, i = this.max; const o = r => s = t ? s : r, a = r => i = e ? i : r; s === i && (s <= 0 ? (o(1), a(10)) : (o(qe(s, -1)), a(qe(i, 1)))), s <= 0 && o(qe(i, -1)), i <= 0 && a(qe(s, 1)), this.min = s, this.max = i } buildTicks () { const t = this.options, e = { min: this._userMin, max: this._userMax }, s = uv(e, this); return t.bounds === "ticks" && ec(s, this, "value"), t.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s } getLabelForValue (t) { return t === void 0 ? "0" : us(t, this.chart.options.locale, this.options.ticks.format) } configure () { const t = this.min; super.configure(), this._startValue = De(t), this._valueRange = De(this.max) - De(t) } getPixelForValue (t) { return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (De(t) - this._startValue) / this._valueRange) } getValueForPixel (t) { const e = this.getDecimalForPixel(t); return Math.pow(10, this._startValue + e * this._valueRange) } } V(Po, "id", "logarithmic"), V(Po, "defaults", { ticks: { callback: yi.formatters.logarithmic, major: { enabled: !0 } } }); function Co (n) { const t = n.ticks; if (t.display && n.display) { const e = Ht(t.backdropPadding); return tt(t.font && t.font.size, Pt.font.size) + e.height } return 0 } function hv (n, t, e) { return e = yt(e) ? e : [e], { w: yg(n, t.string, e), h: e.length * t.lineHeight } } function tl (n, t, e, s, i) { return n === s || n === i ? { start: t - e / 2, end: t + e / 2 } : n < s || n > i ? { start: t - e, end: t } : { start: t, end: t + e } } function fv (n) { const t = { l: n.left + n._padding.left, r: n.right - n._padding.right, t: n.top + n._padding.top, b: n.bottom - n._padding.bottom }, e = Object.assign({}, t), s = [], i = [], o = n._pointLabels.length, a = n.options.pointLabels, r = a.centerPointLabels ? mt / o : 0; for (let l = 0; l < o; l++) { const c = a.setContext(n.getPointLabelContext(l)); i[l] = c.padding; const d = n.getPointPosition(l, n.drawingArea + i[l], r), u = At(c.font), h = hv(n.ctx, u, n._pointLabels[l]); s[l] = h; const f = Gt(n.getIndexAngle(l) + r), g = Math.round(Uo(f)), m = tl(g, d.x, h.w, 0, 180), v = tl(g, d.y, h.h, 90, 270); pv(e, t, f, m, v) } n.setCenterPoint(t.l - e.l, e.r - t.r, t.t - e.t, e.b - t.b), n._pointLabelItems = bv(n, s, i) } function pv (n, t, e, s, i) { const o = Math.abs(Math.sin(e)), a = Math.abs(Math.cos(e)); let r = 0, l = 0; s.start < t.l ? (r = (t.l - s.start) / o, n.l = Math.min(n.l, t.l - r)) : s.end > t.r && (r = (s.end - t.r) / o, n.r = Math.max(n.r, t.r + r)), i.start < t.t ? (l = (t.t - i.start) / a, n.t = Math.min(n.t, t.t - l)) : i.end > t.b && (l = (i.end - t.b) / a, n.b = Math.max(n.b, t.b + l)) } function gv (n, t, e) { const s = n.drawingArea, { extra: i, additionalAngle: o, padding: a, size: r } = e, l = n.getPointPosition(t, s + i + a, o), c = Math.round(Uo(Gt(l.angle + Ct))), d = yv(l.y, r.h, c), u = vv(c), h = _v(l.x, r.w, u); return { visible: !0, x: l.x, y: d, textAlign: u, left: h, top: d, right: h + r.w, bottom: d + r.h } } function mv (n, t) { if (!t) return !0; const { left: e, top: s, right: i, bottom: o } = n; return !(ke({ x: e, y: s }, t) || ke({ x: e, y: o }, t) || ke({ x: i, y: s }, t) || ke({ x: i, y: o }, t)) } function bv (n, t, e) { const s = [], i = n._pointLabels.length, o = n.options, { centerPointLabels: a, display: r } = o.pointLabels, l = { extra: Co(o) / 2, additionalAngle: a ? mt / i : 0 }; let c; for (let d = 0; d < i; d++) { l.padding = e[d], l.size = t[d]; const u = gv(n, d, l); s.push(u), r === "auto" && (u.visible = mv(u, c), u.visible && (c = u)) } return s } function vv (n) { return n === 0 || n === 180 ? "center" : n < 180 ? "left" : "right" } function _v (n, t, e) { return e === "right" ? n -= t : e === "center" && (n -= t / 2), n } function yv (n, t, e) { return e === 90 || e === 270 ? n -= t / 2 : (e > 270 || e < 90) && (n -= t), n } function xv (n, t, e) { const { left: s, top: i, right: o, bottom: a } = e, { backdropColor: r } = t; if (!at(r)) { const l = en(t.borderRadius), c = Ht(t.backdropPadding); n.fillStyle = r; const d = s - c.left, u = i - c.top, h = o - s + c.width, f = a - i + c.height; Object.values(l).some(g => g !== 0) ? (n.beginPath(), ns(n, { x: d, y: u, w: h, h: f, radius: l }), n.fill()) : n.fillRect(d, u, h, f) } } function wv (n, t) { const { ctx: e, options: { pointLabels: s } } = n; for (let i = t - 1; i >= 0; i--) { const o = n._pointLabelItems[i]; if (!o.visible) continue; const a = s.setContext(n.getPointLabelContext(i)); xv(e, a, o); const r = At(a.font), { x: l, y: c, textAlign: d } = o; dn(e, n._pointLabels[i], l, c + r.lineHeight / 2, r, { color: a.color, textAlign: d, textBaseline: "middle" }) } } function Uc (n, t, e, s) { const { ctx: i } = n; if (e) i.arc(n.xCenter, n.yCenter, t, 0, gt); else { let o = n.getPointPosition(0, t); i.moveTo(o.x, o.y); for (let a = 1; a < s; a++)o = n.getPointPosition(a, t), i.lineTo(o.x, o.y) } } function kv (n, t, e, s, i) { const o = n.ctx, a = t.circular, { color: r, lineWidth: l } = t; !a && !s || !r || !l || e < 0 || (o.save(), o.strokeStyle = r, o.lineWidth = l, o.setLineDash(i.dash), o.lineDashOffset = i.dashOffset, o.beginPath(), Uc(n, e, a, s), o.closePath(), o.stroke(), o.restore()) } function Sv (n, t, e) { return We(n, { label: e, index: t, type: "pointLabel" }) } class Bn extends ai { constructor(t) { super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions () { const t = this._padding = Ht(Co(this.options) / 2), e = this.width = this.maxWidth - t.width, s = this.height = this.maxHeight - t.height; this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + s / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, s) / 2) } determineDataLimits () { const { min: t, max: e } = this.getMinMax(!1); this.min = Mt(t) && !isNaN(t) ? t : 0, this.max = Mt(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions() } computeTickLimit () { return Math.ceil(this.drawingArea / Co(this.options)) } generateTickLabels (t) { ai.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((e, s) => { const i = pt(this.options.pointLabels.callback, [e, s], this); return i || i === 0 ? i : "" }).filter((e, s) => this.chart.getDataVisibility(s)) } fit () { const t = this.options; t.display && t.pointLabels.display ? fv(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint (t, e, s, i) { this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((s - i) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, s, i)) } getIndexAngle (t) { const e = gt / (this._pointLabels.length || 1), s = this.options.startAngle || 0; return Gt(t * e + oe(s)) } getDistanceFromCenterForValue (t) { if (at(t)) return NaN; const e = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - t) * e : (t - this.min) * e } getValueForDistanceFromCenter (t) { if (at(t)) return NaN; const e = t / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - e : this.min + e } getPointLabelContext (t) { const e = this._pointLabels || []; if (t >= 0 && t < e.length) { const s = e[t]; return Sv(this.getContext(), t, s) } } getPointPosition (t, e, s = 0) { const i = this.getIndexAngle(t) - Ct + s; return { x: Math.cos(i) * e + this.xCenter, y: Math.sin(i) * e + this.yCenter, angle: i } } getPointPositionForValue (t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) } getBasePosition (t) { return this.getPointPositionForValue(t || 0, this.getBaseValue()) } getPointLabelPosition (t) { const { left: e, top: s, right: i, bottom: o } = this._pointLabelItems[t]; return { left: e, top: s, right: i, bottom: o } } drawBackground () { const { backgroundColor: t, grid: { circular: e } } = this.options; if (t) { const s = this.ctx; s.save(), s.beginPath(), Uc(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), s.closePath(), s.fillStyle = t, s.fill(), s.restore() } } drawGrid () { const t = this.ctx, e = this.options, { angleLines: s, grid: i, border: o } = e, a = this._pointLabels.length; let r, l, c; if (e.pointLabels.display && wv(this, a), i.display && this.ticks.forEach((d, u) => { if (u !== 0 || u === 0 && this.min < 0) { l = this.getDistanceFromCenterForValue(d.value); const h = this.getContext(u), f = i.setContext(h), g = o.setContext(h); kv(this, f, l, a, g) } }), s.display) { for (t.save(), r = a - 1; r >= 0; r--) { const d = s.setContext(this.getPointLabelContext(r)), { color: u, lineWidth: h } = d; !h || !u || (t.lineWidth = h, t.strokeStyle = u, t.setLineDash(d.borderDash), t.lineDashOffset = d.borderDashOffset, l = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), c = this.getPointPosition(r, l), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(c.x, c.y), t.stroke()) } t.restore() } } drawBorder () { } drawLabels () { const t = this.ctx, e = this.options, s = e.ticks; if (!s.display) return; const i = this.getIndexAngle(0); let o, a; t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(i), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((r, l) => { if (l === 0 && this.min >= 0 && !e.reverse) return; const c = s.setContext(this.getContext(l)), d = At(c.font); if (o = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) { t.font = d.string, a = t.measureText(r.label).width, t.fillStyle = c.backdropColor; const u = Ht(c.backdropPadding); t.fillRect(-a / 2 - u.left, -o - d.size / 2 - u.top, a + u.width, d.size + u.height) } dn(t, r.label, 0, -o, d, { color: c.color, strokeColor: c.textStrokeColor, strokeWidth: c.textStrokeWidth }) }), t.restore() } drawTitle () { } } V(Bn, "id", "radialLinear"), V(Bn, "defaults", { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: yi.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback (t) { return t }, padding: 5, centerPointLabels: !1 } }), V(Bn, "defaultRoutes", { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }), V(Bn, "descriptors", { angleLines: { _fallback: "grid" } }); const Si = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, Kt = Object.keys(Si); function el (n, t) { return n - t } function nl (n, t) { if (at(t)) return null; const e = n._adapter, { parser: s, round: i, isoWeekday: o } = n._parseOpts; let a = t; return typeof s == "function" && (a = s(a)), Mt(a) || (a = typeof s == "string" ? e.parse(a, s) : e.parse(a)), a === null ? null : (i && (a = i === "week" && (kn(o) || o === !0) ? e.startOf(a, "isoWeek", o) : e.startOf(a, i)), +a) } function sl (n, t, e, s) { const i = Kt.length; for (let o = Kt.indexOf(n); o < i - 1; ++o) { const a = Si[Kt[o]], r = a.steps ? a.steps : Number.MAX_SAFE_INTEGER; if (a.common && Math.ceil((e - t) / (r * a.size)) <= s) return Kt[o] } return Kt[i - 1] } function Mv (n, t, e, s, i) { for (let o = Kt.length - 1; o >= Kt.indexOf(e); o--) { const a = Kt[o]; if (Si[a].common && n._adapter.diff(i, s, a) >= t - 1) return a } return Kt[e ? Kt.indexOf(e) : 0] } function Pv (n) { for (let t = Kt.indexOf(n) + 1, e = Kt.length; t < e; ++t)if (Si[Kt[t]].common) return Kt[t] } function il (n, t, e) { if (!e) n[t] = !0; else if (e.length) { const { lo: s, hi: i } = Yo(e, t), o = e[s] >= t ? e[s] : e[i]; n[o] = !0 } } function Cv (n, t, e, s) { const i = n._adapter, o = +i.startOf(t[0].value, s), a = t[t.length - 1].value; let r, l; for (r = o; r <= a; r = +i.add(r, 1, s))l = e[r], l >= 0 && (t[l].major = !0); return t } function ol (n, t, e) { const s = [], i = {}, o = t.length; let a, r; for (a = 0; a < o; ++a)r = t[a], i[r] = a, s.push({ value: r, major: !1 }); return o === 0 || !e ? s : Cv(n, s, i, e) } class os extends un { constructor(t) { super(t), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init (t, e = {}) { const s = t.time || (t.time = {}), i = this._adapter = new Im._date(t.adapters.date); i.init(e), Wn(s.displayFormats, i.formats()), this._parseOpts = { parser: s.parser, round: s.round, isoWeekday: s.isoWeekday }, super.init(t), this._normalized = e.normalized } parse (t, e) { return t === void 0 ? null : nl(this, t) } beforeLayout () { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits () { const t = this.options, e = this._adapter, s = t.time.unit || "day"; let { min: i, max: o, minDefined: a, maxDefined: r } = this.getUserBounds(); function l (c) { !a && !isNaN(c.min) && (i = Math.min(i, c.min)), !r && !isNaN(c.max) && (o = Math.max(o, c.max)) } (!a || !r) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), i = Mt(i) && !isNaN(i) ? i : +e.startOf(Date.now(), s), o = Mt(o) && !isNaN(o) ? o : +e.endOf(Date.now(), s) + 1, this.min = Math.min(i, o - 1), this.max = Math.max(i + 1, o) } _getLabelBounds () { const t = this.getLabelTimestamps(); let e = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY; return t.length && (e = t[0], s = t[t.length - 1]), { min: e, max: s } } buildTicks () { const t = this.options, e = t.time, s = t.ticks, i = s.source === "labels" ? this.getLabelTimestamps() : this._generate(); t.bounds === "ticks" && i.length && (this.min = this._userMin || i[0], this.max = this._userMax || i[i.length - 1]); const o = this.min, a = this.max, r = rg(i, o, a); return this._unit = e.unit || (s.autoSkip ? sl(e.minUnit, this.min, this.max, this._getLabelCapacity(o)) : Mv(this, r.length, e.minUnit, this.min, this.max)), this._majorUnit = !s.major.enabled || this._unit === "year" ? void 0 : Pv(this._unit), this.initOffsets(i), t.reverse && r.reverse(), ol(this, r, this._majorUnit) } afterAutoSkip () { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(t => +t.value)) } initOffsets (t = []) { let e = 0, s = 0, i, o; this.options.offset && t.length && (i = this.getDecimalForValue(t[0]), t.length === 1 ? e = 1 - i : e = (this.getDecimalForValue(t[1]) - i) / 2, o = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? s = o : s = (o - this.getDecimalForValue(t[t.length - 2])) / 2); const a = t.length < 3 ? .5 : .25; e = Dt(e, 0, a), s = Dt(s, 0, a), this._offsets = { start: e, end: s, factor: 1 / (e + 1 + s) } } _generate () { const t = this._adapter, e = this.min, s = this.max, i = this.options, o = i.time, a = o.unit || sl(o.minUnit, e, s, this._getLabelCapacity(e)), r = tt(i.ticks.stepSize, 1), l = a === "week" ? o.isoWeekday : !1, c = kn(l) || l === !0, d = {}; let u = e, h, f; if (c && (u = +t.startOf(u, "isoWeek", l)), u = +t.startOf(u, c ? "day" : a), t.diff(s, e, a) > 1e5 * r) throw new Error(e + " and " + s + " are too far apart with stepSize of " + r + " " + a); const g = i.ticks.source === "data" && this.getDataTimestamps(); for (h = u, f = 0; h < s; h = +t.add(h, r, a), f++)il(d, h, g); return (h === s || i.bounds === "ticks" || f === 1) && il(d, h, g), Object.keys(d).sort(el).map(m => +m) } getLabelForValue (t) { const e = this._adapter, s = this.options.time; return s.tooltipFormat ? e.format(t, s.tooltipFormat) : e.format(t, s.displayFormats.datetime) } format (t, e) { const i = this.options.time.displayFormats, o = this._unit, a = e || i[o]; return this._adapter.format(t, a) } _tickFormatFunction (t, e, s, i) { const o = this.options, a = o.ticks.callback; if (a) return pt(a, [t, e, s], this); const r = o.time.displayFormats, l = this._unit, c = this._majorUnit, d = l && r[l], u = c && r[c], h = s[e], f = c && u && h && h.major; return this._adapter.format(t, i || (f ? u : d)) } generateTickLabels (t) { let e, s, i; for (e = 0, s = t.length; e < s; ++e)i = t[e], i.label = this._tickFormatFunction(i.value, e, t) } getDecimalForValue (t) { return t === null ? NaN : (t - this.min) / (this.max - this.min) } getPixelForValue (t) { const e = this._offsets, s = this.getDecimalForValue(t); return this.getPixelForDecimal((e.start + s) * e.factor) } getValueForPixel (t) { const e = this._offsets, s = this.getDecimalForPixel(t) / e.factor - e.end; return this.min + s * (this.max - this.min) } _getLabelSize (t) { const e = this.options.ticks, s = this.ctx.measureText(t).width, i = oe(this.isHorizontal() ? e.maxRotation : e.minRotation), o = Math.cos(i), a = Math.sin(i), r = this._resolveTickFontOptions(0).size; return { w: s * o + r * a, h: s * a + r * o } } _getLabelCapacity (t) { const e = this.options.time, s = e.displayFormats, i = s[e.unit] || s.millisecond, o = this._tickFormatFunction(t, 0, ol(this, [t], this._majorUnit), i), a = this._getLabelSize(o), r = Math.floor(this.isHorizontal() ? this.width / a.w : this.height / a.h) - 1; return r > 0 ? r : 1 } getDataTimestamps () { let t = this._cache.data || [], e, s; if (t.length) return t; const i = this.getMatchingVisibleMetas(); if (this._normalized && i.length) return this._cache.data = i[0].controller.getAllParsedValues(this); for (e = 0, s = i.length; e < s; ++e)t = t.concat(i[e].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(t) } getLabelTimestamps () { const t = this._cache.labels || []; let e, s; if (t.length) return t; const i = this.getLabels(); for (e = 0, s = i.length; e < s; ++e)t.push(nl(this, i[e])); return this._cache.labels = this._normalized ? t : this.normalize(t) } normalize (t) { return ic(t.sort(el)) } } V(os, "id", "time"), V(os, "defaults", { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }); function Ls (n, t, e) { let s = 0, i = n.length - 1, o, a, r, l; e ? (t >= n[s].pos && t <= n[i].pos && ({ lo: s, hi: i } = we(n, "pos", t)), { pos: o, time: r } = n[s], { pos: a, time: l } = n[i]) : (t >= n[s].time && t <= n[i].time && ({ lo: s, hi: i } = we(n, "time", t)), { time: o, pos: r } = n[s], { time: a, pos: l } = n[i]); const c = a - o; return c ? r + (l - r) * (t - o) / c : r } class To extends os { constructor(t) { super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets () { const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t); this._minPos = Ls(e, this.min), this._tableRange = Ls(e, this.max) - this._minPos, super.initOffsets(t) } buildLookupTable (t) { const { min: e, max: s } = this, i = [], o = []; let a, r, l, c, d; for (a = 0, r = t.length; a < r; ++a)c = t[a], c >= e && c <= s && i.push(c); if (i.length < 2) return [{ time: e, pos: 0 }, { time: s, pos: 1 }]; for (a = 0, r = i.length; a < r; ++a)d = i[a + 1], l = i[a - 1], c = i[a], Math.round((d + l) / 2) !== c && o.push({ time: c, pos: a / (r - 1) }); return o } _generate () { const t = this.min, e = this.max; let s = super.getDataTimestamps(); return (!s.includes(t) || !s.length) && s.splice(0, 0, t), (!s.includes(e) || s.length === 1) && s.push(e), s.sort((i, o) => i - o) } _getTimestampsForTable () { let t = this._cache.all || []; if (t.length) return t; const e = this.getDataTimestamps(), s = this.getLabelTimestamps(); return e.length && s.length ? t = this.normalize(e.concat(s)) : t = e.length ? e : s, t = this._cache.all = t, t } getDecimalForValue (t) { return (Ls(this._table, t) - this._minPos) / this._tableRange } getValueForPixel (t) { const e = this._offsets, s = this.getDecimalForPixel(t) / e.factor - e.end; return Ls(this._table, s * this._tableRange + this._minPos, !0) } } V(To, "id", "timeseries"), V(To, "defaults", os.defaults); var Tv = Object.freeze({ __proto__: null, CategoryScale: So, LinearScale: Mo, LogarithmicScale: Po, RadialLinearScale: Bn, TimeScale: os, TimeSeriesScale: To }); const Ov = [Rm, ub, ov, Tv]; ye.register(...Ov); const Lv = _("h3", { class: "text-lg font-medium leading-6 text-gray-900" }, " Last 30 days ", -1), Av = { class: "grid grid-cols-1 gap-5 mt-5 sm:grid-cols-3" }, $v = { class: "px-4 py-5 overflow-hidden bg-white rounded-lg shadow sm:p-6 dark:bg-gray-700" }, Dv = _("dt", { class: "text-sm font-medium text-gray-500 truncate dark:text-gray-300" }, " Keys ", -1), Ev = { class: "mt-1 text-3xl font-semibold text-gray-600 dark:text-white" }, Rv = { class: "px-4 py-5 overflow-hidden bg-white rounded-lg shadow sm:p-6 dark:bg-gray-700" }, Iv = _("dt", { class: "text-sm font-medium text-gray-500 truncate dark:text-gray-300" }, " Usage Rate ", -1), Nv = { class: "mt-1 text-3xl font-semibold text-gray-600 dark:text-white" }, Fv = { class: "px-4 py-5 overflow-hidden bg-white rounded-lg shadow dark:bg-gray-700 sm:p-6" }, Vv = _("dt", { class: "text-sm font-medium text-gray-500 truncate dark:text-gray-300" }, " Daily Usage ", -1), Bv = { class: "mt-1 text-3xl font-semibold text-gray-600 dark:text-white" }, zv = { class: "col-span-3 px-4 py-5 bg-white rounded-lg shadow dark:bg-gray-700 sm:p-6" }, jv = z({ __name: "PageDashboard", setup (n) { const { isDark: t } = Pn(), e = et(), { data: s, update: i, loading: o } = Bo((a, r) => Ve.Get("v1/account/dashboard", { hitSource: [/^createKey/], transform: l => l.data, params: { page: a, limit: r } }), { initialData: { usage: 0, dailyUsage: 0, weeklyUsage: 0, totalKeys: 0, usageRate: 0, usageTrend: [] } }).onSuccess(({ data: a }) => { e.value && new ye(e.value, { type: "line", data: { labels: a.usageTrend.map(r => r.month), datasets: [{ data: a.usageTrend.map(r => r.usageRate), tension: .3, borderColor: t.value ? "#fff" : "green" }] }, options: { responsive: !0, plugins: { title: { display: !0, text: "Usage Rate for the last 6 months", color: t.value ? "#d1d5db" : "#6b7280", font: { size: 14, weight: 500 } }, legend: { display: !1 }, tooltip: { callbacks: { label: function (r) { return r.formattedValue + "%" } } } }, scales: { x: { grid: { color: "#8388918c" }, ticks: { color: t.value ? "#fff" : "#666666" } }, y: { grid: { color: "#8388918c" }, ticks: { color: t.value ? "#fff" : "#666666" } } } } }) }); return (a, r) => (M(), O("div", null, [Lv, _("dl", Av, [_("div", $v, [Dv, _("dd", Ev, q(P(s).totalKeys), 1)]), _("div", Rv, [Iv, _("dd", Nv, q(P(s).usageRate) + "% ", 1)]), _("div", Fv, [Vv, _("dd", Bv, q(P(s).dailyUsage), 1)]), _("div", zv, [_("canvas", { ref_key: "usageTrend", ref: e }, null, 512)])])])) } }), Hv = Object.freeze(Object.defineProperty({ __proto__: null, default: jv }, Symbol.toStringTag, { value: "Module" })), Wv = { class: "flex flex-col justify-center min-h-full py-12 sm:px-6 lg:px-8" }, Uv = { class: "sm:mx-auto sm:w-full sm:max-w-md" }, Yv = { href: "/" }, Kv = ["src"], qv = _("h2", { class: "mt-6 text-3xl font-extrabold text-center text-gray-900 dark:text-white" }, " Sign in to your account ", -1), Xv = _("p", { class: "mt-2 text-sm text-center text-gray-600 dark:text-white" }, [Lt(" Or "), _("a", { href: "/portal/register", class: "font-medium text-primary hover:text-green-800 dark:text-gray-300 dark:hover:text-gray-100" }, " create a new account ")], -1), Gv = { class: "mt-8 sm:mx-auto sm:w-full sm:max-w-md" }, Jv = { class: "px-4 py-8 bg-white shadow dark:bg-black sm:rounded-lg sm:px-10" }, Qv = _("label", { for: "email", class: "block text-sm font-medium text-gray-700 dark:text-white" }, " Email address ", -1), Zv = { class: "mt-1" }, t_ = { key: 0, class: "mt-2 text-sm text-red-700" }, e_ = _("label", { for: "password", class: "block text-sm font-medium text-gray-700 dark:text-white" }, " Password ", -1), n_ = { class: "mt-1" }, s_ = { key: 0, class: "mt-2 text-sm text-red-700" }, i_ = _("div", { class: "flex items-center justify-between" }, [_("div", { class: "flex items-center" }), _("div", { class: "text-sm" }, [_("a", { href: "/portal/reset-password", class: "font-medium text-primary hover:text-primary" }, " Forgot your password? ")])], -1), o_ = z({ __name: "PageLogin", setup (n) { var c; const t = Gn(), e = K(() => { var d; return (d = a.value) == null ? void 0 : d.errors }); (c = K(() => Jt().user).value) != null && c.id && t.go("/portal/home"); const { send: i, form: o, error: a, loading: r } = _i(d => { const u = Ve.Post("v1/auth/login", d); return u.meta = { authRole: "login" }, u }, { store: !0, initialForm: { email: "", password: "" } }).onSuccess(() => { t.go("/portal/home") }).onError(({ error: d }) => { wn(d.message, "failure") }), { site: l } = Pn(); return (d, u) => { var f, g; const h = Qt("CButton"); return M(), O("div", Wv, [_("div", Uv, [_("a", Yv, [_("img", { class: "w-auto h-20 mx-auto", src: P(l).themeConfig.logo, alt: "Logo" }, null, 8, Kv)]), qv, Xv]), _("div", Gv, [_("div", Jv, [_("form", { onSubmit: u[2] || (u[2] = sn((...m) => P(i) && P(i)(...m), ["prevent"])), class: "space-y-6" }, [_("div", null, [Qv, _("div", Zv, [Wt(_("input", { "onUpdate:modelValue": u[0] || (u[0] = m => P(o).email = m), id: "email", type: "email", autocomplete: "email", required: "", class: "block w-full px-3 py-2 placeholder-gray-400 border border-gray-300 border-solid rounded-md appearance-none dark:border-gray-800 dark:bg-slate-950 focus:outline-none focus:ring-primary focus:border-primary sm:text-sm" }, null, 512), [[se, P(o).email]]), (f = e.value) != null && f.email ? (M(), O("p", t_, q(e.value.email), 1)) : N("", !0)])]), _("div", null, [e_, _("div", n_, [Wt(_("input", { "onUpdate:modelValue": u[1] || (u[1] = m => P(o).password = m), id: "password", type: "password", autocomplete: "current-password", required: "", class: "block w-full px-3 py-2 placeholder-gray-400 border border-gray-300 border-solid rounded-md appearance-none dark:border-gray-800 focus:outline-none focus:ring-primary dark:bg-slate-950 focus:border-primary sm:text-sm" }, null, 512), [[se, P(o).password]]), (g = e.value) != null && g.password ? (M(), O("p", s_, q(e.value.password), 1)) : N("", !0)])]), i_, _("div", null, [j(h, { type: "submit", label: "Sign in", loading: P(r), class: "w-full text-white focus:ring-primary bg-primary hover:bg-green-800" }, null, 8, ["loading"])])], 32)])])]) } } }), a_ = Object.freeze(Object.defineProperty({ __proto__: null, default: o_ }, Symbol.toStringTag, { value: "Module" })), r_ = { class: "flex flex-col justify-center min-h-full py-12 sm:px-6 lg:px-8" }, l_ = { class: "sm:mx-auto sm:w-full sm:max-w-md" }, c_ = { href: "/" }, d_ = ["src"], u_ = _("h2", { class: "mt-6 text-3xl font-extrabold text-center text-gray-900 dark:text-white" }, " Account Recovery ", -1), h_ = _("p", { class: "mt-2 text-sm text-center text-gray-600 dark:text-white" }, " We'll help you recover your account ", -1), f_ = { class: "mt-8 sm:mx-auto sm:w-full sm:max-w-md" }, p_ = { class: "px-4 py-8 bg-white shadow dark:bg-black sm:rounded-lg sm:px-10" }, g_ = { key: 0 }, m_ = _("label", { for: "email", class: "block text-sm font-medium text-gray-700 dark:text-white" }, " Email address ", -1), b_ = { class: "mt-1" }, v_ = { key: 0, class: "mt-2 text-sm text-red-700" }, __ = { key: 1 }, y_ = _("label", { for: "email", class: "block text-sm font-medium text-gray-700 dark:text-white" }, " Recovery Code ", -1), x_ = { class: "mt-1" }, w_ = { key: 0, class: "mt-2 text-sm text-red-700" }, k_ = _("label", { for: "password", class: "block text-sm font-medium text-gray-700 dark:text-white" }, " Password ", -1), S_ = { class: "mt-1" }, M_ = { key: 0, class: "mt-2 text-sm text-red-700" }, P_ = _("label", { for: "password", class: "block text-sm font-medium text-gray-700 dark:text-white" }, " Repeat Password ", -1), C_ = { class: "mt-1" }, T_ = { key: 0, class: "mt-2 text-sm text-red-700" }, O_ = { key: 3, class: "flex items-center justify-between" }, L_ = { class: "flex items-center" }, A_ = _("div", { class: "text-sm" }, [_("a", { href: "/portal/login", class: "font-medium text-primary hover:text-primary" }, " Login Instead ")], -1), $_ = z({ __name: "PagePasswordReset", setup (n) { var h; const t = et(1), e = Gn(), s = K(() => { var f; return (f = r.value) == null ? void 0 : f.errors }); (h = K(() => Jt().user).value) != null && h.id && e.go("/portal/home"); const { send: o, form: a, error: r, data: l, reset: c, loading: d } = _i(f => { let g = "v1/auth/forgot-password"; t.value >= 2 && (g = `v1/auth/reset-password/${f != null && f.password ? "" : "check-code"}`); const m = Ve.Post(g, f); return m.meta = { authRole: null }, m }, { store: !0, initialForm: { code: null, email: null, password: null, password_confirmation: null } }).onSuccess(() => { t.value === 3 ? (t.value = 4, c()) : t.value === 2 ? t.value = 3 : t.value === 1 ? t.value = 2 : t.value = 1 }).onError(({ error: f }) => { wn(f.message, "failure") }), { site: u } = Pn(); return (f, g) => { var p, b, y, k, w, L, A, x, S, C; const m = Qt("CAlert"), v = Qt("CButton"); return M(), O("div", r_, [_("div", l_, [_("a", c_, [_("img", { class: "w-auto h-20 mx-auto", src: P(u).themeConfig.logo, alt: "Logo" }, null, 8, d_)]), u_, h_]), _("div", f_, [_("div", p_, [_("form", { onSubmit: g[5] || (g[5] = sn((...T) => P(o) && P(o)(...T), ["prevent"])), class: "space-y-6" }, [j(m, { showing: !!((b = (p = P(r)) == null ? void 0 : p.data) != null && b.message) || !!((y = P(l)) != null && y.message), message: ((w = (k = P(r)) == null ? void 0 : k.data) == null ? void 0 : w.message) || ((L = P(l)) == null ? void 0 : L.message), type: P(r) ? "error" : "success" }, null, 8, ["showing", "message", "type"]), t.value === 1 ? (M(), O("div", g_, [m_, _("div", b_, [Wt(_("input", { "onUpdate:modelValue": g[0] || (g[0] = T => P(a).email = T), id: "email", type: "email", autocomplete: "email", required: "", class: "block w-full px-3 py-2 placeholder-gray-400 border border-gray-300 border-solid rounded-md appearance-none dark:border-gray-800 dark:bg-slate-950 focus:outline-none focus:ring-primary focus:border-primary sm:text-sm" }, null, 512), [[se, P(a).email]]), (A = s.value) != null && A.email ? (M(), O("p", v_, q(s.value.email), 1)) : N("", !0)])])) : t.value === 2 ? (M(), O("div", __, [y_, _("div", x_, [Wt(_("input", { "onUpdate:modelValue": g[1] || (g[1] = T => P(a).code = T), id: "code", type: "text", required: "", class: "block w-full px-3 py-2 placeholder-gray-400 border border-gray-300 border-solid rounded-md appearance-none dark:border-gray-800 dark:bg-slate-950 focus:outline-none focus:ring-primary focus:border-primary sm:text-sm" }, null, 512), [[se, P(a).code]]), (x = s.value) != null && x.code ? (M(), O("p", w_, q(s.value.code), 1)) : N("", !0)])])) : t.value === 3 ? (M(), O(dt, { key: 2 }, [_("div", null, [k_, _("div", S_, [Wt(_("input", { "onUpdate:modelValue": g[2] || (g[2] = T => P(a).password = T), id: "password", type: "password", autocomplete: "current-password", required: "", class: "block w-full px-3 py-2 placeholder-gray-400 border border-gray-300 border-solid rounded-md appearance-none dark:border-gray-800 focus:outline-none focus:ring-primary dark:bg-slate-950 focus:border-primary sm:text-sm" }, null, 512), [[se, P(a).password]]), (S = s.value) != null && S.password ? (M(), O("p", M_, q(s.value.password), 1)) : N("", !0)])]), _("div", null, [P_, _("div", C_, [Wt(_("input", { "onUpdate:modelValue": g[3] || (g[3] = T => P(a).password_confirmation = T), id: "password", type: "password", autocomplete: "current-password", required: "", class: "block w-full px-3 py-2 placeholder-gray-400 border border-gray-300 border-solid rounded-md appearance-none dark:border-gray-800 focus:outline-none focus:ring-primary dark:bg-slate-950 focus:border-primary sm:text-sm" }, null, 512), [[se, P(a).password_confirmation]]), (C = s.value) != null && C.password_confirmation ? (M(), O("p", T_, q(s.value.password_confirmation), 1)) : N("", !0)])])], 64)) : N("", !0), t.value < 4 ? (M(), O("div", O_, [_("div", L_, [t.value === 2 ? (M(), W(v, { key: 0, label: "Resend", class: "w-full text-gray-600 border-gray-400 border-solid focus:ring-gray-500 dark:border-white dark:hover:border-gray-400 dark:hover:text-gray-400 dark:text-white hover:text-gray-400 hover:border-gray-400", onClick: g[4] || (g[4] = T => (t.value = 1, P(l).message = null)) })) : N("", !0)]), A_])) : N("", !0), _("div", null, [t.value < 4 ? (M(), W(v, { key: 0, label: "Request", type: "submit", loading: P(d), class: "w-full text-white focus:ring-primary bg-primary hover:bg-green-800" }, null, 8, ["loading"])) : (M(), W(v, { key: 1, href: "/portal/login", class: "w-full text-white focus:ring-primary bg-primary hover:bg-green-800" }, { default: D(() => [Lt(" Continue to login ")]), _: 1 }))])], 32)])])]) } } }), D_ = Object.freeze(Object.defineProperty({ __proto__: null, default: $_ }, Symbol.toStringTag, { value: "Module" })), E_ = { class: "flex flex-col justify-center min-h-full py-12 sm:px-6 lg:px-8" }, R_ = { class: "sm:mx-auto sm:w-full sm:max-w-md" }, I_ = { href: "/" }, N_ = ["src"], F_ = _("h2", { class: "mt-6 text-3xl font-extrabold text-center text-gray-900 dark:text-white" }, " Create your account ", -1), V_ = _("p", { class: "mt-2 text-sm text-center text-gray-600 dark:text-white" }, [Lt(" Or "), _("a", { href: "/portal/login", class: "font-medium text-primary hover:text-green-800 dark:text-gray-300 dark:hover:text-gray-100" }, " login to your existing account ")], -1), B_ = { class: "mt-8 sm:mx-auto sm:w-full sm:max-w-md" }, z_ = { class: "px-4 py-8 bg-white shadow dark:bg-black sm:rounded-lg sm:px-10" }, j_ = _("label", { for: "email", class: "block text-sm font-medium text-gray-700 dark:text-white" }, " Fullname ", -1), H_ = { class: "mt-1" }, W_ = { key: 0, class: "mt-2 text-sm text-red-700" }, U_ = _("label", { for: "email", class: "block text-sm font-medium text-gray-700 dark:text-white" }, " Email address ", -1), Y_ = { class: "mt-1" }, K_ = { key: 0, class: "mt-2 text-sm text-red-700" }, q_ = _("label", { for: "password", class: "block text-sm font-medium text-gray-700 dark:text-white" }, " Password ", -1), X_ = { class: "mt-1" }, G_ = { key: 0, class: "mt-2 text-sm text-red-700" }, J_ = _("label", { for: "password", class: "block text-sm font-medium text-gray-700 dark:text-white" }, " Repeat Password ", -1), Q_ = { class: "mt-1" }, Z_ = { key: 0, class: "mt-2 text-sm text-red-700" }, ty = z({ __name: "PageRegister", setup (n) { var c; const t = Gn(), e = K(() => { var d; return (d = a.value) == null ? void 0 : d.errors }); (c = K(() => Jt().user).value) != null && c.id && t.go("/portal/home"); const { send: i, form: o, error: a, loading: r } = _i(d => { const u = Ve.Post("v1/auth/register", d); return u.meta = { authRole: "login" }, u }, { store: !0, initialForm: { name: "", email: "", password: "", password_confirmation: "" } }).onSuccess(() => { t.go("/portal/home") }).onError(({ error: d }) => { wn(d.message, "failure") }), { site: l } = Pn(); return (d, u) => { var f, g, m, v; const h = Qt("CButton"); return M(), O("div", E_, [_("div", R_, [_("a", I_, [_("img", { class: "w-auto h-20 mx-auto", src: P(l).themeConfig.logo, alt: "Logo" }, null, 8, N_)]), F_, V_]), _("div", B_, [_("div", z_, [_("form", { onSubmit: u[4] || (u[4] = sn((...p) => P(i) && P(i)(...p), ["prevent"])), class: "space-y-6" }, [_("div", null, [j_, _("div", H_, [Wt(_("input", { "onUpdate:modelValue": u[0] || (u[0] = p => P(o).name = p), id: "name", type: "text", autocomplete: "name", required: "", class: "block w-full px-3 py-2 placeholder-gray-400 border border-gray-300 border-solid rounded-md appearance-none dark:border-gray-800 dark:bg-slate-950 focus:outline-none focus:ring-primary focus:border-primary sm:text-sm" }, null, 512), [[se, P(o).name]]), (f = e.value) != null && f.name ? (M(), O("p", W_, q(e.value.name), 1)) : N("", !0)])]), _("div", null, [U_, _("div", Y_, [Wt(_("input", { "onUpdate:modelValue": u[1] || (u[1] = p => P(o).email = p), id: "email", type: "email", autocomplete: "email", required: "", class: "block w-full px-3 py-2 placeholder-gray-400 border border-gray-300 border-solid rounded-md appearance-none dark:border-gray-800 dark:bg-slate-950 focus:outline-none focus:ring-primary focus:border-primary sm:text-sm" }, null, 512), [[se, P(o).email]]), (g = e.value) != null && g.email ? (M(), O("p", K_, q(e.value.email), 1)) : N("", !0)])]), _("div", null, [q_, _("div", X_, [Wt(_("input", { "onUpdate:modelValue": u[2] || (u[2] = p => P(o).password = p), id: "password", type: "password", autocomplete: "new-password", required: "", class: "block w-full px-3 py-2 placeholder-gray-400 border border-gray-300 border-solid rounded-md appearance-none dark:border-gray-800 focus:outline-none focus:ring-primary dark:bg-slate-950 focus:border-primary sm:text-sm" }, null, 512), [[se, P(o).password]]), (m = e.value) != null && m.password ? (M(), O("p", G_, q(e.value.password), 1)) : N("", !0)])]), _("div", null, [J_, _("div", Q_, [Wt(_("input", { "onUpdate:modelValue": u[3] || (u[3] = p => P(o).password_confirmation = p), id: "password_confirmation", type: "password", autocomplete: "new-password", required: "", class: "block w-full px-3 py-2 placeholder-gray-400 border border-gray-300 border-solid rounded-md appearance-none dark:border-gray-800 focus:outline-none focus:ring-primary dark:bg-slate-950 focus:border-primary sm:text-sm" }, null, 512), [[se, P(o).password_confirmation]]), (v = e.value) != null && v.password_confirmation ? (M(), O("p", Z_, q(e.value.password_confirmation), 1)) : N("", !0)])]), _("div", null, [j(h, { type: "submit", label: "Register", loading: P(r), class: "w-full text-white focus:ring-primary bg-primary hover:bg-green-800" }, null, 8, ["loading"])])], 32)])])]) } } }), ey = Object.freeze(Object.defineProperty({ __proto__: null, default: ty }, Symbol.toStringTag, { value: "Module" })), ny = z({ __name: "VPBadge", props: { text: {}, type: { default: "tip" } }, setup (n) { return (t, e) => (M(), O("span", { class: Q(["VPBadge", t.type]) }, [$(t.$slots, "default", {}, () => [Lt(q(t.text), 1)])], 2)) } }), sy = { key: 0, class: "VPBackdrop" }, iy = z({ __name: "VPBackdrop", props: { show: { type: Boolean } }, setup (n) { return (t, e) => (M(), W(li, { name: "fade" }, { default: D(() => [t.show ? (M(), O("div", sy)) : N("", !0)]), _: 1 })) } }), oy = J(iy, [["__scopeId", "data-v-54a304ca"]]), it = Pn; function ay (n, t) { let e, s = !1; return () => { e && clearTimeout(e), s ? e = setTimeout(n, t) : (n(), (s = !0) && setTimeout(() => s = !1, t)) } } function Oo (n) { return /^\//.test(n) ? n : `/${n}` } function ia (n) { const { pathname: t, search: e, hash: s, protocol: i } = new URL(n, "http://a.com"); if (gd(n) || n.startsWith("#") || !i.startsWith("http") || !md(t)) return n; const { site: o } = it(), a = t.endsWith("/") || t.endsWith(".html") ? n : n.replace(/(?:(^\.+)\/)?.*$/, `$1${t.replace(/(\.md)?$/, o.value.cleanUrls ? "" : ".html")}${e}${s}`); return $o(a) } function fs ({ correspondingLink: n = !1 } = {}) { const { site: t, localeIndex: e, page: s, theme: i, hash: o } = it(), a = K(() => { var l, c; return { label: (l = t.value.locales[e.value]) == null ? void 0 : l.label, link: ((c = t.value.locales[e.value]) == null ? void 0 : c.link) || (e.value === "root" ? "/" : `/${e.value}/`) } }); return { localeLinks: K(() => Object.entries(t.value.locales).flatMap(([l, c]) => a.value.label === c.label ? [] : { text: c.label, link: ry(c.link || (l === "root" ? "/" : `/${l}/`), i.value.i18nRouting !== !1 && n, s.value.relativePath.slice(a.value.link.length - 1), !t.value.cleanUrls) + o.value })), currentLang: a } } function ry (n, t, e, s) { return t ? n.replace(/\/$/, "") + Oo(e.replace(/(^|\/)index\.md$/, "$1").replace(/\.md$/, s ? ".html" : "")) : n } const ly = n => (Ft("data-v-6ff51ddd"), n = n(), Vt(), n), cy = { class: "NotFound" }, dy = { class: "code" }, uy = { class: "title" }, hy = ly(() => _("div", { class: "divider" }, null, -1)), fy = { class: "quote" }, py = { class: "action" }, gy = ["href", "aria-label"], my = z({ __name: "NotFound", setup (n) { const { theme: t } = it(), { currentLang: e } = fs(); return (s, i) => { var o, a, r, l, c; return M(), O("div", cy, [_("p", dy, q(((o = P(t).notFound) == null ? void 0 : o.code) ?? "404"), 1), _("h1", uy, q(((a = P(t).notFound) == null ? void 0 : a.title) ?? "PAGE NOT FOUND"), 1), hy, _("blockquote", fy, q(((r = P(t).notFound) == null ? void 0 : r.quote) ?? "But if you don't change your direction, and if you keep looking, you may end up where you are heading."), 1), _("div", py, [_("a", { class: "link", href: P($o)(P(e).link), "aria-label": ((l = P(t).notFound) == null ? void 0 : l.linkLabel) ?? "go to home" }, q(((c = P(t).notFound) == null ? void 0 : c.linkText) ?? "Take me home"), 9, gy)])]) } } }), by = J(my, [["__scopeId", "data-v-6ff51ddd"]]); function Yc (n, t) { if (Array.isArray(n)) return Hs(n); if (n == null) return []; t = Oo(t); const e = Object.keys(n).sort((i, o) => o.split("/").length - i.split("/").length).find(i => t.startsWith(Oo(i))), s = e ? n[e] : []; return Array.isArray(s) ? Hs(s) : Hs(s.items, s.base) } function vy (n) { const t = []; let e = 0; for (const s in n) { const i = n[s]; if (i.items) { e = t.push(i); continue } t[e] || t.push({ items: [] }), t[e].items.push(i) } return t } function _y (n) { const t = []; function e (s) { for (const i of s) i.text && i.link && t.push({ text: i.text, link: i.link, docFooterText: i.docFooterText }), i.items && e(i.items) } return e(n), t } function Lo (n, t) { return Array.isArray(t) ? t.some(e => Lo(n, e)) : on(n, t.link) ? !0 : t.items ? Lo(n, t.items) : !1 } function Hs (n, t) { return [...n].map(e => { const s = { ...e }, i = s.base || t; return i && s.link && (s.link = i + s.link), s.items && (s.items = Hs(s.items, i)), s }) } function Ce () { const { frontmatter: n, page: t, theme: e } = it(), s = Qi("(min-width: 960px)"), i = et(!1), o = K(() => { const m = e.value.sidebar, v = t.value.relativePath; return m ? Yc(m, v) : [] }), a = et(o.value); ne(o, (m, v) => { JSON.stringify(m) !== JSON.stringify(v) && (a.value = o.value) }); const r = K(() => n.value.sidebar !== !1 && a.value.length > 0 && n.value.layout !== "home"), l = K(() => c ? n.value.aside == null ? e.value.aside === "left" : n.value.aside === "left" : !1), c = K(() => n.value.layout === "home" ? !1 : n.value.aside != null ? !!n.value.aside : e.value.aside !== !1), d = K(() => r.value && s.value), u = K(() => r.value ? vy(a.value) : []); function h () { i.value = !0 } function f () { i.value = !1 } function g () { i.value ? f() : h() } return { isOpen: i, sidebar: a, sidebarGroups: u, hasSidebar: r, hasAside: c, leftAside: l, isSidebarEnabled: d, open: h, close: f, toggle: g } } function yy (n, t) { let e; ci(() => { e = n.value ? document.activeElement : void 0 }), Se(() => { window.addEventListener("keyup", s) }), Xn(() => { window.removeEventListener("keyup", s) }); function s (i) { i.key === "Escape" && n.value && (t(), e == null || e.focus()) } } function xy (n) { const { page: t, hash: e } = it(), s = et(!1), i = K(() => n.value.collapsed != null), o = K(() => !!n.value.link), a = et(!1), r = () => { a.value = on(t.value.relativePath, n.value.link) }; ne([t, n, e], r), Se(r); const l = K(() => a.value ? !0 : n.value.items ? Lo(t.value.relativePath, n.value.items) : !1), c = K(() => !!(n.value.items && n.value.items.length)); ci(() => { s.value = !!(i.value && n.value.collapsed) }), Do(() => { (a.value || l.value) && (s.value = !1) }); function d () { i.value && (s.value = !s.value) } return { collapsed: s, collapsible: i, isLink: o, isActiveLink: a, hasActiveLink: l, hasChildren: c, toggle: d } } function wy () { const { hasSidebar: n } = Ce(), t = Qi("(min-width: 960px)"), e = Qi("(min-width: 1280px)"); return { isAsideEnabled: K(() => !e.value && !t.value ? !1 : n.value ? e.value : t.value) } } const Ao = []; function Kc (n) { return typeof n.outline == "object" && !Array.isArray(n.outline) && n.outline.label || n.outlineTitle || "On this page" } function oa (n) { const t = [...document.querySelectorAll(".VPDoc :where(h1,h2,h3,h4,h5,h6)")].filter(e => e.id && e.hasChildNodes()).map(e => { const s = Number(e.tagName[1]); return { element: e, title: ky(e), link: "#" + e.id, level: s } }); return Sy(t, n) } function ky (n) { let t = ""; for (const e of n.childNodes) if (e.nodeType === 1) { if (e.classList.contains("VPBadge") || e.classList.contains("header-anchor") || e.classList.contains("ignore-header")) continue; t += e.textContent } else e.nodeType === 3 && (t += e.textContent); return t.trim() } function Sy (n, t) { if (t === !1) return []; const e = (typeof t == "object" && !Array.isArray(t) ? t.level : t) || 2, [s, i] = typeof e == "number" ? [e, e] : e === "deep" ? [2, 6] : e; n = n.filter(a => a.level >= s && a.level <= i), Ao.length = 0; for (const { element: a, link: r } of n) Ao.push({ element: a, link: r }); const o = []; t: for (let a = 0; a < n.length; a++) { const r = n[a]; if (a === 0) o.push(r); else { for (let l = a - 1; l >= 0; l--) { const c = n[l]; if (c.level < r.level) { (c.children || (c.children = [])).push(r); continue t } } o.push(r) } } return o } function My (n, t) { const { isAsideEnabled: e } = wy(), s = ay(o, 100); let i = null; Se(() => { requestAnimationFrame(o), window.addEventListener("scroll", s) }), bd(() => { a(location.hash) }), Xn(() => { window.removeEventListener("scroll", s) }); function o () { if (!e.value) return; const r = window.scrollY, l = window.innerHeight, c = document.body.offsetHeight, d = Math.abs(r + l - c) < 1, u = Ao.map(({ element: f, link: g }) => ({ link: g, top: Py(f) })).filter(({ top: f }) => !Number.isNaN(f)).sort((f, g) => f.top - g.top); if (!u.length) { a(null); return } if (r < 1) { a(null); return } if (d) { a(u[u.length - 1].link); return } let h = null; for (const { link: f, top: g } of u) { if (g > r + vd() + 4) break; h = f } a(h) } function a (r) { i && i.classList.remove("active"), r == null ? i = null : i = n.value.querySelector(`a[href="${decodeURIComponent(r)}"]`); const l = i; l ? (l.classList.add("active"), t.value.style.top = l.offsetTop + 39 + "px", t.value.style.opacity = "1") : (t.value.style.top = "33px", t.value.style.opacity = "0") } } function Py (n) { let t = 0; for (; n !== document.body;) { if (n === null) return NaN; t += n.offsetTop, n = n.offsetParent } return t } const Cy = ["href", "title"], Ty = z({ __name: "VPDocOutlineItem", props: { headers: {}, root: { type: Boolean } }, setup (n) { function t ({ target: e }) { const s = e.href.split("#")[1], i = document.getElementById(decodeURIComponent(s)); i == null || i.focus({ preventScroll: !0 }) } return (e, s) => { const i = Qt("VPDocOutlineItem", !0); return M(), O("ul", { class: Q(["VPDocOutlineItem", e.root ? "root" : "nested"]) }, [(M(!0), O(dt, null, Et(e.headers, ({ children: o, link: a, title: r }) => (M(), O("li", null, [_("a", { class: "outline-link", href: a, onClick: t, title: r }, q(r), 9, Cy), o != null && o.length ? (M(), W(i, { key: 0, headers: o }, null, 8, ["headers"])) : N("", !0)]))), 256))], 2) } } }), qc = J(Ty, [["__scopeId", "data-v-53c99d69"]]), Oy = { class: "content" }, Ly = { "aria-level": "2", class: "outline-title", id: "doc-outline-aria-label", role: "heading" }, Ay = z({ __name: "VPDocAsideOutline", setup (n) { const { frontmatter: t, theme: e } = it(), s = gl([]); di(() => { s.value = oa(t.value.outline ?? e.value.outline) }); const i = et(), o = et(); return My(i, o), (a, r) => (M(), O("nav", { "aria-labelledby": "doc-outline-aria-label", class: Q(["VPDocAsideOutline", { "has-outline": s.value.length > 0 }]), ref_key: "container", ref: i }, [_("div", Oy, [_("div", { class: "outline-marker", ref_key: "marker", ref: o }, null, 512), _("div", Ly, q(P(Kc)(P(e))), 1), j(qc, { headers: s.value, root: !0 }, null, 8, ["headers"])])], 2)) } }), $y = J(Ay, [["__scopeId", "data-v-f610f197"]]), Dy = { class: "VPDocAsideCarbonAds" }, Ey = z({ __name: "VPDocAsideCarbonAds", props: { carbonAds: {} }, setup (n) { const t = () => null; return (e, s) => (M(), O("div", Dy, [j(P(t), { "carbon-ads": e.carbonAds }, null, 8, ["carbon-ads"])])) } }), Ry = n => (Ft("data-v-cb998dce"), n = n(), Vt(), n), Iy = { class: "VPDocAside" }, Ny = Ry(() => _("div", { class: "spacer" }, null, -1)), Fy = z({ __name: "VPDocAside", setup (n) { const { theme: t } = it(); return (e, s) => (M(), O("div", Iy, [$(e.$slots, "aside-top", {}, void 0, !0), $(e.$slots, "aside-outline-before", {}, void 0, !0), j($y), $(e.$slots, "aside-outline-after", {}, void 0, !0), Ny, $(e.$slots, "aside-ads-before", {}, void 0, !0), P(t).carbonAds ? (M(), W(Ey, { key: 0, "carbon-ads": P(t).carbonAds }, null, 8, ["carbon-ads"])) : N("", !0), $(e.$slots, "aside-ads-after", {}, void 0, !0), $(e.$slots, "aside-bottom", {}, void 0, !0)])) } }), Vy = J(Fy, [["__scopeId", "data-v-cb998dce"]]); function By () { const { theme: n, page: t } = it(); return K(() => { const { text: e = "Edit this page", pattern: s = "" } = n.value.editLink || {}; let i; return typeof s == "function" ? i = s(t.value) : i = s.replace(/:path/g, t.value.filePath), { url: i, text: e } }) } function zy () { const { page: n, theme: t, frontmatter: e } = it(); return K(() => { var c, d, u, h, f, g, m, v; const s = Yc(t.value.sidebar, n.value.relativePath), i = _y(s), o = jy(i, p => p.link.replace(/[?#].*$/, "")), a = o.findIndex(p => on(n.value.relativePath, p.link)), r = ((c = t.value.docFooter) == null ? void 0 : c.prev) === !1 && !e.value.prev || e.value.prev === !1, l = ((d = t.value.docFooter) == null ? void 0 : d.next) === !1 && !e.value.next || e.value.next === !1; return { prev: r ? void 0 : { text: (typeof e.value.prev == "string" ? e.value.prev : typeof e.value.prev == "object" ? e.value.prev.text : void 0) ?? ((u = o[a - 1]) == null ? void 0 : u.docFooterText) ?? ((h = o[a - 1]) == null ? void 0 : h.text), link: (typeof e.value.prev == "object" ? e.value.prev.link : void 0) ?? ((f = o[a - 1]) == null ? void 0 : f.link) }, next: l ? void 0 : { text: (typeof e.value.next == "string" ? e.value.next : typeof e.value.next == "object" ? e.value.next.text : void 0) ?? ((g = o[a + 1]) == null ? void 0 : g.docFooterText) ?? ((m = o[a + 1]) == null ? void 0 : m.text), link: (typeof e.value.next == "object" ? e.value.next.link : void 0) ?? ((v = o[a + 1]) == null ? void 0 : v.link) } } }) } function jy (n, t) { const e = new Set; return n.filter(s => { const i = t(s); return e.has(i) ? !1 : e.add(i) }) } const pe = z({ __name: "VPLink", props: { tag: {}, href: {}, noIcon: { type: Boolean }, target: {}, rel: {} }, setup (n) { const t = n, e = K(() => t.tag ?? (t.href ? "a" : "span")), s = K(() => t.href && ml.test(t.href) || t.target === "_blank"); return (i, o) => (M(), W(he(e.value), { class: Q(["VPLink", { link: i.href, "vp-external-link-icon": s.value, "no-icon": i.noIcon }]), href: i.href ? P(ia)(i.href) : void 0, target: i.target ?? (s.value ? "_blank" : void 0), rel: i.rel ?? (s.value ? "noreferrer" : void 0) }, { default: D(() => [$(i.$slots, "default")]), _: 3 }, 8, ["class", "href", "target", "rel"])) } }), Hy = { class: "VPLastUpdated" }, Wy = ["datetime"], Uy = z({ __name: "VPDocFooterLastUpdated", setup (n) { const { theme: t, page: e, lang: s } = it(), i = K(() => new Date(e.value.lastUpdated)), o = K(() => i.value.toISOString()), a = et(""); return Se(() => { ci(() => { var r, l, c; a.value = new Intl.DateTimeFormat((l = (r = t.value.lastUpdated) == null ? void 0 : r.formatOptions) != null && l.forceLocale ? s.value : void 0, ((c = t.value.lastUpdated) == null ? void 0 : c.formatOptions) ?? { dateStyle: "short", timeStyle: "short" }).format(i.value) }) }), (r, l) => { var c; return M(), O("p", Hy, [Lt(q(((c = P(t).lastUpdated) == null ? void 0 : c.text) || P(t).lastUpdatedText || "Last updated") + ": ", 1), _("time", { datetime: o.value }, q(a.value), 9, Wy)]) } } }), Yy = J(Uy, [["__scopeId", "data-v-1bb0c8a8"]]), Xc = n => (Ft("data-v-1bcd8184"), n = n(), Vt(), n), Ky = { key: 0, class: "VPDocFooter" }, qy = { key: 0, class: "edit-info" }, Xy = { key: 0, class: "edit-link" }, Gy = Xc(() => _("span", { class: "vpi-square-pen edit-link-icon" }, null, -1)), Jy = { key: 1, class: "last-updated" }, Qy = { key: 1, class: "prev-next", "aria-labelledby": "doc-footer-aria-label" }, Zy = Xc(() => _("span", { class: "visually-hidden", id: "doc-footer-aria-label" }, "Pager", -1)), tx = { class: "pager" }, ex = ["innerHTML"], nx = ["innerHTML"], sx = { class: "pager" }, ix = ["innerHTML"], ox = ["innerHTML"], ax = z({ __name: "VPDocFooter", setup (n) { const { theme: t, page: e, frontmatter: s } = it(), i = By(), o = zy(), a = K(() => t.value.editLink && s.value.editLink !== !1), r = K(() => e.value.lastUpdated), l = K(() => a.value || r.value || o.value.prev || o.value.next); return (c, d) => { var u, h, f, g; return l.value ? (M(), O("footer", Ky, [$(c.$slots, "doc-footer-before", {}, void 0, !0), a.value || r.value ? (M(), O("div", qy, [a.value ? (M(), O("div", Xy, [j(pe, { class: "edit-link-button", href: P(i).url, "no-icon": !0 }, { default: D(() => [Gy, Lt(" " + q(P(i).text), 1)]), _: 1 }, 8, ["href"])])) : N("", !0), r.value ? (M(), O("div", Jy, [j(Yy)])) : N("", !0)])) : N("", !0), (u = P(o).prev) != null && u.link || (h = P(o).next) != null && h.link ? (M(), O("nav", Qy, [Zy, _("div", tx, [(f = P(o).prev) != null && f.link ? (M(), W(pe, { key: 0, class: "pager-link prev", href: P(o).prev.link }, { default: D(() => { var m; return [_("span", { class: "desc", innerHTML: ((m = P(t).docFooter) == null ? void 0 : m.prev) || "Previous page" }, null, 8, ex), _("span", { class: "title", innerHTML: P(o).prev.text }, null, 8, nx)] }), _: 1 }, 8, ["href"])) : N("", !0)]), _("div", sx, [(g = P(o).next) != null && g.link ? (M(), W(pe, { key: 0, class: "pager-link next", href: P(o).next.link }, { default: D(() => { var m; return [_("span", { class: "desc", innerHTML: ((m = P(t).docFooter) == null ? void 0 : m.next) || "Next page" }, null, 8, ix), _("span", { class: "title", innerHTML: P(o).next.text }, null, 8, ox)] }), _: 1 }, 8, ["href"])) : N("", !0)])])) : N("", !0)])) : N("", !0) } } }), rx = J(ax, [["__scopeId", "data-v-1bcd8184"]]), lx = n => (Ft("data-v-e6f2a212"), n = n(), Vt(), n), cx = { class: "container" }, dx = lx(() => _("div", { class: "aside-curtain" }, null, -1)), ux = { class: "aside-container" }, hx = { class: "aside-content" }, fx = { class: "content" }, px = { class: "content-container" }, gx = { class: "main" }, mx = z({ __name: "VPDoc", setup (n) { const { theme: t } = it(), e = ui(), { hasSidebar: s, hasAside: i, leftAside: o } = Ce(), a = K(() => e.path.replace(/[./]+/g, "_").replace(/_html$/, "")); return (r, l) => { const c = Qt("Content"); return M(), O("div", { class: Q(["VPDoc", { "has-sidebar": P(s), "has-aside": P(i) }]) }, [$(r.$slots, "doc-top", {}, void 0, !0), _("div", cx, [P(i) ? (M(), O("div", { key: 0, class: Q(["aside", { "left-aside": P(o) }]) }, [dx, _("div", ux, [_("div", hx, [j(Vy, null, { "aside-top": D(() => [$(r.$slots, "aside-top", {}, void 0, !0)]), "aside-bottom": D(() => [$(r.$slots, "aside-bottom", {}, void 0, !0)]), "aside-outline-before": D(() => [$(r.$slots, "aside-outline-before", {}, void 0, !0)]), "aside-outline-after": D(() => [$(r.$slots, "aside-outline-after", {}, void 0, !0)]), "aside-ads-before": D(() => [$(r.$slots, "aside-ads-before", {}, void 0, !0)]), "aside-ads-after": D(() => [$(r.$slots, "aside-ads-after", {}, void 0, !0)]), _: 3 })])])], 2)) : N("", !0), _("div", fx, [_("div", px, [$(r.$slots, "doc-before", {}, void 0, !0), _("main", gx, [j(c, { class: Q(["vp-doc", [a.value, P(t).externalLinkIcon && "external-link-icon-enabled"]]) }, null, 8, ["class"])]), j(rx, null, { "doc-footer-before": D(() => [$(r.$slots, "doc-footer-before", {}, void 0, !0)]), _: 3 }), $(r.$slots, "doc-after", {}, void 0, !0)])])]), $(r.$slots, "doc-bottom", {}, void 0, !0)], 2) } } }), bx = J(mx, [["__scopeId", "data-v-e6f2a212"]]), vx = z({ __name: "VPButton", props: { tag: {}, size: { default: "medium" }, theme: { default: "brand" }, text: {}, href: {}, target: {}, rel: {} }, setup (n) { const t = n, e = K(() => t.href && ml.test(t.href)), s = K(() => t.tag || t.href ? "a" : "button"); return (i, o) => (M(), W(he(s.value), { class: Q(["VPButton", [i.size, i.theme]]), href: i.href ? P(ia)(i.href) : void 0, target: t.target ?? (e.value ? "_blank" : void 0), rel: t.rel ?? (e.value ? "noreferrer" : void 0) }, { default: D(() => [Lt(q(i.text), 1)]), _: 1 }, 8, ["class", "href", "target", "rel"])) } }), _x = J(vx, [["__scopeId", "data-v-c9cf0e3c"]]), yx = ["src", "alt"], xx = z({ inheritAttrs: !1, __name: "VPImage", props: { image: {}, alt: {} }, setup (n) { return (t, e) => { const s = Qt("VPImage", !0); return t.image ? (M(), O(dt, { key: 0 }, [typeof t.image == "string" || "src" in t.image ? (M(), O("img", Ie({ key: 0, class: "VPImage" }, typeof t.image == "string" ? t.$attrs : { ...t.image, ...t.$attrs }, { src: P($o)(typeof t.image == "string" ? t.image : t.image.src), alt: t.alt ?? (typeof t.image == "string" ? "" : t.image.alt || "") }), null, 16, yx)) : (M(), O(dt, { key: 1 }, [j(s, Ie({ class: "dark", image: t.image.dark, alt: t.image.alt }, t.$attrs), null, 16, ["image", "alt"]), j(s, Ie({ class: "light", image: t.image.light, alt: t.image.alt }, t.$attrs), null, 16, ["image", "alt"])], 64))], 64)) : N("", !0) } } }), ri = J(xx, [["__scopeId", "data-v-ab19afbb"]]), wx = n => (Ft("data-v-b10c5094"), n = n(), Vt(), n), kx = { class: "container" }, Sx = { class: "main" }, Mx = { key: 0, class: "name" }, Px = ["innerHTML"], Cx = ["innerHTML"], Tx = ["innerHTML"], Ox = { key: 0, class: "actions" }, Lx = { key: 0, class: "image" }, Ax = { class: "image-container" }, $x = wx(() => _("div", { class: "image-bg" }, null, -1)), Dx = z({ __name: "VPHero", props: { name: {}, text: {}, tagline: {}, image: {}, actions: {} }, setup (n) { const t = as("hero-image-slot-exists"); return (e, s) => (M(), O("div", { class: Q(["VPHero", { "has-image": e.image || P(t) }]) }, [_("div", kx, [_("div", Sx, [$(e.$slots, "home-hero-info-before", {}, void 0, !0), $(e.$slots, "home-hero-info", {}, () => [e.name ? (M(), O("h1", Mx, [_("span", { innerHTML: e.name, class: "clip" }, null, 8, Px)])) : N("", !0), e.text ? (M(), O("p", { key: 1, innerHTML: e.text, class: "text" }, null, 8, Cx)) : N("", !0), e.tagline ? (M(), O("p", { key: 2, innerHTML: e.tagline, class: "tagline" }, null, 8, Tx)) : N("", !0)], !0), $(e.$slots, "home-hero-info-after", {}, void 0, !0), e.actions ? (M(), O("div", Ox, [(M(!0), O(dt, null, Et(e.actions, i => (M(), O("div", { key: i.link, class: "action" }, [j(_x, { tag: "a", size: "medium", theme: i.theme, text: i.text, href: i.link, target: i.target, rel: i.rel }, null, 8, ["theme", "text", "href", "target", "rel"])]))), 128))])) : N("", !0), $(e.$slots, "home-hero-actions-after", {}, void 0, !0)]), e.image || P(t) ? (M(), O("div", Lx, [_("div", Ax, [$x, $(e.$slots, "home-hero-image", {}, () => [e.image ? (M(), W(ri, { key: 0, class: "image-src", image: e.image }, null, 8, ["image"])) : N("", !0)], !0)])])) : N("", !0)])], 2)) } }), Ex = J(Dx, [["__scopeId", "data-v-b10c5094"]]), Rx = z({ __name: "VPHomeHero", setup (n) { const { frontmatter: t } = it(); return (e, s) => P(t).hero ? (M(), W(Ex, { key: 0, class: "VPHomeHero", name: P(t).hero.name, text: P(t).hero.text, tagline: P(t).hero.tagline, image: P(t).hero.image, actions: P(t).hero.actions }, { "home-hero-info-before": D(() => [$(e.$slots, "home-hero-info-before")]), "home-hero-info": D(() => [$(e.$slots, "home-hero-info")]), "home-hero-info-after": D(() => [$(e.$slots, "home-hero-info-after")]), "home-hero-actions-after": D(() => [$(e.$slots, "home-hero-actions-after")]), "home-hero-image": D(() => [$(e.$slots, "home-hero-image")]), _: 3 }, 8, ["name", "text", "tagline", "image", "actions"])) : N("", !0) } }), Ix = n => (Ft("data-v-bd37d1a2"), n = n(), Vt(), n), Nx = { class: "box" }, Fx = { key: 0, class: "icon" }, Vx = ["innerHTML"], Bx = ["innerHTML"], zx = ["innerHTML"], jx = { key: 4, class: "link-text" }, Hx = { class: "link-text-value" }, Wx = Ix(() => _("span", { class: "vpi-arrow-right link-text-icon" }, null, -1)), Ux = z({ __name: "VPFeature", props: { icon: {}, title: {}, details: {}, link: {}, linkText: {}, rel: {}, target: {} }, setup (n) { return (t, e) => (M(), W(pe, { class: "VPFeature", href: t.link, rel: t.rel, target: t.target, "no-icon": !0, tag: t.link ? "a" : "div" }, { default: D(() => [_("article", Nx, [typeof t.icon == "object" && t.icon.wrap ? (M(), O("div", Fx, [j(ri, { image: t.icon, alt: t.icon.alt, height: t.icon.height || 48, width: t.icon.width || 48 }, null, 8, ["image", "alt", "height", "width"])])) : typeof t.icon == "object" ? (M(), W(ri, { key: 1, image: t.icon, alt: t.icon.alt, height: t.icon.height || 48, width: t.icon.width || 48 }, null, 8, ["image", "alt", "height", "width"])) : t.icon ? (M(), O("div", { key: 2, class: "icon", innerHTML: t.icon }, null, 8, Vx)) : N("", !0), _("h2", { class: "title", innerHTML: t.title }, null, 8, Bx), t.details ? (M(), O("p", { key: 3, class: "details", innerHTML: t.details }, null, 8, zx)) : N("", !0), t.linkText ? (M(), O("div", jx, [_("p", Hx, [Lt(q(t.linkText) + " ", 1), Wx])])) : N("", !0)])]), _: 1 }, 8, ["href", "rel", "target", "tag"])) } }), Yx = J(Ux, [["__scopeId", "data-v-bd37d1a2"]]), Kx = { key: 0, class: "VPFeatures" }, qx = { class: "container" }, Xx = { class: "items" }, Gx = z({ __name: "VPFeatures", props: { features: {} }, setup (n) { const t = n, e = K(() => { const s = t.features.length; if (s) { if (s === 2) return "grid-2"; if (s === 3) return "grid-3"; if (s % 3 === 0) return "grid-6"; if (s > 3) return "grid-4" } else return }); return (s, i) => s.features ? (M(), O("div", Kx, [_("div", qx, [_("div", Xx, [(M(!0), O(dt, null, Et(s.features, o => (M(), O("div", { key: o.title, class: Q(["item", [e.value]]) }, [j(Yx, { icon: o.icon, title: o.title, details: o.details, link: o.link, "link-text": o.linkText, rel: o.rel, target: o.target }, null, 8, ["icon", "title", "details", "link", "link-text", "rel", "target"])], 2))), 128))])])])) : N("", !0) } }), Jx = J(Gx, [["__scopeId", "data-v-b1eea84a"]]), Qx = z({ __name: "VPHomeFeatures", setup (n) { const { frontmatter: t } = it(); return (e, s) => P(t).features ? (M(), W(Jx, { key: 0, class: "VPHomeFeatures", features: P(t).features }, null, 8, ["features"])) : N("", !0) } }), Zx = z({ __name: "VPHomeContent", setup (n) { const { width: t } = _d({ initialWidth: 0, includeScrollbar: !1 }); return (e, s) => (M(), O("div", { class: "vp-doc container", style: bl(P(t) ? { "--vp-offset": `calc(50% - ${P(t) / 2}px)` } : {}) }, [$(e.$slots, "default", {}, void 0, !0)], 4)) } }), t1 = J(Zx, [["__scopeId", "data-v-c141a4bd"]]), e1 = { class: "VPHome" }, n1 = z({ __name: "VPHome", setup (n) { const { frontmatter: t } = it(); return (e, s) => { const i = Qt("Content"); return M(), O("div", e1, [$(e.$slots, "home-hero-before", {}, void 0, !0), j(Rx, null, { "home-hero-info-before": D(() => [$(e.$slots, "home-hero-info-before", {}, void 0, !0)]), "home-hero-info": D(() => [$(e.$slots, "home-hero-info", {}, void 0, !0)]), "home-hero-info-after": D(() => [$(e.$slots, "home-hero-info-after", {}, void 0, !0)]), "home-hero-actions-after": D(() => [$(e.$slots, "home-hero-actions-after", {}, void 0, !0)]), "home-hero-image": D(() => [$(e.$slots, "home-hero-image", {}, void 0, !0)]), _: 3 }), $(e.$slots, "home-hero-after", {}, void 0, !0), $(e.$slots, "home-features-before", {}, void 0, !0), j(Qx), $(e.$slots, "home-features-after", {}, void 0, !0), P(t).markdownStyles !== !1 ? (M(), W(t1, { key: 0 }, { default: D(() => [j(i)]), _: 1 })) : (M(), W(i, { key: 1 }))]) } } }), s1 = J(n1, [["__scopeId", "data-v-07b1ad08"]]), i1 = {}, o1 = { class: "VPPage" }; function a1 (n, t) { const e = Qt("Content"); return M(), O("div", o1, [$(n.$slots, "page-top"), j(e), $(n.$slots, "page-bottom")]) } const r1 = J(i1, [["render", a1]]), l1 = z({ __name: "VPContent", setup (n) { const { page: t, frontmatter: e } = it(), { hasSidebar: s } = Ce(); return (i, o) => (M(), O("div", { class: Q(["VPContent", { "has-sidebar": P(s), "is-home": P(e).layout === "home" }]), id: "VPContent" }, [P(t).isNotFound ? $(i.$slots, "not-found", { key: 0 }, () => [j(by)], !0) : P(e).layout === "page" ? (M(), W(r1, { key: 1 }, { "page-top": D(() => [$(i.$slots, "page-top", {}, void 0, !0)]), "page-bottom": D(() => [$(i.$slots, "page-bottom", {}, void 0, !0)]), _: 3 })) : P(e).layout === "home" ? (M(), W(s1, { key: 2 }, { "home-hero-before": D(() => [$(i.$slots, "home-hero-before", {}, void 0, !0)]), "home-hero-info-before": D(() => [$(i.$slots, "home-hero-info-before", {}, void 0, !0)]), "home-hero-info": D(() => [$(i.$slots, "home-hero-info", {}, void 0, !0)]), "home-hero-info-after": D(() => [$(i.$slots, "home-hero-info-after", {}, void 0, !0)]), "home-hero-actions-after": D(() => [$(i.$slots, "home-hero-actions-after", {}, void 0, !0)]), "home-hero-image": D(() => [$(i.$slots, "home-hero-image", {}, void 0, !0)]), "home-hero-after": D(() => [$(i.$slots, "home-hero-after", {}, void 0, !0)]), "home-features-before": D(() => [$(i.$slots, "home-features-before", {}, void 0, !0)]), "home-features-after": D(() => [$(i.$slots, "home-features-after", {}, void 0, !0)]), _: 3 })) : P(e).layout && P(e).layout !== "doc" ? (M(), W(he(P(e).layout), { key: 3 })) : (M(), W(bx, { key: 4 }, { "doc-top": D(() => [$(i.$slots, "doc-top", {}, void 0, !0)]), "doc-bottom": D(() => [$(i.$slots, "doc-bottom", {}, void 0, !0)]), "doc-footer-before": D(() => [$(i.$slots, "doc-footer-before", {}, void 0, !0)]), "doc-before": D(() => [$(i.$slots, "doc-before", {}, void 0, !0)]), "doc-after": D(() => [$(i.$slots, "doc-after", {}, void 0, !0)]), "aside-top": D(() => [$(i.$slots, "aside-top", {}, void 0, !0)]), "aside-outline-before": D(() => [$(i.$slots, "aside-outline-before", {}, void 0, !0)]), "aside-outline-after": D(() => [$(i.$slots, "aside-outline-after", {}, void 0, !0)]), "aside-ads-before": D(() => [$(i.$slots, "aside-ads-before", {}, void 0, !0)]), "aside-ads-after": D(() => [$(i.$slots, "aside-ads-after", {}, void 0, !0)]), "aside-bottom": D(() => [$(i.$slots, "aside-bottom", {}, void 0, !0)]), _: 3 }))], 2)) } }), c1 = J(l1, [["__scopeId", "data-v-9a6c75ad"]]), d1 = { class: "container" }, u1 = ["innerHTML"], h1 = ["innerHTML"], f1 = z({ __name: "VPFooter", setup (n) { const { theme: t, frontmatter: e } = it(), { hasSidebar: s } = Ce(); return (i, o) => P(t).footer && P(e).footer !== !1 ? (M(), O("footer", { key: 0, class: Q(["VPFooter", { "has-sidebar": P(s) }]) }, [_("div", d1, [P(t).footer.message ? (M(), O("p", { key: 0, class: "message", innerHTML: P(t).footer.message }, null, 8, u1)) : N("", !0), P(t).footer.copyright ? (M(), O("p", { key: 1, class: "copyright", innerHTML: P(t).footer.copyright }, null, 8, h1)) : N("", !0)])], 2)) : N("", !0) } }), p1 = J(f1, [["__scopeId", "data-v-566314d4"]]); function g1 () { const { theme: n, frontmatter: t } = it(), e = gl([]), s = K(() => e.value.length > 0); return di(() => { e.value = oa(t.value.outline ?? n.value.outline) }), { headers: e, hasLocalNav: s } } const m1 = n => (Ft("data-v-883964e0"), n = n(), Vt(), n), b1 = { class: "menu-text" }, v1 = m1(() => _("span", { class: "vpi-chevron-right icon" }, null, -1)), _1 = { class: "header" }, y1 = { class: "outline" }, x1 = z({ __name: "VPLocalNavOutlineDropdown", props: { headers: {}, navHeight: {} }, setup (n) { const t = n, { theme: e } = it(), s = et(!1), i = et(0), o = et(), a = et(); function r (u) { var h; (h = o.value) != null && h.contains(u.target) || (s.value = !1) } ne(s, u => { if (u) { document.addEventListener("click", r); return } document.removeEventListener("click", r) }), yd("Escape", () => { s.value = !1 }), di(() => { s.value = !1 }); function l () { s.value = !s.value, i.value = window.innerHeight + Math.min(window.scrollY - t.navHeight, 0) } function c (u) { u.target.classList.contains("outline-link") && (a.value && (a.value.style.transition = "none"), pl(() => { s.value = !1 })) } function d () { s.value = !1, window.scrollTo({ top: 0, left: 0, behavior: "smooth" }) } return (u, h) => (M(), O("div", { class: "VPLocalNavOutlineDropdown", style: bl({ "--vp-vh": i.value + "px" }), ref_key: "main", ref: o }, [u.headers.length > 0 ? (M(), O("button", { key: 0, onClick: l, class: Q({ open: s.value }) }, [_("span", b1, q(P(Kc)(P(e))), 1), v1], 2)) : (M(), O("button", { key: 1, onClick: d }, q(P(e).returnToTopLabel || "Return to top"), 1)), j(li, { name: "flyout" }, { default: D(() => [s.value ? (M(), O("div", { key: 0, ref_key: "items", ref: a, class: "items", onClick: c }, [_("div", _1, [_("a", { class: "top-link", href: "#", onClick: d }, q(P(e).returnToTopLabel || "Return to top"), 1)]), _("div", y1, [j(qc, { headers: u.headers }, null, 8, ["headers"])])], 512)) : N("", !0)]), _: 1 })], 4)) } }), w1 = J(x1, [["__scopeId", "data-v-883964e0"]]), k1 = n => (Ft("data-v-2488c25a"), n = n(), Vt(), n), S1 = { class: "container" }, M1 = ["aria-expanded"], P1 = k1(() => _("span", { class: "vpi-align-left menu-icon" }, null, -1)), C1 = { class: "menu-text" }, T1 = z({ __name: "VPLocalNav", props: { open: { type: Boolean } }, emits: ["open-menu"], setup (n) { const { theme: t, frontmatter: e } = it(), { hasSidebar: s } = Ce(), { headers: i } = g1(), { y: o } = vl(), a = et(0); Se(() => { a.value = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--vp-nav-height")) }), di(() => { i.value = oa(e.value.outline ?? t.value.outline) }); const r = K(() => i.value.length === 0), l = K(() => r.value && !s.value), c = K(() => ({ VPLocalNav: !0, "has-sidebar": s.value, empty: r.value, fixed: l.value })); return (d, u) => P(e).layout !== "home" && (!l.value || P(o) >= a.value) ? (M(), O("div", { key: 0, class: Q(c.value) }, [_("div", S1, [P(s) ? (M(), O("button", { key: 0, class: "menu", "aria-expanded": d.open, "aria-controls": "VPSidebarNav", onClick: u[0] || (u[0] = h => d.$emit("open-menu")) }, [P1, _("span", C1, q(P(t).sidebarMenuLabel || "Menu"), 1)], 8, M1)) : N("", !0), j(w1, { headers: P(i), navHeight: a.value }, null, 8, ["headers", "navHeight"])])], 2)) : N("", !0) } }), O1 = J(T1, [["__scopeId", "data-v-2488c25a"]]); function L1 () { const n = et(!1); function t () { n.value = !0, window.addEventListener("resize", i) } function e () { n.value = !1, window.removeEventListener("resize", i) } function s () { n.value ? e() : t() } function i () { window.outerWidth >= 768 && e() } const o = ui(); return ne(() => o.path, e), { isScreenOpen: n, openScreen: t, closeScreen: e, toggleScreen: s } } const A1 = {}, $1 = { class: "VPSwitch", type: "button", role: "switch" }, D1 = { class: "check" }, E1 = { key: 0, class: "icon" }; function R1 (n, t) { return M(), O("button", $1, [_("span", D1, [n.$slots.default ? (M(), O("span", E1, [$(n.$slots, "default", {}, void 0, !0)])) : N("", !0)])]) } const I1 = J(A1, [["render", R1], ["__scopeId", "data-v-b4ccac88"]]), Gc = n => (Ft("data-v-be9742d9"), n = n(), Vt(), n), N1 = Gc(() => _("span", { class: "vpi-sun sun" }, null, -1)), F1 = Gc(() => _("span", { class: "vpi-moon moon" }, null, -1)), V1 = z({ __name: "VPSwitchAppearance", setup (n) { const { isDark: t, theme: e } = it(), s = as("toggle-appearance", () => { t.value = !t.value }), i = et(""); return Do(() => { i.value = t.value ? e.value.lightModeSwitchTitle || "Switch to light theme" : e.value.darkModeSwitchTitle || "Switch to dark theme" }), (o, a) => (M(), W(I1, { title: i.value, class: "VPSwitchAppearance", "aria-checked": P(t), onClick: P(s) }, { default: D(() => [N1, F1]), _: 1 }, 8, ["title", "aria-checked", "onClick"])) } }), aa = J(V1, [["__scopeId", "data-v-be9742d9"]]), B1 = { key: 0, class: "VPNavBarAppearance" }, z1 = z({ __name: "VPNavBarAppearance", setup (n) { const { site: t } = it(); return (e, s) => P(t).appearance && P(t).appearance !== "force-dark" && P(t).appearance !== "force-auto" ? (M(), O("div", B1, [j(aa)])) : N("", !0) } }), j1 = J(z1, [["__scopeId", "data-v-3f90c1a5"]]), ra = et(); let Jc = !1, Ji = 0; function H1 (n) { const t = et(!1); if (hi) { !Jc && W1(), Ji++; const e = ne(ra, s => { var i, o, a; s === n.el.value || (i = n.el.value) != null && i.contains(s) ? (t.value = !0, (o = n.onFocus) == null || o.call(n)) : (t.value = !1, (a = n.onBlur) == null || a.call(n)) }); Xn(() => { e(), Ji--, Ji || U1() }) } return xd(t) } function W1 () { document.addEventListener("focusin", Qc), Jc = !0, ra.value = document.activeElement } function U1 () { document.removeEventListener("focusin", Qc) } function Qc () { ra.value = document.activeElement } const Y1 = { class: "VPMenuLink" }, K1 = z({ __name: "VPMenuLink", props: { item: {} }, setup (n) { const { page: t } = it(); return (e, s) => (M(), O("div", Y1, [j(pe, { class: Q({ active: P(on)(P(t).relativePath, e.item.activeMatch || e.item.link, !!e.item.activeMatch) }), href: e.item.link, target: e.item.target, rel: e.item.rel }, { default: D(() => [Lt(q(e.item.text), 1)]), _: 1 }, 8, ["class", "href", "target", "rel"])])) } }), Mi = J(K1, [["__scopeId", "data-v-f51f088d"]]), q1 = { class: "VPMenuGroup" }, X1 = { key: 0, class: "title" }, G1 = z({ __name: "VPMenuGroup", props: { text: {}, items: {} }, setup (n) { return (t, e) => (M(), O("div", q1, [t.text ? (M(), O("p", X1, q(t.text), 1)) : N("", !0), (M(!0), O(dt, null, Et(t.items, s => (M(), O(dt, null, ["link" in s ? (M(), W(Mi, { key: 0, item: s }, null, 8, ["item"])) : N("", !0)], 64))), 256))])) } }), J1 = J(G1, [["__scopeId", "data-v-a6b0397c"]]), Q1 = { class: "VPMenu" }, Z1 = { key: 0, class: "items" }, tw = z({ __name: "VPMenu", props: { items: {} }, setup (n) { return (t, e) => (M(), O("div", Q1, [t.items ? (M(), O("div", Z1, [(M(!0), O(dt, null, Et(t.items, s => (M(), O(dt, { key: JSON.stringify(s) }, ["link" in s ? (M(), W(Mi, { key: 0, item: s }, null, 8, ["item"])) : "component" in s ? (M(), W(he(s.component), Ie({ key: 1, ref_for: !0 }, s.props), null, 16)) : (M(), W(J1, { key: 2, text: s.text, items: s.items }, null, 8, ["text", "items"]))], 64))), 128))])) : N("", !0), $(t.$slots, "default", {}, void 0, !0)])) } }), ew = J(tw, [["__scopeId", "data-v-20ed86d6"]]), nw = n => (Ft("data-v-af5898d3"), n = n(), Vt(), n), sw = ["aria-expanded", "aria-label"], iw = { key: 0, class: "text" }, ow = ["innerHTML"], aw = nw(() => _("span", { class: "vpi-chevron-down text-icon" }, null, -1)), rw = { key: 1, class: "vpi-more-horizontal icon" }, lw = { class: "menu" }, cw = z({ __name: "VPFlyout", props: { icon: {}, button: {}, label: {}, items: {} }, setup (n) { const t = et(!1), e = et(); H1({ el: e, onBlur: s }); function s () { t.value = !1 } return (i, o) => (M(), O("div", { class: "VPFlyout", ref_key: "el", ref: e, onMouseenter: o[1] || (o[1] = a => t.value = !0), onMouseleave: o[2] || (o[2] = a => t.value = !1) }, [_("button", { type: "button", class: "button", "aria-haspopup": "true", "aria-expanded": t.value, "aria-label": i.label, onClick: o[0] || (o[0] = a => t.value = !t.value) }, [i.button || i.icon ? (M(), O("span", iw, [i.icon ? (M(), O("span", { key: 0, class: Q([i.icon, "option-icon"]) }, null, 2)) : N("", !0), i.button ? (M(), O("span", { key: 1, innerHTML: i.button }, null, 8, ow)) : N("", !0), aw])) : (M(), O("span", rw))], 8, sw), _("div", lw, [j(ew, { items: i.items }, { default: D(() => [$(i.$slots, "default", {}, void 0, !0)]), _: 3 }, 8, ["items"])])], 544)) } }), la = J(cw, [["__scopeId", "data-v-af5898d3"]]), dw = ["href", "aria-label", "innerHTML"], uw = z({ __name: "VPSocialLink", props: { icon: {}, link: {}, ariaLabel: {} }, setup (n) { const t = n, e = K(() => typeof t.icon == "object" ? t.icon.svg : `<span class="vpi-social-${t.icon}" />`); return (s, i) => (M(), O("a", { class: "VPSocialLink no-icon", href: s.link, "aria-label": s.ariaLabel ?? (typeof s.icon == "string" ? s.icon : ""), target: "_blank", rel: "noopener", innerHTML: e.value }, null, 8, dw)) } }), hw = J(uw, [["__scopeId", "data-v-358b6670"]]), fw = { class: "VPSocialLinks" }, pw = z({ __name: "VPSocialLinks", props: { links: {} }, setup (n) { return (t, e) => (M(), O("div", fw, [(M(!0), O(dt, null, Et(t.links, ({ link: s, icon: i, ariaLabel: o }) => (M(), W(hw, { key: s, icon: i, link: s, ariaLabel: o }, null, 8, ["icon", "link", "ariaLabel"]))), 128))])) } }), ca = J(pw, [["__scopeId", "data-v-e71e869c"]]), gw = { key: 0, class: "group translations" }, mw = { class: "trans-title" }, bw = { key: 1, class: "group" }, vw = { class: "item appearance" }, _w = { class: "label" }, yw = { class: "appearance-action" }, xw = { key: 2, class: "group" }, ww = { class: "item social-links" }, kw = z({ __name: "VPNavBarExtra", setup (n) { const { site: t, theme: e } = it(), { localeLinks: s, currentLang: i } = fs({ correspondingLink: !0 }), o = K(() => s.value.length && i.value.label || t.value.appearance || e.value.socialLinks); return (a, r) => o.value ? (M(), W(la, { key: 0, class: "VPNavBarExtra", label: "extra navigation" }, { default: D(() => [P(s).length && P(i).label ? (M(), O("div", gw, [_("p", mw, q(P(i).label), 1), (M(!0), O(dt, null, Et(P(s), l => (M(), W(Mi, { key: l.link, item: l }, null, 8, ["item"]))), 128))])) : N("", !0), P(t).appearance && P(t).appearance !== "force-dark" && P(t).appearance !== "force-auto" ? (M(), O("div", bw, [_("div", vw, [_("p", _w, q(P(e).darkModeSwitchLabel || "Appearance"), 1), _("div", yw, [j(aa)])])])) : N("", !0), P(e).socialLinks ? (M(), O("div", xw, [_("div", ww, [j(ca, { class: "social-links-list", links: P(e).socialLinks }, null, 8, ["links"])])])) : N("", !0)]), _: 1 })) : N("", !0) } }), Sw = J(kw, [["__scopeId", "data-v-f953d92f"]]), Mw = n => (Ft("data-v-6bee1efd"), n = n(), Vt(), n), Pw = ["aria-expanded"], Cw = Mw(() => _("span", { class: "container" }, [_("span", { class: "top" }), _("span", { class: "middle" }), _("span", { class: "bottom" })], -1)), Tw = [Cw], Ow = z({ __name: "VPNavBarHamburger", props: { active: { type: Boolean } }, emits: ["click"], setup (n) { return (t, e) => (M(), O("button", { type: "button", class: Q(["VPNavBarHamburger", { active: t.active }]), "aria-label": "mobile navigation", "aria-expanded": t.active, "aria-controls": "VPNavScreen", onClick: e[0] || (e[0] = s => t.$emit("click")) }, Tw, 10, Pw)) } }), Lw = J(Ow, [["__scopeId", "data-v-6bee1efd"]]), Aw = ["innerHTML"], $w = z({ __name: "VPNavBarMenuLink", props: { item: {} }, setup (n) { const { page: t } = it(); return (e, s) => (M(), W(pe, { class: Q({ VPNavBarMenuLink: !0, active: P(on)(P(t).relativePath, e.item.activeMatch || e.item.link, !!e.item.activeMatch) }), href: e.item.link, noIcon: e.item.noIcon, target: e.item.target, rel: e.item.rel, tabindex: "0" }, { default: D(() => [_("span", { innerHTML: e.item.text }, null, 8, Aw)]), _: 1 }, 8, ["class", "href", "noIcon", "target", "rel"])) } }), Dw = J($w, [["__scopeId", "data-v-08fbf4b6"]]), Ew = z({ __name: "VPNavBarMenuGroup", props: { item: {} }, setup (n) { const t = n, { page: e } = it(), s = o => "component" in o ? !1 : "link" in o ? on(e.value.relativePath, o.link, !!t.item.activeMatch) : o.items.some(s), i = K(() => s(t.item)); return (o, a) => (M(), W(la, { class: Q({ VPNavBarMenuGroup: !0, active: P(on)(P(e).relativePath, o.item.activeMatch, !!o.item.activeMatch) || i.value }), button: o.item.text, items: o.item.items }, null, 8, ["class", "button", "items"])) } }), Rw = n => (Ft("data-v-afb2845e"), n = n(), Vt(), n), Iw = { key: 0, "aria-labelledby": "main-nav-aria-label", class: "VPNavBarMenu" }, Nw = Rw(() => _("span", { id: "main-nav-aria-label", class: "visually-hidden" }, " Main Navigation ", -1)), Fw = z({ __name: "VPNavBarMenu", setup (n) { const { theme: t } = it(); return (e, s) => P(t).nav ? (M(), O("nav", Iw, [Nw, (M(!0), O(dt, null, Et(P(t).nav, i => (M(), O(dt, { key: JSON.stringify(i) }, ["link" in i ? (M(), W(Dw, { key: 0, item: i }, null, 8, ["item"])) : "component" in i ? (M(), W(he(i.component), Ie({ key: 1, ref_for: !0 }, i.props), null, 16)) : (M(), W(Ew, { key: 2, item: i }, null, 8, ["item"]))], 64))), 128))])) : N("", !0) } }), Vw = J(Fw, [["__scopeId", "data-v-afb2845e"]]); function Bw (n) { const { localeIndex: t, theme: e } = it(); function s (i) { var g, m, v; const o = i.split("."), a = (g = e.value.search) == null ? void 0 : g.options, r = a && typeof a == "object", l = r && ((v = (m = a.locales) == null ? void 0 : m[t.value]) == null ? void 0 : v.translations) || null, c = r && a.translations || null; let d = l, u = c, h = n; const f = o.pop(); for (const p of o) { let b = null; const y = h == null ? void 0 : h[p]; y && (b = h = y); const k = u == null ? void 0 : u[p]; k && (b = u = k); const w = d == null ? void 0 : d[p]; w && (b = d = w), y || (h = b), k || (u = b), w || (d = b) } return (d == null ? void 0 : d[f]) ?? (u == null ? void 0 : u[f]) ?? (h == null ? void 0 : h[f]) ?? "" } return s } const zw = ["aria-label"], jw = { class: "DocSearch-Button-Container" }, Hw = _("span", { class: "vp-icon DocSearch-Search-Icon" }, null, -1), Ww = { class: "DocSearch-Button-Placeholder" }, Uw = _("span", { class: "DocSearch-Button-Keys" }, [_("kbd", { class: "DocSearch-Button-Key" }), _("kbd", { class: "DocSearch-Button-Key" }, "K")], -1), al = z({ __name: "VPNavBarSearchButton", setup (n) { const e = Bw({ button: { buttonText: "Search", buttonAriaLabel: "Search" } }); return (s, i) => (M(), O("button", { type: "button", class: "DocSearch DocSearch-Button", "aria-label": P(e)("button.buttonAriaLabel") }, [_("span", jw, [Hw, _("span", Ww, q(P(e)("button.buttonText")), 1)]), Uw], 8, zw)) } }), Yw = { class: "VPNavBarSearch" }, Kw = { id: "local-search" }, qw = { key: 1, id: "docsearch" }, Xw = z({ __name: "VPNavBarSearch", setup (n) { const t = () => null, e = () => null, { theme: s } = it(), i = et(!1), o = et(!1); Se(() => { }); function a () { i.value || (i.value = !0, setTimeout(r, 16)) } function r () { const d = new Event("keydown"); d.key = "k", d.metaKey = !0, window.dispatchEvent(d), setTimeout(() => { document.querySelector(".DocSearch-Modal") || r() }, 16) } const l = et(!1), c = ""; return (d, u) => { var h; return M(), O("div", Yw, [P(c) === "local" ? (M(), O(dt, { key: 0 }, [l.value ? (M(), W(P(t), { key: 0, onClose: u[0] || (u[0] = f => l.value = !1) })) : N("", !0), _("div", Kw, [j(al, { onClick: u[1] || (u[1] = f => l.value = !0) })])], 64)) : P(c) === "algolia" ? (M(), O(dt, { key: 1 }, [i.value ? (M(), W(P(e), { key: 0, algolia: ((h = P(s).search) == null ? void 0 : h.options) ?? P(s).algolia, onVnodeBeforeMount: u[2] || (u[2] = f => o.value = !0) }, null, 8, ["algolia"])) : N("", !0), o.value ? N("", !0) : (M(), O("div", qw, [j(al, { onClick: a })]))], 64)) : N("", !0)]) } } }), Gw = z({ __name: "VPNavBarSocialLinks", setup (n) { const { theme: t } = it(); return (e, s) => P(t).socialLinks ? (M(), W(ca, { key: 0, class: "VPNavBarSocialLinks", links: P(t).socialLinks }, null, 8, ["links"])) : N("", !0) } }), Jw = J(Gw, [["__scopeId", "data-v-ef6192dc"]]), Qw = ["href", "rel", "target"], Zw = { key: 1 }, tk = { key: 2 }, ek = z({ __name: "VPNavBarTitle", setup (n) { const { site: t, theme: e } = it(), { hasSidebar: s } = Ce(), { currentLang: i } = fs(), o = K(() => { var l; return typeof e.value.logoLink == "string" ? e.value.logoLink : (l = e.value.logoLink) == null ? void 0 : l.link }), a = K(() => { var l; return typeof e.value.logoLink == "string" || (l = e.value.logoLink) == null ? void 0 : l.rel }), r = K(() => { var l; return typeof e.value.logoLink == "string" || (l = e.value.logoLink) == null ? void 0 : l.target }); return (l, c) => (M(), O("div", { class: Q(["VPNavBarTitle", { "has-sidebar": P(s) }]) }, [_("a", { class: "title", href: o.value ?? P(ia)(P(i).link), rel: a.value, target: r.value }, [$(l.$slots, "nav-bar-title-before", {}, void 0, !0), P(e).logo ? (M(), W(ri, { key: 0, class: "logo", image: P(e).logo }, null, 8, ["image"])) : N("", !0), P(e).siteTitle ? (M(), O("span", Zw, q(P(e).siteTitle), 1)) : P(e).siteTitle === void 0 ? (M(), O("span", tk, q(P(t).title), 1)) : N("", !0), $(l.$slots, "nav-bar-title-after", {}, void 0, !0)], 8, Qw)], 2)) } }), nk = J(ek, [["__scopeId", "data-v-0ad69264"]]), sk = { class: "items" }, ik = { class: "title" }, ok = z({ __name: "VPNavBarTranslations", setup (n) { const { theme: t } = it(), { localeLinks: e, currentLang: s } = fs({ correspondingLink: !0 }); return (i, o) => P(e).length && P(s).label ? (M(), W(la, { key: 0, class: "VPNavBarTranslations", icon: "vpi-languages", label: P(t).langMenuLabel || "Change language" }, { default: D(() => [_("div", sk, [_("p", ik, q(P(s).label), 1), (M(!0), O(dt, null, Et(P(e), a => (M(), W(Mi, { key: a.link, item: a }, null, 8, ["item"]))), 128))])]), _: 1 }, 8, ["label"])) : N("", !0) } }), ak = J(ok, [["__scopeId", "data-v-acee064b"]]), rk = n => (Ft("data-v-9fd4d1dd"), n = n(), Vt(), n), lk = { class: "wrapper" }, ck = { class: "container" }, dk = { class: "title" }, uk = { class: "content" }, hk = { class: "content-body" }, fk = rk(() => _("div", { class: "divider" }, [_("div", { class: "divider-line" })], -1)), pk = z({ __name: "VPNavBar", props: { isScreenOpen: { type: Boolean } }, emits: ["toggle-screen"], setup (n) { const t = n, { y: e } = vl(), { hasSidebar: s } = Ce(), { frontmatter: i } = it(), o = et({}); return Do(() => { o.value = { "has-sidebar": s.value, home: i.value.layout === "home", top: e.value === 0, "screen-open": t.isScreenOpen } }), (a, r) => (M(), O("div", { class: Q(["VPNavBar", o.value]) }, [_("div", lk, [_("div", ck, [_("div", dk, [j(nk, null, { "nav-bar-title-before": D(() => [$(a.$slots, "nav-bar-title-before", {}, void 0, !0)]), "nav-bar-title-after": D(() => [$(a.$slots, "nav-bar-title-after", {}, void 0, !0)]), _: 3 })]), _("div", uk, [_("div", hk, [$(a.$slots, "nav-bar-content-before", {}, void 0, !0), j(Xw, { class: "search" }), j(Vw, { class: "menu" }), j(ak, { class: "translations" }), j(j1, { class: "appearance" }), j(Jw, { class: "social-links" }), j(Sw, { class: "extra" }), $(a.$slots, "nav-bar-content-after", {}, void 0, !0), j(Lw, { class: "hamburger", active: a.isScreenOpen, onClick: r[0] || (r[0] = l => a.$emit("toggle-screen")) }, null, 8, ["active"])])])])]), fk], 2)) } }), gk = J(pk, [["__scopeId", "data-v-9fd4d1dd"]]), mk = { key: 0, class: "VPNavScreenAppearance" }, bk = { class: "text" }, vk = z({ __name: "VPNavScreenAppearance", setup (n) { const { site: t, theme: e } = it(); return (s, i) => P(t).appearance && P(t).appearance !== "force-dark" && P(t).appearance !== "force-auto" ? (M(), O("div", mk, [_("p", bk, q(P(e).darkModeSwitchLabel || "Appearance"), 1), j(aa)])) : N("", !0) } }), _k = J(vk, [["__scopeId", "data-v-a3e2920d"]]), yk = z({ __name: "VPNavScreenMenuLink", props: { item: {} }, setup (n) { const t = as("close-screen"); return (e, s) => (M(), W(pe, { class: "VPNavScreenMenuLink", href: e.item.link, target: e.item.target, rel: e.item.rel, onClick: P(t), innerHTML: e.item.text }, null, 8, ["href", "target", "rel", "onClick", "innerHTML"])) } }), xk = J(yk, [["__scopeId", "data-v-1a934d60"]]), wk = z({ __name: "VPNavScreenMenuGroupLink", props: { item: {} }, setup (n) { const t = as("close-screen"); return (e, s) => (M(), W(pe, { class: "VPNavScreenMenuGroupLink", href: e.item.link, target: e.item.target, rel: e.item.rel, onClick: P(t) }, { default: D(() => [Lt(q(e.item.text), 1)]), _: 1 }, 8, ["href", "target", "rel", "onClick"])) } }), Zc = J(wk, [["__scopeId", "data-v-aea78dd1"]]), kk = { class: "VPNavScreenMenuGroupSection" }, Sk = { key: 0, class: "title" }, Mk = z({ __name: "VPNavScreenMenuGroupSection", props: { text: {}, items: {} }, setup (n) { return (t, e) => (M(), O("div", kk, [t.text ? (M(), O("p", Sk, q(t.text), 1)) : N("", !0), (M(!0), O(dt, null, Et(t.items, s => (M(), W(Zc, { key: s.text, item: s }, null, 8, ["item"]))), 128))])) } }), Pk = J(Mk, [["__scopeId", "data-v-f60dbfa7"]]), Ck = n => (Ft("data-v-d99bfeec"), n = n(), Vt(), n), Tk = ["aria-controls", "aria-expanded"], Ok = ["innerHTML"], Lk = Ck(() => _("span", { class: "vpi-plus button-icon" }, null, -1)), Ak = ["id"], $k = { key: 0, class: "item" }, Dk = { key: 1, class: "item" }, Ek = { key: 2, class: "group" }, Rk = z({ __name: "VPNavScreenMenuGroup", props: { text: {}, items: {} }, setup (n) { const t = n, e = et(!1), s = K(() => `NavScreenGroup-${t.text.replace(" ", "-").toLowerCase()}`); function i () { e.value = !e.value } return (o, a) => (M(), O("div", { class: Q(["VPNavScreenMenuGroup", { open: e.value }]) }, [_("button", { class: "button", "aria-controls": s.value, "aria-expanded": e.value, onClick: i }, [_("span", { class: "button-text", innerHTML: o.text }, null, 8, Ok), Lk], 8, Tk), _("div", { id: s.value, class: "items" }, [(M(!0), O(dt, null, Et(o.items, r => (M(), O(dt, { key: JSON.stringify(r) }, ["link" in r ? (M(), O("div", $k, [j(Zc, { item: r }, null, 8, ["item"])])) : "component" in r ? (M(), O("div", Dk, [(M(), W(he(r.component), Ie({ ref_for: !0 }, r.props, { "screen-menu": "" }), null, 16))])) : (M(), O("div", Ek, [j(Pk, { text: r.text, items: r.items }, null, 8, ["text", "items"])]))], 64))), 128))], 8, Ak)], 2)) } }), Ik = J(Rk, [["__scopeId", "data-v-d99bfeec"]]), Nk = { key: 0, class: "VPNavScreenMenu" }, Fk = z({ __name: "VPNavScreenMenu", setup (n) { const { theme: t } = it(); return (e, s) => P(t).nav ? (M(), O("nav", Nk, [(M(!0), O(dt, null, Et(P(t).nav, i => (M(), O(dt, { key: JSON.stringify(i) }, ["link" in i ? (M(), W(xk, { key: 0, item: i }, null, 8, ["item"])) : "component" in i ? (M(), W(he(i.component), Ie({ key: 1, ref_for: !0 }, i.props, { "screen-menu": "" }), null, 16)) : (M(), W(Ik, { key: 2, text: i.text || "", items: i.items }, null, 8, ["text", "items"]))], 64))), 128))])) : N("", !0) } }), Vk = z({ __name: "VPNavScreenSocialLinks", setup (n) { const { theme: t } = it(); return (e, s) => P(t).socialLinks ? (M(), W(ca, { key: 0, class: "VPNavScreenSocialLinks", links: P(t).socialLinks }, null, 8, ["links"])) : N("", !0) } }), td = n => (Ft("data-v-516e4bc3"), n = n(), Vt(), n), Bk = td(() => _("span", { class: "vpi-languages icon lang" }, null, -1)), zk = td(() => _("span", { class: "vpi-chevron-down icon chevron" }, null, -1)), jk = { class: "list" }, Hk = z({ __name: "VPNavScreenTranslations", setup (n) { const { localeLinks: t, currentLang: e } = fs({ correspondingLink: !0 }), s = et(!1); function i () { s.value = !s.value } return (o, a) => P(t).length && P(e).label ? (M(), O("div", { key: 0, class: Q(["VPNavScreenTranslations", { open: s.value }]) }, [_("button", { class: "title", onClick: i }, [Bk, Lt(" " + q(P(e).label) + " ", 1), zk]), _("ul", jk, [(M(!0), O(dt, null, Et(P(t), r => (M(), O("li", { key: r.link, class: "item" }, [j(pe, { class: "link", href: r.link }, { default: D(() => [Lt(q(r.text), 1)]), _: 2 }, 1032, ["href"])]))), 128))])], 2)) : N("", !0) } }), Wk = J(Hk, [["__scopeId", "data-v-516e4bc3"]]), Uk = { class: "container" }, Yk = z({ __name: "VPNavScreen", props: { open: { type: Boolean } }, setup (n) { const t = et(null), e = _l(hi ? document.body : null); return (s, i) => (M(), W(li, { name: "fade", onEnter: i[0] || (i[0] = o => e.value = !0), onAfterLeave: i[1] || (i[1] = o => e.value = !1) }, { default: D(() => [s.open ? (M(), O("div", { key: 0, class: "VPNavScreen", ref_key: "screen", ref: t, id: "VPNavScreen" }, [_("div", Uk, [$(s.$slots, "nav-screen-content-before", {}, void 0, !0), j(Fk, { class: "menu" }), j(Wk, { class: "translations" }), j(_k, { class: "appearance" }), j(Vk, { class: "social-links" }), $(s.$slots, "nav-screen-content-after", {}, void 0, !0)])], 512)) : N("", !0)]), _: 3 })) } }), Kk = J(Yk, [["__scopeId", "data-v-2dd6d0c7"]]), qk = { key: 0, class: "VPNav" }, Xk = z({ __name: "VPNav", setup (n) { const { isScreenOpen: t, closeScreen: e, toggleScreen: s } = L1(), { frontmatter: i } = it(), o = K(() => i.value.navbar !== !1); return yl("close-screen", e), ci(() => { hi && document.documentElement.classList.toggle("hide-nav", !o.value) }), (a, r) => o.value ? (M(), O("header", qk, [j(gk, { "is-screen-open": P(t), onToggleScreen: P(s) }, { "nav-bar-title-before": D(() => [$(a.$slots, "nav-bar-title-before", {}, void 0, !0)]), "nav-bar-title-after": D(() => [$(a.$slots, "nav-bar-title-after", {}, void 0, !0)]), "nav-bar-content-before": D(() => [$(a.$slots, "nav-bar-content-before", {}, void 0, !0)]), "nav-bar-content-after": D(() => [$(a.$slots, "nav-bar-content-after", {}, void 0, !0)]), _: 3 }, 8, ["is-screen-open", "onToggleScreen"]), j(Kk, { open: P(t) }, { "nav-screen-content-before": D(() => [$(a.$slots, "nav-screen-content-before", {}, void 0, !0)]), "nav-screen-content-after": D(() => [$(a.$slots, "nav-screen-content-after", {}, void 0, !0)]), _: 3 }, 8, ["open"])])) : N("", !0) } }), Gk = J(Xk, [["__scopeId", "data-v-7ad780c2"]]), ed = n => (Ft("data-v-edd2eed8"), n = n(), Vt(), n), Jk = ["role", "tabindex"], Qk = ed(() => _("div", { class: "indicator" }, null, -1)), Zk = ed(() => _("span", { class: "vpi-chevron-right caret-icon" }, null, -1)), tS = [Zk], eS = { key: 1, class: "items" }, nS = z({ __name: "VPSidebarItem", props: { item: {}, depth: {} }, setup (n) { const t = n, { collapsed: e, collapsible: s, isLink: i, isActiveLink: o, hasActiveLink: a, hasChildren: r, toggle: l } = xy(K(() => t.item)), c = K(() => r.value ? "section" : "div"), d = K(() => i.value ? "a" : "div"), u = K(() => r.value ? t.depth + 2 === 7 ? "p" : `h${t.depth + 2}` : "p"), h = K(() => i.value ? void 0 : "button"), f = K(() => [[`level-${t.depth}`], { collapsible: s.value }, { collapsed: e.value }, { "is-link": i.value }, { "is-active": o.value }, { "has-active": a.value }]); function g (v) { "key" in v && v.key !== "Enter" || !t.item.link && l() } function m () { t.item.link && l() } return (v, p) => { const b = Qt("VPSidebarItem", !0); return M(), W(he(c.value), { class: Q(["VPSidebarItem", f.value]) }, { default: D(() => [v.item.text ? (M(), O("div", Ie({ key: 0, class: "item", role: h.value }, wd(v.item.items ? { click: g, keydown: g } : {}, !0), { tabindex: v.item.items && 0 }), [Qk, v.item.link ? (M(), W(pe, { key: 0, tag: d.value, class: "link", href: v.item.link, rel: v.item.rel, target: v.item.target }, { default: D(() => [(M(), W(he(u.value), { class: "text", innerHTML: v.item.text }, null, 8, ["innerHTML"]))]), _: 1 }, 8, ["tag", "href", "rel", "target"])) : (M(), W(he(u.value), { key: 1, class: "text", innerHTML: v.item.text }, null, 8, ["innerHTML"])), v.item.collapsed != null && v.item.items && v.item.items.length ? (M(), O("div", { key: 2, class: "caret", role: "button", "aria-label": "toggle section", onClick: m, onKeydown: kd(m, ["enter"]), tabindex: "0" }, tS, 32)) : N("", !0)], 16, Jk)) : N("", !0), v.item.items && v.item.items.length ? (M(), O("div", eS, [v.depth < 5 ? (M(!0), O(dt, { key: 0 }, Et(v.item.items, y => (M(), W(b, { key: y.text, item: y, depth: v.depth + 1 }, null, 8, ["item", "depth"]))), 128)) : N("", !0)])) : N("", !0)]), _: 1 }, 8, ["class"]) } } }), sS = J(nS, [["__scopeId", "data-v-edd2eed8"]]), iS = z({ __name: "VPSidebarGroup", props: { items: {} }, setup (n) { const t = et(!0); let e = null; return Se(() => { e = setTimeout(() => { e = null, t.value = !1 }, 300) }), Sd(() => { e != null && (clearTimeout(e), e = null) }), (s, i) => (M(!0), O(dt, null, Et(s.items, o => (M(), O("div", { key: o.text, class: Q(["group", { "no-transition": t.value }]) }, [j(sS, { item: o, depth: 0 }, null, 8, ["item"])], 2))), 128)) } }), oS = J(iS, [["__scopeId", "data-v-51288d80"]]), nd = n => (Ft("data-v-42c4c606"), n = n(), Vt(), n), aS = nd(() => _("div", { class: "curtain" }, null, -1)), rS = { class: "nav", id: "VPSidebarNav", "aria-labelledby": "sidebar-aria-label", tabindex: "-1" }, lS = nd(() => _("span", { class: "visually-hidden", id: "sidebar-aria-label" }, " Sidebar Navigation ", -1)), cS = z({ __name: "VPSidebar", props: { open: { type: Boolean } }, setup (n) { const { sidebarGroups: t, hasSidebar: e } = Ce(), s = n, i = et(null), o = _l(hi ? document.body : null); ne([s, i], () => { var r; s.open ? (o.value = !0, (r = i.value) == null || r.focus()) : o.value = !1 }, { immediate: !0, flush: "post" }); const a = et(0); return ne(t, () => { a.value += 1 }, { deep: !0 }), (r, l) => P(e) ? (M(), O("aside", { key: 0, class: Q(["VPSidebar", { open: r.open }]), ref_key: "navEl", ref: i, onClick: l[0] || (l[0] = sn(() => { }, ["stop"])) }, [aS, _("nav", rS, [lS, $(r.$slots, "sidebar-nav-before", {}, void 0, !0), (M(), W(oS, { items: P(t), key: a.value }, null, 8, ["items"])), $(r.$slots, "sidebar-nav-after", {}, void 0, !0)])], 2)) : N("", !0) } }), dS = J(cS, [["__scopeId", "data-v-42c4c606"]]), uS = z({ __name: "VPSkipLink", setup (n) { const t = ui(), e = et(); ne(() => t.path, () => e.value.focus()); function s ({ target: i }) { const o = document.getElementById(decodeURIComponent(i.hash).slice(1)); if (o) { const a = () => { o.removeAttribute("tabindex"), o.removeEventListener("blur", a) }; o.setAttribute("tabindex", "-1"), o.addEventListener("blur", a), o.focus(), window.scrollTo(0, 0) } } return (i, o) => (M(), O(dt, null, [_("span", { ref_key: "backToTop", ref: e, tabindex: "-1" }, null, 512), _("a", { href: "#VPContent", class: "VPSkipLink visually-hidden", onClick: s }, " Skip to content ")], 64)) } }), hS = J(uS, [["__scopeId", "data-v-c8291ffa"]]), fS = z({ __name: "Layout", setup (n) { const { isOpen: t, open: e, close: s } = Ce(), i = ui(); ne(() => i.path, s), yy(t, s); const { frontmatter: o } = it(), a = Md(), r = K(() => !!a["home-hero-image"]); return yl("hero-image-slot-exists", r), (l, c) => { const d = Qt("Content"); return P(o).layout !== !1 ? (M(), O("div", { key: 0, class: Q(["Layout", P(o).pageClass]) }, [$(l.$slots, "layout-top", {}, void 0, !0), j(hS), j(oy, { class: "backdrop", show: P(t), onClick: P(s) }, null, 8, ["show", "onClick"]), j(Gk, null, { "nav-bar-title-before": D(() => [$(l.$slots, "nav-bar-title-before", {}, void 0, !0)]), "nav-bar-title-after": D(() => [$(l.$slots, "nav-bar-title-after", {}, void 0, !0)]), "nav-bar-content-before": D(() => [$(l.$slots, "nav-bar-content-before", {}, void 0, !0)]), "nav-bar-content-after": D(() => [$(l.$slots, "nav-bar-content-after", {}, void 0, !0)]), "nav-screen-content-before": D(() => [$(l.$slots, "nav-screen-content-before", {}, void 0, !0)]), "nav-screen-content-after": D(() => [$(l.$slots, "nav-screen-content-after", {}, void 0, !0)]), _: 3 }), j(O1, { open: P(t), onOpenMenu: P(e) }, null, 8, ["open", "onOpenMenu"]), j(dS, { open: P(t) }, { "sidebar-nav-before": D(() => [$(l.$slots, "sidebar-nav-before", {}, void 0, !0)]), "sidebar-nav-after": D(() => [$(l.$slots, "sidebar-nav-after", {}, void 0, !0)]), _: 3 }, 8, ["open"]), j(c1, null, { "page-top": D(() => [$(l.$slots, "page-top", {}, void 0, !0)]), "page-bottom": D(() => [$(l.$slots, "page-bottom", {}, void 0, !0)]), "not-found": D(() => [$(l.$slots, "not-found", {}, void 0, !0)]), "home-hero-before": D(() => [$(l.$slots, "home-hero-before", {}, void 0, !0)]), "home-hero-info-before": D(() => [$(l.$slots, "home-hero-info-before", {}, void 0, !0)]), "home-hero-info": D(() => [$(l.$slots, "home-hero-info", {}, void 0, !0)]), "home-hero-info-after": D(() => [$(l.$slots, "home-hero-info-after", {}, void 0, !0)]), "home-hero-actions-after": D(() => [$(l.$slots, "home-hero-actions-after", {}, void 0, !0)]), "home-hero-image": D(() => [$(l.$slots, "home-hero-image", {}, void 0, !0)]), "home-hero-after": D(() => [$(l.$slots, "home-hero-after", {}, void 0, !0)]), "home-features-before": D(() => [$(l.$slots, "home-features-before", {}, void 0, !0)]), "home-features-after": D(() => [$(l.$slots, "home-features-after", {}, void 0, !0)]), "doc-footer-before": D(() => [$(l.$slots, "doc-footer-before", {}, void 0, !0)]), "doc-before": D(() => [$(l.$slots, "doc-before", {}, void 0, !0)]), "doc-after": D(() => [$(l.$slots, "doc-after", {}, void 0, !0)]), "doc-top": D(() => [$(l.$slots, "doc-top", {}, void 0, !0)]), "doc-bottom": D(() => [$(l.$slots, "doc-bottom", {}, void 0, !0)]), "aside-top": D(() => [$(l.$slots, "aside-top", {}, void 0, !0)]), "aside-bottom": D(() => [$(l.$slots, "aside-bottom", {}, void 0, !0)]), "aside-outline-before": D(() => [$(l.$slots, "aside-outline-before", {}, void 0, !0)]), "aside-outline-after": D(() => [$(l.$slots, "aside-outline-after", {}, void 0, !0)]), "aside-ads-before": D(() => [$(l.$slots, "aside-ads-before", {}, void 0, !0)]), "aside-ads-after": D(() => [$(l.$slots, "aside-ads-after", {}, void 0, !0)]), _: 3 }), j(p1), $(l.$slots, "layout-bottom", {}, void 0, !0)], 2)) : (M(), W(d, { key: 1 })) } } }), pS = J(fS, [["__scopeId", "data-v-d8b57b2d"]]), rl = { Layout: pS, enhanceApp: ({ app: n }) => { n.component("Badge", ny) } }; function gS (n) { return typeof n == "object" && n !== null } function ll (n, t) { return n = gS(n) ? n : Object.create(null), new Proxy(n, { get (e, s, i) { return s === "key" ? Reflect.get(e, s, i) : Reflect.get(e, s, i) || Reflect.get(t, s, i) } }) } function mS (n, t) { return t.reduce((e, s) => e == null ? void 0 : e[s], n) } function bS (n, t, e) { return t.slice(0, -1).reduce((s, i) => /^(__proto__)$/.test(i) ? {} : s[i] = s[i] || {}, n)[t[t.length - 1]] = e, n } function vS (n, t) { return t.reduce((e, s) => { const i = s.split("."); return bS(e, i, mS(n, i)) }, {}) } function _S (n, t) { return e => { var s; try { const { storage: i = localStorage, beforeRestore: o = void 0, afterRestore: a = void 0, serializer: r = { serialize: JSON.stringify, deserialize: JSON.parse }, key: l = t.$id, paths: c = null, debug: d = !1 } = e; return { storage: i, beforeRestore: o, afterRestore: a, serializer: r, key: ((s = n.key) != null ? s : u => u)(typeof l == "string" ? l : l(t.$id)), paths: c, debug: d } } catch (i) { return e.debug && console.error("[pinia-plugin-persistedstate]", i), null } } } function cl (n, { storage: t, serializer: e, key: s, debug: i }) { try { const o = t == null ? void 0 : t.getItem(s); o && n.$patch(e == null ? void 0 : e.deserialize(o)) } catch (o) { i && console.error("[pinia-plugin-persistedstate]", o) } } function dl (n, { storage: t, serializer: e, key: s, paths: i, debug: o }) { try { const a = Array.isArray(i) ? vS(n, i) : n; t.setItem(s, e.serialize(a)) } catch (a) { o && console.error("[pinia-plugin-persistedstate]", a) } } function yS (n = {}) { return t => { const { auto: e = !1 } = n, { options: { persist: s = e }, store: i, pinia: o } = t; if (!s) return; if (!(i.$id in o.state.value)) { const r = o._s.get(i.$id.replace("__hot:", "")); r && Promise.resolve().then(() => r.$persist()); return } const a = (Array.isArray(s) ? s.map(r => ll(r, n)) : [ll(s, n)]).map(_S(n, i)).filter(Boolean); i.$persist = () => { a.forEach(r => { dl(i.$state, r) }) }, i.$hydrate = ({ runHooks: r = !0 } = {}) => { a.forEach(l => { const { beforeRestore: c, afterRestore: d } = l; r && (c == null || c(t)), cl(i, l), r && (d == null || d(t)) }) }, a.forEach(r => { const { beforeRestore: l, afterRestore: c } = r; l == null || l(t), cl(i, r), c == null || c(t), i.$subscribe((d, u) => { dl(u, r) }, { detached: !0 }) }) } } const SS = { extends: rl, Layout: () => Pd(rl.Layout, null, {}), enhanceApp ({ app: n, router: t, siteData: e }) { const s = Kd(); s.use(yS({ auto: !0 })), n.use(s), Object.entries(Object.assign({ "./components/CAlert.vue": Id, "./components/CButton.vue": Bd, "./components/CSpinner.vue": Ud, "./components/LayoutDashboard.vue": Df, "./components/PageApiKeys.vue": Sp, "./components/PageDashboard.vue": Hv, "./components/PageLogin.vue": a_, "./components/PagePasswordReset.vue": D_, "./components/PageRegister.vue": ey })).forEach(([o, a]) => { var r; if (o) { const l = (r = o.split("/").pop()) == null ? void 0 : r.replace(/\.\w+$/, ""); l && n.component(l, a.default) } }) } }; export { SS as R };
